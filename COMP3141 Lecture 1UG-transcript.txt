SPEAKER 0
Uh, excellent. Ok, that's going to complain. Yes. Alrighty. That one. Uh, okey dokey. Sorry. Lots of teething problems as always. And a very slow screen. Apparently, Um, I'm just making sure I'm logged into the chat because, uh, yeah, so keep an eye on the content, see if anyone posts any things. OK? Doke. Um hi, everyone. Welcome. Welcome to term two, I guess. Well, it was wel welcome for me. Um, who's who's had lectures already this week? About half of you. OK, so I haven't so it's just like I'm I'm still reeling from last term, Actually, it's like it was, um I was doing exams on Friday, so it still from last term. So that's why um it seems a little bit haphazard at the moment. And I apologise for get, uh, being a bit late, getting everything set up, but, um, hopefully, uh, going forward. This will, This will be, uh, much better. So welcome to comp 3141, which is and I can never remember the title I've copied and pasted about five times because I can't remember it. Software system design and implementation, which is complete misnomer. Um, because, well, um It's nothing to do with system design. Um, very little to do with system implementation. Um, nothing to do with software design so much So we kind of we're kind of looking for perhaps a new name for the course. Any suggestions? Any thoughts? High school course. Thank you. Thank you. Thank you. Thank you. Oh, yes. No. Um so one thing about me, incidentally, my name's Paul. Um, if you don't know this, it's on this slide. Um, I, um I like to reward questions, so thank you. Your name? Amber. Thank you, Amber. First question. First answer. Yes. Haskell Course. OK, Why? Why do you want to call it the Haskell course? That's what everyone calls it. That's what I called it. I called it the Haskell course. It's the Haskell course. Except, um, this is not you're not in first year. Probably. Is anyone in first year? If you are, it's OK. It's OK, right? So OK, it's not It's not a first year course, so I'm not gonna teach you how to programme. You know how to programme. Oh, I'm gonna teach you how to programme. I'm gonna teach you how to programme differently, right? I the whole point of this course. The reason why it's the high school course why you're learning has school is because, um, this is supposed to open your eyes to a different kind of programming, right? High school, um, is what's known as falls under the category of a functional programming language, and it's a completely different what we call paradigm. Um, when it comes to programming and paradigms are what dictate, Um, basically, how we go about designing different, different programming languages now who who knows more than one programming language here. Good, good, good. Most people. So, um what what programme? Languages. Do you know rust? Javascript, Java. See? Ok. Yes. Excellent. Great. Thank you. Sorry. What was your name? Uh, Adrian. Thank you, Adrian. Oh, this is no. So I did run a 10-K on the weekend, so, I I can actually get up the stairs. Um, but I might not be able to do it for the full two hours. Um, yes. So rust. See Java. I know two languages, two programming languages, java and, um, javascript. It's like, um, no, I know a little bit of high school. Um, when I was introduced to high school. Um, in my undergraduate, um, it was eye opening. It was so amazing. It was like I was like, this is mind blowing. How? Why is why didn't I not know about this kind of programming before? And so this is why I'm really I'm super keen to take on this course. Um, because I found high school such such a sort of revelation. Uh, when it came, came to came to programming languages. So it's such a such a different thing now. Uh OK, so you you know you know C, you know, rust. Why do we have so many programming languages? Yep. Different attempts at discussing algorithms. Yep. Thank you. Your name? Ay, I'm not. I'm I'm gonna remember a few. How come everyone's name begins with a Can we move on to the BS or something? Um, so anyone whose name begins with B, why do we have different programming languages? Yes, People think they can do better. What's your name? Brodie. Oh, someone called me. Thank you, Brodie. Ok, um people think they can do better. Better than what? Every other language. Ok, so why do we still teach? CC has been around for 50 years. It's too good. Can we do better than C? Assemble? Why? Ok, why is assembler better than C? High performance high. Why is C better than assembler? Easier to write and less tedious. Why do we? Why is rust the big thing now? Memory safety. So C sucks at memory safety, right? So they said Oh, I need to do better than than memory safety. I need to do C. Uh oh. Sorry. I need to I need to do rust. Um but what other languages are there? Well, if you Google like what? The the top top 10, Um, software development. Uh, what did I say? The the the best paying software development, Um, languages to learn. Um, in 2024. If you look at the list, I think I If I remember I, I looked it up this morning. It was way too early. Um, I think about five of them are functional programming languages. So erlang is second on the list. Um go, go. No go is not on the list anymore. Um, but yeah, and Ang is is my is one of my favourites. F Sharp is another one, right? So what? So What's what's the deal with functional languages? Why are we so interested in these functional programming languages? You know this This this paradigm that you probably haven't come across who's come across functional programming before? Yep. Cos you've done rust. Yes, and you've done three. OK, 3161. Yes. If you've done 3161, you probably come across that sort of thing. Excellent, Yes. Why So So, Adrian, Why What what's what's so good about functional programming? OK, there's no state that you have to manage. Is that a good thing? Sometimes Sometimes that's the key thing. Sometimes it's a good thing, right? Um, sometimes it's a terrible thing. Sometimes it's really hard. Like, for instance, printing hello world in high school is really tricky because you can't manage state. Right? Um, So, um, but doing other things in high school is really, really quite easy now, Um, so we're kind of interested in in looking at different, different, uh, different ways of doing sort of a programming, A programming approach, and this course is half of it's gonna be teaching you high school, but the other half there's like, whole half of the course. That's all. Basically, all my lectures are gonna be teaching you. Why? Why are we learning this other paradigm? What's the point? Right? And the the whole Haskell aspect of it. Thank you, Amber. We won't. We'll call it the Haskell, but not a Haskell course. This, I think, is what it's also known as, um the Haskell, but not a Haskell course, because Haskell is just merely a tool right for explaining being able to explain, Um, all the the key ideas that we're gonna be talking about today or not today This this term this term? Um, So, um, so a little bit about me, Um, you know my name now? Um oh, no. First, better acknowledge the, um the traditional owners and custodians of the land on which UN SW is built. The medical people, um, and to elders, past and present, right now, a bit about me. And why aren't you advancing? So my, uh my name's Paul. Call me Paul. Doctor Hunter. Hey, you. Um I'm a lecturer here. I do a lot of lecturing. I lecture. Um, So last term, I was teaching comp 4141, so I'll keep, um, inadvertently making that typo Because I keep keep doing that. Um, So if if you see anything that says C 4141 Just pretend it says 3141. I also taught, uh, CO 9020, which is foundations of computer science, which is the discrete maths for the M for the masters students. And I teach it better than you. You did. You probably did discrete maths because I teach it with a computer science spin. And if you took, if you took C 9020, a lot of the stuff that we're gonna be talking about is going to be easy peasy. Unfortunately, most of you probably took discrete maths from the maths department. They've got a little bit of a different spin on it. Um, you don't need to know that stuff. We'll talk about that a little bit later. Um, but it's good if you've seen it before because we're gonna refresh your memory on all of those things. Um, anyway, what else do I do? So, uh, my area of of research a while back was formal verification. Um, that's about proving programmes. Do what they're supposed to do. Uh, which is kind of the point, Right? Kind of where we're at here, what we're going to be doing. Um, but my also interest sort of delve a little bit into graph theory. Um, as I said, I'm now doing a lot of lecturing. Um and, um, I ran out of things to think about, so I added making lists to my list of things. Um, and this is the first time I've taken this course. So I'm with most who who's taken this course before? Not you. Rafael. I know you. Yes, OK, right. So you're already ahead of me. So So, um are we learning? So what's your name? Uh huh. Anna as another A Oh, gosh. OK, right. Um yeah. OK, so remember. OK, so, like OK? Yep. Fine, right. I'll be leaning on you to explain any concept. I. I don't understand. Thank you very much, Anna. Um, yes. So this is the first time I taught this course. However, as I said, um, I my area of expertise is behind the theory that underpins everything we're gonna be talking about. And the reason and hopefully I can sort of convey why. Why? This is such a good thing. Why? This is such an interesting thing. Perhaps, um, when it comes to the end of the course, you may. Well, yeah, you should be relatively proficient in high school, Hopefully. But more importantly, you should be familiar with some of the ideas that we're talking about. If you never touch Haskell again after this course, that's fine. That's great. But what you'll do is you'll take other courses like the rust course, and you'll see some of the elements that we've been talking about in this course C crop crop up. I know I talked to Paula Tennant. Um, those who everyone knows Paula. She's a student representative. So hopefully you know her. Um, yes, um, about this course and she said, um, if it wasn't for this course, the Russ course would have been completely different, right? So if you're interested in taking the Russ course, this course is a really good precursor to that. Anyway, um, helping me out, Um, apart from Anna, um, is Raphael So do you want to say it's a few words or I'm Raphael or Rath?

SPEAKER 1
Um, I am, uh, I've worked on the course for the past couple of years. I'm a high school enthusiast and sort of, you know, I tutor various courses in the CS E department. Um, yeah. I think it will be fun to do one of the practical things.

SPEAKER 0
Yep. So I've I've collared rough into help helping me with the with the practical aspect of this this course, Um, because I say I'm a little bit rusty on on high school myself. Um, So I'm gonna sit in the audience and, like, pay attention. Um, he has to leave about halfway through, so his his lectures will be delivered sort of online, and maybe it will become a Q and a type session. Um, those are like to be on the Fridays. Not this Friday, but from from next week onwards, Um, and I'm currently trying to work out, um, some help sessions. Um, I've I've Sorry, I've I inherited this course from Johannes. I should mention most of this material is, um, courtesy of Johannes, who was was courtesy of Liam. Um, who took the course before him. Um um So I'm hoping to set up some help sessions. Um, and I'm sort of like S seeing if there's any lab space so we can help have the help sessions in the labs. If not, there are gonna be help sessions in a in a tutorial room. And I'll get some tutors who have also taken this course, Um, to help with those. And so the staff, they'll have, um, good experience with high school as well. Um, in terms of contacting us. Um, so the course website is wrong there because it doesn't. We don't do HTTP anymore. It's all HTPS. Um, the main point of contact for you guys is the Ed forum. Uh, well, the best point of contact is the Ed Forum. If you haven't, uh, received an email inviting you, you I've set up the join function, so just click there and add, uh, join up. Um, please post questions there. Please post public questions there so that everyone can see the questions. Because if you have a question I can guarantee this course has 500 people. I can guarantee there's at least 30 people that have the same question at least. Alright. Um and so by posting it publicly, it, um it lets us sort of identify where our weaknesses in in lecturing are as well. And, um lets other people see that, and it stops us having to answer the same question 12 times. Um, if you need to contact me directly, um, or the sorry, the course authority directly the C S3 141. email address. Um, we'll do that. Um, I'm more than happy for you to contact me directly by my email as well. Some people aren't. These are just sort of left leftover slides. Um, in terms of, uh, material. I'm quite happy for any question to be asked. Um, if it feel if I feel like it's encroaching a little bit on the assessments, I might defer you to say, Please ask this privately or I might just sort of give you a vague answer. That's not that. That's that's hopefully more encouraging you to, um, think about the think about the direction in which to go yourself. There are no tutorials for this course. So most of the course you have to do through self learning, um, and all the help sessions when they come through, um, as always, beyond sort of myself, Rafael and the other members of staff taking, uh, helping out with this course, um, you can always reach out if there's if you need any help through through the university student services. Um, as it says here, screenshot this slide don't bother screenshotting the slide. All the slides are available on the course website. Um, I will try and get a little bit ahead, so you can, uh, can post the slides a little bit earlier than, like, the the night before. Um, but please keep in mind that the slides may change, um, up to up to the delivery of the lecture. So I've kind of started talking about what this course is, so it's like, um so let's sort of boil down. So is the high school, not a high school course. Thanks, amber. Um but, um, I think Johannes summed it up quite well last year when he said, um, a better title for this would be, um, an introduction to mathematically. What was it? Mathematically oriented programming mathematically supported programming? I can't remember exactly. Um and so that's the whole point, right? It's not. It's not about Haskell itself. It's about why Haskell, um alright. And so this is this is sort of like, often portrayed as a bit of a trade off. A bit of a tug of war. When you're developing software you've got, On the one hand, you've got competing competing priorities. On the one hand, you need to develop. Um, your software needs to be developed quickly. Um, needs to be developed cheaply. Right? So companies building this, this software, uh, building the software, you need to put this push this out. You've got users that that want to see see the software today or yesterday. Um, and, um and of course, you don't want to pay people to. You don't want to pay like 100 people to do it when you can pay 10 people to do that. On the other hand, sort of sort of pushing against this a little bit. We also want our software to be correct, and we want it to be safe, and we want it to be secure, right, And this is sort of portrayed as a tug of war. But I like to think of this. This is actually kind of more like a spectrum of software, right? You can have software that's developed fast quickly. Maybe buggy, maybe cheap. You can have software that takes time to develop, right? And you can have sort of, like, sort of any anything in between, right? Sometimes people say 80% if it runs 80% of the time. Um, 80% of the time, then that's good enough. That's fine. That's all well and good. Um, and then you you run your programme and you get something like this. Alright? And they go, Well, that's fine. We'll just patch it in the next release. Um, and they deal with that. And this is this is this is not a problem, right? Because, well, it's just it's just a glitch. Right? Does it? Does it affect you playing the game? Well, this particular instance probably wouldn't affect you playing the game, right? Maybe. Maybe you can reach some some things, right? So some bugs are acceptable because it's it's OK to have some bugs. Um, and but at the end of the day, nobody's gonna die because of a bug in a video game. Right? So why are we interested in removing bugs?

SPEAKER 2
Yep.

SPEAKER 0
Safety critical software. So what's some safety? Are you looking ahead? Are you where you fly?

SPEAKER 2
Do the airlines? The flight manager Yes.

SPEAKER 0
Oh, the airlines is always a good one. Yes, thank you. Sorry. Your name? Michael. Something that doesn't begin with that. Thank you. Michael. Yes. Airlines flights. Brodie had something. You put your hand up. Banks? Yes. You've already had one? Yes. Medical? Yes. What's your name? Lucas. Thank you, Lucas. Yes. Medical medical things, right. So you write software in X-ray. People write software for X ray machines. Right. So now the x-ray operator pushes a button, and the software goes off and tells how much of a dose to give If there's a bug in that software and suddenly your patient gets an I, um, an unhealthy dose of radiation. Whose fault is it? Is it the operators, but for pushing the button? Is it the software developer for writing buggy code? Is it the software developer's manager for not checking the buggy code? Right. It gets a little bit hairy, but like, you know, you start to think sometimes we do have to put a lot of effort into come on that side, that side of the equation, right? We don't want planes to fall out of the sky. Tesla implementing driving systems right at the moment. They, um somebody just recently just had a court case where the the Tesla's automated driving system didn't detect a train. Right. So we've had there's lots of things about them not detecting small Children. But what about not detecting a train? Whose fault is that? Alright. And that becomes and it suddenly becomes. Yes. OK. Tesla are developing their their auto driving software cheaply and quickly because people want auto driving cars. Yes, yes, yes. But at what cost, right? When When a car drives into a train, it now becomes problematic. So I would do a little thought exercise. So think of the worst group assignment you've ever had. Like, you know, the one time where you you had a group assignment and like you got shunted out of all the meetings and somebody went off and took it all and, like, you know, produced some code and you were sort of, like, responsible for a group assignment. Think about that right now. Now, imagine you're doing one of these things, like travelling on a plane, right? And that plain software has been designed by that group. Do you want to get on the plane? Right? What if What If you're, you know, running code to launch nuclear missiles or your group is responsible for running code for launching nuclear missiles, right? Do you want Do you want that? Right. So, um, and the reason why I think the reason why a lot of you are chuckling is like, it's not that hard to to imagine. And the reason is because this is what happens in real life May maybe not quite that extreme, but, um, So, yeah, so we're interested in And I put that in them, keep an eye on the chat, make sure nothing's coming through. Um, yeah, we're interested in in making sure our software is safe. Right? So we want we wanna push forward on on that side of the continuum. Now, who's done? Sage 20, double one. What? What was C two? Oh, Double one to you? Yeah. Formal verification. So what? But what What did you learn from it? Like variants and variants using variants and invariants to prove that your code is doing what it's supposed to do. Ah, prove I love to think. Sorry. Yes. So when you say prove, what do we mean by proof? I think your friends want you up there? Well, I thought they were volunteering and answer my question. No. Is that so? What do we mean by proof? Now that I've given you your friend, it's like you now You gotta you gotta You gotta pay the price. What's the proof? What's the proof? Yes, yes. So this so the whole point of form of verification is that we prove, uh, what our programme is supposed to do. Um, this is the This is the the consensus amongst the one person I asked. Um So what do we mean by proof that it works properly? Yes, yes, yes. Communicate that It works properly, OK? Yes. OK, lots of comments up there. Great. Alright, It's a team effort. You can have three kick Kats one. Thank you. Yes. If you're listening online, you can't get out of a kit. Kat, I'm sorry. Um, that is assignment three, develop a way to deliver Kit Kats to the online community. No, um yes. Prove prove. Hm Hm. A series of irrefutable steps, irrefutable steps. This is really funny because, um, I I came from maths. I'm a maths person. Really? Um, this is why I like this sort of sort of summary. Um, and I always thought proof was that, you know, a series of irrefutable steps. Then I went to a talk by Michael Robin who, Uh, who sort of the Robin Milner primal test. Yes. So what? What? How does that work? You've forgotten, You know, it's important. OK, so the Miller Primal test What it does, is it Basically, you give it a number and it sort of like D spins, you know, basically flips a coin and says this number is prime and it's, like, correct, like with a certain probability. But what you can do is you can run the test again and again and again, and you can get the correctness of the the likelihood of it being wrong down to as small probability as you like. And his argument was that this is a proof that the number is prime because you can make that that error as small as you like you can say I want it to be. I want this this answer to be wrong one and a million times, right? Or I want to be one in a billion, right? If that is the threshold for convincing me that this number is prime Then then I've convinced you that the number is primed. Therefore, I've given you a proof. So a proof. It's not a series of irrefutable steps. This is This is my argument. This is a philosophical argument. I'm sort of like one thing about me is I'll always sort of, like, delve into sort of some sorts of philosophy. Um, a proof is, is an argument that convinces the reader or whoever you're talking to, that what you're trying to prove is correct. Yeah, So if we're trying to prove our programme is correct, right, all we have to do is give an argument that that that convinces the person that it's correct. Does this mean testing as a proof? Yeah. Depends. Depends on what a good test starter or a bad test starter. So Well, this is It's you, uh, I don't think it does depend on whether it's a good test starter. I mean, what do you mean by good test starter? But actually, we come back. OK, so that's what you need to be. That's what you need to be convinced, right? Yes. You have proof for that could be a proof for that specific case. Yes, right. What if your boss knows nothing about computer science? And you ran five test cases past him, and they were all correct. And he said yes. That's fine. Um, I believe that your code is correct. Is that a have you now provided a proof? Yes. You've convinced you've convinced your reader that what you're trying to say is correct, Right? So testing is a form of proof. Formal verification is just a higher burden, right? It's all on the spectrum. Right. So what's your name? Sorry, Morgan. Yep. And you, Matt, Ms Morgan and Matt Morgan was saying Depends on your test cases. You've got a bunch of rubbish test cases. You're sort of a hit. This level. If you've got a bunch of good case, you're at this level. If you're doing formal verification, if you're doing senge 2011. You kind of at this level, right? You're still proving things, all of that. All of the things here, we're proving we're just doing a different level of of convincing right here. We're just We're convincing the maybe the kindergartner right here. We're convincing a well enough people here that we can maybe not fly a plane, but we can launch Skyrim, right? And here we're convincing anybody that wants to use our medical software. Right? So where does this course sit? This course doesn't go all the way to that extreme. And it doesn't quite come from here, right? It sort of sits around about here in the spectrum, right? Because what I'm gonna do is we're gonna talk about how to get correct and safe code without going to the full extreme of formal verification by basically implementing, um, a lot of practically driven, sort of sensible decisions involved in in designing our programming language. Essentially, um, so that our code is safe and clean and secure and correct to some. To some level, it doesn't go all the way to formal verification. But the one thing about the one nice thing about Haskell, because we're sort of building this mathematically based programming, it's not that hard to make this final step we can actually go from our code is looking good to actually being able to prove mathematically con concepts about our code. And so, um, so this this is where This is where this course sits. It's like talk teaching you about how to programme in this in this realm. And the best way to do that is via, um, various various programme language. One way to do that is by looking at functional programming. And one way to do that is by looking at high school, which is why we look at Haskell. But it's not the only way. And we have things like rust, right? Where does rust? So if you imagine, imagine our spectrum of of convincing this of safety sort of falls on this thing. We've got C sitting over here. We've got javascript sitting over here, right? Javascript. I mean, uh why? Why typescript, right? Because javascript is over here, right? Typescript is is better than than javascript, right? It's safer. Doesn't introduce Ms. We've got sea. We've got rust. We've got Haskel we've got Should we first order logic or something? Um, you know that, but basically all our programming languages, right? Why do we have so many programming languages? Well, they're all designed to build to to to meet certain requirements, right? The whole point of javascript initially was just so that you could make your Web pages do something funky like actually, um, you know, have a dancing a dancing gif, Um, was, uh, was the I'm I'm I'm old enough to remember when the web was sort of like, um very, um, interesting, Shall we say, um And so I learned JavaScript, um, to to do silly things. And and it never got a chance to sort of, like, rectify this. It was always designed to do simple, simple, straightforward things. Um, but then people started to use it for more and more important applications. And then people started realising, Hang on, it's a bit, It's a bit broken So you know. So we have typescript, right? And then we have CC is great. C is C is efficient, right? It's better than assembler, right? Well, assemblers, I don't know where assembler is there in the spectrum, right? It's a assemble is an interesting one, right? It's very safe, but it's very hard to to write. So, um right correctly so CC pretty pretty good, very, very efficient, right? It makes you can you can read it ish. You guys can probably read it better than I can. Um, but like it still has memory problems. And so we have rust and sort of like as an improvement, but moving down this this spectrum, right? And the idea we're we're doing this trade off right? As we get as we move closer down this way, our ability to be to to write code, become it becomes a little bit more of an effort, right? We can't just sort of like, um, index any array or or ma manipulate pointers. However we like, um, So anyway, so, yeah, this is why this is why we're interested in code down that or coding down that end of the spectrum. Um, here's A Here's one of my favourite things. This is something I actually bring up in. Um, in my other course, um, my other course is 3153, which is formal verification. Um, so I am down that that end there. Um, but what's wrong with this code? I'll give you a minute to think about it. While I sort of, like, suss things out. Yeah. Oh, gosh. Hang on. Hang on. Michael Lucas. Ah, off by one metre, Lucas. Yes, I guess the number Your balance out, it doesn't

SPEAKER 2
check them exists when a price like index.

SPEAKER 0
OK, so So that was the last one. Sorry. Currency is OK, so they are all good points. Um, so he said that that you you could change this to greater than are equal to, um You don't check that the count to and from exists and so on and so forth. Um, there's a more fundamental error with this code.

SPEAKER 2
Kate was saying Ninja under the blow.

SPEAKER 0
OK. Yep. Integer, overflow, um or underflow? Yes, that's also an issue. Let's pretend that one doesn't exist as well. There's a still more fundamental yes, a racist. No, no, not not a race size. Not worried about that. Yep. Sure you don't know what's coming out of it. That's OK. There's still a more fundamental A really big There's really big error here. Yes, up the back side effects. Yeah, OK, what side effects balances in in the scope of this function? OK, so right, so you're mostly familiar with With C, you can imagine balances. Self is like maybe a global variable. That's fine. Um, that you hit. You kind of hit the nail on the head in the there's there's side effects So this is one thing, um, that Haskell The reason why people like to to work with Haskell is that, um it it doesn't have or doesn't have side effects. And what what exactly is side effects? Um, side effects aren't necessarily bad. I should point this out. Side effects are just things that are not quite what you intended to happen. And so, usually in the context of programming, it's something happens. Your your your function call or your your procedure call affects part of the programme outside of itself. Right. So it's a side, a side effect affecting something else. Any other thoughts? Yes. Mhm. Yeah, Yeah. Yep. Hm. Yeah. So this is kind of what Lucas was saying about concurrency issues. Yeah, there's Let's pretend that, like, this is all concurrency safe proof. It's like it runs. It runs in its own little she we don't have. We don't have simultaneous things. This is I should point out this is I mean, this is not C code. This is Ethereum code. This was actually deployed in the ether network. Um, as banking app.

SPEAKER 2
Why? But like, we don't know if you can. It's cancer wrong.

SPEAKER 0
Well, you could just let's assume that, like, you know, that that you you know it it will S and you plug in a two and a F from, like, the the two and the from are balances they they're valid balances. But yes, anyone can call this, but it's yes. If the requirement fails, then, um then the the thing will exit with an error. Let's just say no. No. Thought no, no, no redundant calculations. So it's a really subtle one. Yeah, the amount is negative. Nah, no. Yep. Yeah, right. Magic magic, chocolate. Right prize. OK, for those that didn't catch it right? What happens if accounts from and accounts two are the same? Let's have a look. Right. Balances from subtract the balance from balances two. Sorry, I don't know. Set balances. Um, my from account to balances from set my two account to to balances two. All I've done is just add two to my account so I can just add $100 from my account to my account to my account to my account to my account. Right. Infinite money glitch. All right. Thank you. What's your name, sir? Chris. Chris. Thank you. Chris. Yes, big prize. Yes. This is my favourite. Yes. I love this one. This was deployed. Um it was detected by a FA form of verification group. And they were. And then when they discovered this, they were like, Oops. Um, yeah. So code. This is a safety critical example. Right. And, um, your name Sorry. Up the back blue shirt, huh? Hugh, Um, as Hugh pointed out, this code has side effects. Right? What's going on? Basically, we're manipulating this. This balances, um array. Right, which we have no control over. That's outside of our function. So this function is is dealing has got side effects that we're not checking against. Essentially, right. Basically, our requirement might be that yes, after, After you've completed the transaction, balances two plus balances from is equal to what balances two plus balances from was equal to before the transaction. Imagine if you're doing something like senge 2011. That's the sort of precondition and post condition you might set up. And it's like, Oh, this will fail that. So, Yeah. So this is this is 11 of my favourite examples of, like, um things. It's a nice little example. Um where you know, where Coke can introduced. And now there's lots of ways you could find this. You could find this with proper testing and so on. You could find this by, um, Daphne. Uh, sorry. By by plugging in Daphne with the appropriate pre and post conditions. If you had the the suitable pre and post conditions, um, or you could you could find it. You may be able to find it if you implemented it in, um, a more friendly, uh, a more maths friendly programming language. So what is this course? This course kind of lies in the in in the intersection between maths and software. Right. The whole point of this course is math based, um, programming, mathematical based programming. Um, so in terms of the maths that we're gonna be covering, we're gonna be talking about basically discrete maths. Um, so logic sets proofs. We just talked about proofs. Induction. Right. Everyone goes. Ah, not induction. Induction's cool. Induction's really nice. When you when it's taught properly, um, algebra, bit of algebra. Um, no calculus. So it's discrete maths. Um, you don't need to have taken 1081, as I said, because they don't teach it in the right way. Right? So all of these topics weren't taught in the way that you need to need to do that. If you take a 9020, Then, um, yeah, that's a really good precursor for this course, because all the all the maths will be taught in the right way. Um, or if you're taking my 9020, course. Sorry. I should clarify. Um, the so it's not necessary. It's not sufficient for 3141. so don't stress if you haven't taken it or you can't remember it, it's all fine. We'll come back to it. We we, we we'll introduce these things nice and gently, um, in, like, five minutes, Not not five minutes. Now, we in a few weeks, we'll introduce it in five minutes. Um, in terms of software, what are we gonna be doing? We're gonna talk about programming. We're gonna be talking about reasoning. Kind of like 2011, and design and testing and types and high school. And again has school is not a prerequisite for knowledge. For 3141. Basically, we're going to teach you. We're gonna give you an in a relatively rushed introduction through, uh, through has school, But there is an element of you need You may need to take on board some self learning and take take this. Uh, take that on board. All right, So what isn't this course? This course is not a high school course? Uh, it's more than that. More than a high school course. It's like high school plus high school plus plus, um, it's not a form of verification course. It's not S 2011. It's not Comp 4161. It's not my other course. Comp 3153. As I said, Think of the spectrum, right. Those those courses sort of lie over here, right? These are things where we want to be really rigorous on our proofs and our correctness right here. We don't want to be quite so rigorous, but we want to be able to design things a little bit more easily. And the the principles behind those things make things, um, a little bit more straightforward. Um, if you do like this course, if you do like the where this is going, I encourage you to look at those courses. I'm taking 3153 next term and 4161 is running next term as well. Um, on those on those things, Johannes used to take 4161. this is not a software design course. This is not 2511. Right? In particular, it's not object oriented software. This is functional programming. Functional programming is a different paradigm, a different, a different structure. And it's not a programming. Uh, it's not. Not a course about programming languages. It's not 3161 either. So despite all that, But as I was talking about before, right, that's it. That's all I'm gonna be talking about. You know what? You know, This is how we would design this language. And this is how we design that language. If that interests, you look into 3161 um, 3161 does use has school. Um, and that's because high school is a very good tool for designing programming languages. So we're, um, here. Basically, we're we're introducing high school because it's a very good tool for describing, um, what we want to do now, These are not my slides. Um, this is notoriously tricky course. Um, it's not the trickiest course, like not advanced operating systems or anything like that. Um, the reason why it's tricky is because a lot of the concepts are new, right? And it's a it's a different way of thinking and that that can break some people. Um, hopefully it doesn't break you too much, right? And hopefully it's not soul crushing, Um, on that front, Um, but at the end of it, if you can get through it right, you'll be a better programmer. You'll have a wider, wider array of tools at your disposal. You you'll be able to understand functional programming. Alright. So, as I said, this course will present a lot of new topics for most of you. Um, if you're a seasoned programmer, you may have to learn as if you're starting from scratch, and this is quite an interesting thing. Um, so my background I I'm from Tasmania. Uh, but I went off and did my PhD in the UK. Uh, and at the universities I was at and at a NU as well. I believe the introductory programming course is a functional programming course, the first language you learn is Haskell or Scala or or um, ML, Right. You don't learn C. You don't learn C++ you don't learn java. You don't actually learn Java at Sorry at Cambridge, which is where I did my PhD. You don't learn java until your second year, right? Why? Well, they start off by saying right this this is programming. This is what programming is. They teach you functional programming. It puts everybody on the same keel because people haven't come across functional programme. Most people haven't come across functional programming before, Right, So this is is will be learning, you know, basically starting from scratch for a lot of you. Um, but you are now you are now not first years. You are now third years or something approximately, um so you should be able to pick this up. We should You should have all the the techniques. You know how to pick this up. So look at that, right. In terms of assessments, I am, um So, as I said, I inherited this course I am the one. The number one rule when inheriting a course is to change as little as possible. Um So this is what happened last year. Um, basically, there are two programming assignments, um, which are worth 20 marks each. There are going to be weekly online quizzes released on Friday due the next Friday. So starting that we one released this Friday. So weeks 23456789, 10. Um, they're multiple choice type questions. Um, And there's weekly programming exercises again, Um, sort of released on, uh, on that sort of weekly schedule. So nothing. Nothing yet. Nothing's due this week. Don't worry. Um, and those in total are worth 40 marks. And so these are practical exercises. You submit your solution through, give, um, and they're they're auto marked. Are they? Yep. They're auto marked, um and, um yeah, and so that's all that. And then at the end, there's a final exam, and your overall result is just your, um, the arithmetic mean of those two things? Um, right. Lectures? Well, those of you who are here or online know about the lecture between 11. And one today. This is largely gonna be me, or it's always gonna be me. Um, this is where I introduce the material. I motivate all the all the stuff, um, on Fridays, not Scott. Oh, my God. Rafael. I knew there would be one type of OK? No, um not Scott Raphael. Um will be doing the Practicals and reinforcing re Wednesday's material with questions and examples basically working through, um, the practical exercises of the week. Um, and there's a quiz quiz is due on Fridays. Not this Friday, but Fridays afterwards. And they assessed the previous week's material. Um, but don't leave it to the last minute. Start early. I As I said, I'm working on getting, um, help sessions, uh, going up, um, in terms of a textbook. Traditionally, we don't set a textbook, but there is lots of stuff online for learning about high school, um, learning about functional programming, learning about, um, all the stuff we're talking about. Um, so this is a tradition to not set a textbook. Um, we use Haskell, as I said, um, because it is the most widely used language with good support. For as I said, mathematically structured programming, which is where we what we're trying to do. So Haskell is a programming language that sits at this end of the spectrum, where things behave nicely Mathematically. Everything works really well. Um, but at the flip side, you know, doing simple things like printing Hello. World is now no longer a trivial task. Right? Um ha. About half the course is dedicated to teaching you high school. Um, but the main thing you should be taking away from this course, the things that you're gonna be assessed on ultimately, you know, in the final come the final exam are about techniques, the whole the whole basic behind these things. Because, um, yes, you may not use has school after this course, but you'll see you'll see all the principles, uh, in other languages. And this is the one place where I'll slightly deviate from Johannes. This is based on feedback from last year. Um, I will try to bring in examples from other languages of all these concepts. So you can see it's not just high school that we're doing this thing. So it's why it's not. It's not a high school course. Um, a couple of notes about Haskell. Haskell is old. It's older than me. Well, it's not older than me. It's older than my academic career because I learned it in as an undergraduate. Um, it's apparently 34. I'm not 34. I'm a bit older than 34. Um, I learned has school 98. I should point this out to give you an indication of how old I am. Right. So there's been various, um, versions since then. So my knowledge of high school is a little bit out of date. The principles are still the same. I can teach you the starting points. Um, but then this is why I'm gonna defer to Rafael to to, um, do the do the final things. Um, But what this does mean is that if you go online and you say, um, help me solve this problem, that there may well be quite out of date information, so just be careful. Don't cheat. Um, So what I'll do now is 5 to 12. Um, the other thing about me, I should point out, um, is that my For some reason, they always schedule my lectures over lunch. Like last term I had, I had I was taking two courses, had four lectures, and, um, 11 to 111 to 1. 10 to 12 and 12 to 2. So, um, I never get lunch. But that means you never get lunch if you come in. And I really like it when people come in because I like talking to people. I like giving Kit Kats out. Um, I like giving chocolate bars out. Thank you. Thank you, Chris. Um, so in the break, we take a break, grab some food. We've got more people than I than I anticipated, so I'd get more food out. Um, so grab food. I always bring food. Um, and, um, and even bring healthy food sometimes. Um, if you if you come to one of my courses at term one, you get Easter eggs instead of Kit Kats, by the way, um ah, but you don't get satsumas cos they don't come out to the second term. Anyway, grab some food and we'll meet back in about 10 minutes. Um, so about seven past to to to talk to these things.

SPEAKER 3
OK, ok, point, it's not voice questions about this.

SPEAKER 4
Um, I'm gonna send you measure. Alright, So then, um, 3141 is a four. Yeah, we got an email earlier saying that it's gonna be replaced by a 3142 Yep. So does that mean this is not a four?

SPEAKER 0
It's complicated. It's It's unclear at the moment. Uh, it's it's in the process. So basically, 3142 is a new course. So we can't take on the full amount of students, so yeah. So, um so I think, um, so that was the intention Was was going to replace it with 3142. I think that's a terrible idea. I think 3141 should be a core course, because it's like I say, like, 3142 is just more on testing. It's like, you know, it's like this one actually pushes you right to the other side of things. But anyway, um, that's by the way, Um, yeah, so I think this year three on 41 is the core. And then the idea is that next year is three on 42 is gonna be the core course. Yeah, yeah. Well, at the moment, it's it's unclear. It's unclear. So basically, um, yeah, the there's discussion. Basically, the the reason is that, um, it wasn't clear that there was gonna be anyone that could take 3141. so I sort of volunteered cos it's like, this is this This course needs to be taught, right? And so it's like, um And so now that this course is actually being taught by someone, that is, um, likely to be around for a few more years it comes, it might come back. It might come back and say, Oh, we want It's better to have teaching them functional programming than to teach them more intensive testing sort of thing. So I know that's the last one.

SPEAKER 5
So I have a question like with the scale of, um, you know, easy, easy to write, uh, languages to verify. Um, where would this lip where lisp sit on that

SPEAKER 0
thing? So lisp is, I would say, listeners.

SPEAKER 3
Yeah, I'm not sure it's, um I think I think

SPEAKER 0
Haskell is easier to verify and easier to write than lisp. Um, lisp is very I don't know. Yeah, I, I Yeah, I. I don't know. I don't know enough about listeners about this. Obviously, I think it changes the way you think about

SPEAKER 5
like, is it a completely different paradigm in the same way? Like, um, I don't think so.

SPEAKER 0
I think really the the pillars of paradigm as you go from the differences are so there you talk about imperative programming. Um, declarative programming. And I think it's logical programming or something like this is, uh, talk about the three things, But really, the two main ones are imperative and declarative. Um, and sort of li, I think. Yeah, I say the the third, the third pillar of the paradigm Triad. I don't think is so so important as as much as the the imperative dresses declarative. Um, which is what? Which is what the difference between functional programming and and imperative programming is. Yeah, No worries. Great question.

SPEAKER 3
I Is that fine? Oh, there. Yeah. Mhm. Oh, my God. I think you're right. That now. OK, president. And now I just Oh, yeah. No. What is the plan? Like your, you know, around I tell you, right. OK, he's a night man. All right, OK, because that what could at least reply

SPEAKER 0
with a different chip?

SPEAKER 3
Where is the same one?

SPEAKER 2
Alright, So do you know if there's a bean around

SPEAKER 0
here? No idea. No idea. This is Maybe I'll Yeah, I No.

SPEAKER 3
Oh, yeah. From if I like at all you. I ok for you.

SPEAKER 0
Excellent. Right now I've got a surname to the first name Lucas, and now you're in trouble. Um, well, um right. Thank you for at least at least testing that the chat thing works. It's great. It's, um I say it. It was under early release, so I have no idea. Cool. Right. Um OK, Haskell setting up Haskell? Yes. OK, we're gonna turn away from chat. My daughter. I have a nine year old daughter. Who, um who, of course, gets involved with these. You know, with, um they have various things, and the teacher is very strict. If you start posting rubbish, you get banned straight away. So please tell me you're older than nine. Um, right. Um, setting up paso. Um, so some instructions on the course website for doing so? Um, Cabal, uh, stack, apparently, uh, useful tools for having, um, no idea why Kabal is used on the CS E machines and we recommend stack on the home machine. Um, you can actually, in Ed, I've got Ed set up so that you've got, um, workspaces. You can have a, uh there's a high school playground which I'm sharing at the moment, Um, which is where I'll put all, um, my walkthrough code. I've I'm As soon as Rafael logs into ed, I'll add him. So he can also, um, edit, Um, this particular, um workspace? Yep. Yes. OK, that's terrible. Um, yeah, we'll sort that out. Um, did did you get the Did you get the email invite? Ok, well, I got I sent an email invite to someone, um, offering them administrative rights and everything. So cool, I'll sort I'll sort you out anyway. Later on. Um, yeah. So you can actually you can actually do things in Ed, and I'll do this here so that you can actually access the code after the lecture. Um, but if you log into the lab, um, and because I'm using a le a lecture machine, I've done it through the web. Um, in order to make sure that you're using the same build, um, you just flip to the 3141. Subs shell like so. And then you can, um, run Hal by typing cabal. Repel. So rle stands for what's never again re evaluate print? No, I don't know. It's It's It's the It's the It's the thing that sets up, um, gets you running and into high school like so and so, um, it will spit out some garbage and then not show you where it's gone. Here we go. Um, and once you've loaded up GHC, I, um so GHC I stands for Glasgow Haskell. Something or other something or other. Um, that that means you're in the Haskell shell. And so you're you're, um, running that in, ed In order to get it to work in Ed, you just actually just run GHC I and it'll just plonk plonk it straight into the GHC. I shell straight away, which is very convenient. So I'm gonna work in Ed because I can make things bigger. Um, and it runs a lot faster than me, um, SSH in through the university. Um, I'm not going to let chat. Um, but I What I will do is I will make the code a bit bigger so people can see it on the screen. So, unfortunately, I can't make the terminal B bigger. Anyway, so we're in GHC I We're running high school. So what can we do in high school? Well, we can type, you know, we can use high school as a as a calculator, right? Three times three is nine. Um, six plus five is 11. Um, maybe we want to do integer division, so 10 D, um, integer division. Right? So, Div and you've got a bunch of things there. So that's that's high school, right? Just a calculator. Alright, easy, easy, straightforward. How to do things in high school, right? Ok, that's not that's not what we really want to do it like that. You can do that with a python. Um, interpreter, That's that's no, no deal. So this is just a list of things I need to remind myself to do, so Well, you can already see here. Um, this is the This is a high school file over there to load this Haskell file, right? You just load that there and it says, Oh, no, uh, one module loaded. OK, they're gonna bring me into the thing, But as long as it didn't complain about my loading right, it's imported all my information from that from from this file. And this particular file has nothing in it because all of this stuff here is currently commented out, so you can see here how to set up block comments. It's just brace dash and dash bras. Bra, Brace, Dash. Yes, Lucas. Apparently, the Livestream can't see this. That's annoying. Thank you. Um, how does the livestream gonna see this? That's a good question. Um mm. That's annoying.

SPEAKER 2
Like peanut, right?

SPEAKER 0
It might be It might be distinct. Yeah, OK, so if you're trying to watch this on the live stream, try logging off and logging on again. Um, is that is that a chat Comment, right? Anyway, yes. Hopefully, yeah. Hopefully it's just a decent issue. Um, right, So, yeah, block comments. Anyway, open brace, dash, dash, close brace for in line comments. It's just double brace. Uh, double, double dash like so, um and, you know, um, Ed is currently doing all our, um, formatting for us. Um, So what do we do? Well, um, the first thing we want we want to do is set up a module modules are our name spaces. Right. So we might say you don't you don't have to do a module, but it of course, it helps with with code management. Um, and And you do that. And so you set up your namespace so, module, first lecture. Um, where and then basically what follows? That is basically what's gonna fall under your your your first lecture. You don't have to indent. Uh, indentation is not necessary. Um, white space kind of matters. I mean, you know, in that in that you need white space to separate things, But we'll get we'll get on to that in in due course, right? So this will set up your, um, set up your your name space. Your sorry, your your name space. And so if I have something like X is equal to seven, if I want to access that X in a different module, um, I would call like something like, um, what's that? I would I would call, um, first lecture dot X and that would access that particular, um, that particular item. I want to call it an item binding home and have a bit more space. That's what I do. Right? And so, um, so now I've Now, I've done some something a little bit more interesting. If I load, um, load up, lecture H one. And now if I say, um, what's X? It'll say me that X is seven so no, it didn't have to. I don't have to say first lecture dot X right, Because basically, it's I've loaded up this this module as sort of like one of the default modules. Um, when you start GHC I there's a There's a module that's automatically loaded up called Prelude um, which basically sets up the basic, uh, the basic functions that are available to you. For instance, um, div is a function we saw that, um, we saw that up here. 10 div three is a type of function, and we can learn some things about it by, for instance um asking, Sir Colin, I will give you information about the div function. So the div function. Um, it talks about its type, and it's, uh, various, uh, various classes. I sorry. Classes are defined by its type. Um, so it's a type 88 a. And where it's defined, right? So if I asked if I asked about X, they tell me that X is an integer and it's defined in line 19 of lecture one, dot HS. Now I don't have to just find the type by I. I can also find the type by T. What what's the type of X? Um, X is of type integer, so we'll talk about types, um, later on down the track. You don't need to worry about that so much. Um, so that's our first Well, that's a That's an introduction to writing Haskell code for so far. Let's let's just eliminate that one for the time being. And let's just talk about one of the the the most fundamental things we do in Haskell. Well, actually, let me let me go back to Why, Why? Oxford and Cambridge, for instance, and a NU, um think that functional programming is the thing that should be taught first, Um, what's a programme? But in the most abstract sense? Yeah, a set of instructions to be interpreted by a computer. Yeah, that's a That's a good a good answer. But like does it have to be a set of instructions? I mean, think most abstractly. What does a programme do? Executes? Does the programme have to execute? If I write, if I write my code print hello world and just like leave it there is that is that still a programme, even if it's not executing it is a programme. So the programme doesn't have to execute. No, I still like I like the I like the volunteering of an answer. Oh, there we go. Yeah, Black box where you give it some input and it spits out some output. Yes, I like that Answer a lot. That's the answer I always like to hear. Um why do I like to hear that answer? Because, Well, that's that's a really, um uh, It's a really good, succinct way of describing it. And it describes computing up to about, uh, 20 years ago. Probably a bit longer than that. Why? Um OK, well, does it always have to give an output? Got by. It's got void, but it's void. I mean, arguably void is an output. It's like I was just like the The function is done. It's like, you know, there's like an inherent output going on there. Does computation have to stop in order to be computation? Can we have things that run forever, nominally forever, right? Theoretically, forever. Web service, right. As long as they don't crash, they should, in theory, run forever, right? You know the programme running the web server, it takes input, and it produces output, but like it's still waiting for more input. Perhaps so the idea of computation as being something that takes input to output is is what we like to think of as as computation. It's certainly what we built all of computer science around Turing machines, programmes, all of that all. Everything from from the start was the idea of a computer is something that takes an input, does some steps and produces an output. But then we sort of we the notion of computation has evolved now as we sort of have things that need to run indefinitely. But anyway, I like the idea Input turning input into output mathematically, what's that function? So all programmes are just functions if we go back to the old definition of functions, is that right? Is that is that wrong? All computation is just a computation is just a function. Yeah, that seems reasonable. Hence functional programming. In fact, we you know, when you think back, uh, when you sort of go back to the history of computer science, the so, uh uh this is again delving into my other course. Um, I talk about the history of computer science. Um Where does computer science start? So computer science really started in about about 1900 when David Hilbert posed his 22 mathematical problems that were going to shape the the next century. And one of his problems he posed was, um, give an algorithm that determines if a polynomial has, um, integer roots. And so here a polynomial is not just like X squared. Plus X plus three, plus three equals zero. It's like, you know, X squared times Y plus Y squared times X squared. Plus, you can have multiple variables, so it's a little bit a little bit more complicated than just one variable. You can have multiple variables. There's a given algorithm. So he didn't say given algorithm, he said, Give a sequence of steps, um, that can determine if a given polynomial Sorry, don't when a given polynomial has an integer integer value. And what was really interesting about that question was, you never question the fact that such an algorithm might not exist. Such a process might not exist. You always assume that Yes, there is one. We just have to work out what it is, um, and so that that question sort of inspired people to sort of go back to mathematics and say, OK, what do we mean by an algorithm? What do we mean by a sequence of steps? And, um, and the the the notion of computation sort of developed over the next say, 30 years and sort of within a year of one another, Um Alonso Church and Alan Turing came up with their own notions of what computation is right. Alonzo Church came first, he said. Computation is this is a function right? It's it's about. So start with the idea of a computation is that it takes an input and produces an output. OK, so what we wanna do is we wanna take, um, our basic unit is a function and we take a function and we talk about inputs and do that. They said Well, but do our inputs have to be like integers or anything? No. Let's make our inputs functions as well. Let's just make everything functions and and there's a But, you know, we we know zero. We know zero is a number. How can zero be a function? Is it well, you just make you just call it this function right? just to like define a special function is that this function is zero. It's like it's a weird function. It doesn't do very much. It actually does the same thing as false, actually, but false is a Boolean, But no, no. Everything's a function. We just make everything a function. And then he said, OK, if everything is a function, then this is what we mean by computation. You basically take a function, you take an input, you plug it into the, um function and you get output. That's computation. And then he proved that that could do basic arithmetic. It could do multiplication. It could do division. It could do recursion. It could do basically everything that we understand nowadays as computation, right? And he said, Yeah, look, I can do everything with this, this notion. And then, um, that didn't catch on. Not surprising, but it caught on in certain fields. It caught on in the logic field because lo logicians love being complicated. A year later, Turing came along and said, No, that's not computation. This is computation. And he said, computation is a machine and it just what it does. Is it just, um it has a number of states. You go in this state and you go in that state, and it has. It has a piece of paper, and it just writes down symbols on the piece of paper, and it can cross out symbols and go back and forth on the piece of paper and cross out different symbols and cos that's what humans do. If we're like if we're doing a computation, we write down things and then maybe we go back and cross a few things out. Or maybe we substitute things like this, but that's all we do. And like we go through various states, we go OK, if I know that like the current point of the calculation, X is equal to 552 then Y is gonna be equal to and then write it down and do that step by step computation. And so that's what Turing came up with, he said. Basically, he's distilled it down to the simplest form possible and said, This is computation and that caught on. That's why we've got computers the way we do. That's why we think of programming as sort of like, you know, step by step sequences of instructions to go back to what a programme is. A step by step sequence of instructions. But it's not the only way to think of what a programme is. If you think about most abstractly a programme, all the programme is is taking input to output and so functional programming actually predates. You know, the notion of functional programme predates the notion of imperative programming by about a year. But it's just what what caught on. So basically the idea that everything is a function is is an interesting way to look at things. So OK, everything's a function. A programme is a function. So let's start by talking about a function How would I define a function? So let's talk about squaring squaring a number X So say say square I take a square square I'm gonna define the Function square. Oh, I better define the function properly, So I'm gonna say Square square is a function that takes integers, um, to integers, right, So enters a built in type capital. I all your types have capital letters. Alright, I gonna say square is a function goes from type uh from takes integer to integers If I take X. I'm gonna square it. I'm gonna give you X times. X! Right, So that's that's that. If I I can reload it with control R I can ask about I can ask about square. What's the type of square square is a function that takes integers to integers OK, and now I can, um, see how a square square behaves So say, what's the square of two? The square of two is four and now Raphael's squirming. It's like he's, like, horrified that I've done this because he's a functional programmer and functional programmers don't use parentheses, right? You can actually see it on this side here What I've written, I've written square of X No parenthesis, I said, but basically square followed by X. And so actually, what you do in functional programming is you tend to drop the parentheses, right, so square. So we think of this as a function. And the first thing that after the function separated by whitespace, is the input into the function, right, So, like so? So we can use you can use parentheses, um, to sort of like disambiguate things, but, um, ideally, try not to. So here's a question What's this? Six? This is six. Yeah. Anyone else? Any other form? Teeth? What else could it be? 16. Yeah. So we don't know how we're gonna pause this so we could pause it like this, right? I did say, But I did say the first thing that comes into a function is right is what we take is the argument to so we can do something like that, Right? So which way do we do it? Well, let's have a look. Uh, we get six. So what happens with when we've come to? So what we're actually doing here is we're applying, um, one function to another. We're doing sort of function composition. Um, the way to read this is that function application is what we call left associative, right? And so we do the square two first, and then we do the plus two second like so. So function composition is what we call left associative, right? That means the brackets sort of go to the left. Right. Um oops. What? What? Come back. Come back. Come back, Come back. I want to see chat. Right. Good, intelligent chat comments there. Great. Obviously, No-one's having any problems. Any questions. Sorry, I should have I should have asked any questions so far. So we did like square square two plus two without

SPEAKER 2
the square square.

SPEAKER 0
What? Square square? Two plus two. OK, so yeah. So how how does this work? So let's have a think about this. How would this pause? Well, we've got to pause it. That's right. Let's see. Let's see what it says, right? Haskell yells at you. Right? So why is Haskell ye yelling at you? Well, how do we pass this? Remember, the first thing that we pass into square is its argument. So this is reading this as square square, so it's passing square into square now. That's actually generally not a problem, right? The one thing about high school is that functions our first class citizens, right? That means that you can pass a function around. You can return a function right, and so I could pass the function square into another function. I can't pass the Function square into into the function square. However, why not? Hm? Yes, exactly. Thank you, Brodie and I and I know Lucas was in there too. Yes, Brodie looks surlier. I'm a bit I'm a bit scared of him at the moment. So, um yes, square is not a not an in right. In order to pass the function into, uh, into an argument in the square, I need to pass it as an in, So I can't do this. Um, so let's put some parentheses in to make it a little bit more sensible If I put parentheses like this, right Square two is an NT right square tells me that it returns an in right so I can pass that into square, and then I can add two to the result. So this will be, like, 18. It should be 18. Yes, thank goodness. Right. Um, Now, let's just go back to the the the syntax over here. Talk about a little bit about the syntax. So if you were writing, um, square in, say, an imperative programming language, you might write something like this you might write. Say, um N square in X return X times. X. Right. So that actually fits into many, many languages. Um, I'm not sure why it's gone red. Um, and so this is this is probably what you're more familiar with. If if you were writing the square function in in C Java JavaScript Um, a JavaScript. You can drop the semi colon because it's it's weird like that. Um, right. But we can see here. We can see here. We can compare these 22 ideas. So what's going on? So this first line here is what we call a type definition. This is defining the type of square. Now, Haskell's quite smart. You don't actually need to provide type definitions. Um, necessarily, Um, it can it can actually work them out for you. But it's a good idea to to do this, um, in the process. So you can, so you can. So you you you monitor your your own your own progress. So this says right, So this says square square is of type in to in. And so this first end here, um, is the domain of the function. So square is a function as a domain and a co domain. So domain is a set of inputs. This is this is what it says. It says Square takes as an input. It takes an in, so that would correspond to the type here of the argument. Right. So the that that in the first in on the on the type definition corresponds to the in, um of the parameter. The second in is the return type, if you like. Of the function this tells me what square returns, um and so that would be, um, corresponding to that in T over there. Alright. So we can see. Um, we already have that. That idea of, like, basically the the domain and the codomain of a function being specified. We specify this in a programming language as well. Um, Now, the interesting thing here is this idea of return, right? So, in an imperative language, we say, right, you give me an X, I'm going to do some steps. Da da da da da. And then I'm gonna return this particular value, and that value is gonna be You know, I'm gonna do some steps. In this particular case, I'm gonna multiply X by X and then I'm going to send that value back to you. What we do in high school is we've written it like this. This equality sign is not like assignment. It's different from assignment. This is mathematical equality. This is literally saying the thing on the left is exactly the same as the thing on the right. So in particular, when I write square two over here, what it does it says I don't know what square is. Is there anywhere where square is set is has been defined or square has been defined over here. Right square X has been defined over here. So I can, um, replace square two with two times two. So it'll do that Replace squared, uh, two with two times two, and then it knows how to work out what two times two is. And so it evaluates two times, two late. So I so E The equal sign in Haskell is equality not, um, assignment. And this comes into play when we talk about things like, um, variables. The variables are slightly different. So you you maybe familiar with sort of the idea of, like, say, maybe saying X equals seven? I said I showed that particular example before, right? And it gonna say X. And it'll say X is seven. Great, what you can't do and this is comes back to what? Um ah, I. I dream the song about state was he was he saying about Oh, yeah, so in many programme languages, you might just say OK, let X be equal to seven. OK? And then blah, blah, blah Let X equal to six, right? What happens when I do this in in high school? Right? It yells at me, right. Variables or single single letters in high school. Uh, more like Constance. You can't You can't change them, right? This is This is what we call a a binding. I'm gonna bind seven to the value of X, right? What I've written here in the Haskell code is that X is X and seven are synonymous. And then X and six are synonymous. And so you can sort of, like, go. Well, that means that six and seven are synonymous. And that's why Haskell is throwing up a complaint essentially so saying You can't say X is equal to six. And at the same time, X is equal to seven, right? And so this is an instance of what we call declarative programming. And this is this is the This is the main. The big difference between imperative programming, which is what you've come across and declarative programming declarative programming. We are stating these facts and the the computer works out what we want to do with imperative programming. You give your step by step instructions, you say, Do this and then do this and then do this. You've got a main method to start with and so on and so forth. Here we're just doing all the declarations. It's like basically setting up, setting up all the function definitions in in C, right? A de or in python deaf function equals blah, blah, blah De function equals blah, blah, blah right, And it doesn't do anything until you call function, right? So it's the same same thing here. So the the that's the you're declaring that the declaring the properties. But this happens at all levels in high school, so you don't have a you don't have a like a outermost level where where the execution happens, right? Basically, everything here is a declaration. So I'm declaring that X is equal to seven. I'm declaring that X is equal to six and because I'm declaring those two things at the same time, it's throwing up an error. But what about you know? So something else you might want to do so say X is equal to X plus one. Right now I've got I'm not. It's not gonna let me do this because I'm declaring X as two different things. Um, I don't know if it's, uh, don't think it's smart enough to know if I declare it the same thing, we'll find out. Yeah. No, it doesn't. Doesn't let me even say it's the same thing. But what if I say X equal X plus one? OK, now, programmatically, that's fine, you know, normal in normal programmes, you know, incrementing the value of X. Yes, that seems that seems sensible. Um X equal to seven increment the value of X by one. That's fine. Mathematically, as a mathematical statement, that doesn't make any sense. X is equal to X plus one. No, no, it's not. That would mean one would be equal to zero. You subtract X from both sides right now. This is where you gotta think this is. This is a Haskell is a mathematical is mathematical based programming. So what if I just said so? Ok, it's complaining cos I've defined X twice. What if I What if I comment out that and just to clear X once and say X is a good X plus one. What's gonna happen? We'll complain. Yeah, OK, let's have a look that it's fine. It's quite happy to let X be equal to X plus one. OK, right. Remember, it's declarative. I'm saying I'm saying that this is the case, OK, fine. He just like Yeah, fine, right? What happens if I want to use X? That's the problem. OK, so let's try and use X. Um oh, it's stuck! What? No! What's happened is that it's trying to work out what the value of X should be. Right, So it says, OK, I don't know what X is. Let's see. Oh, is there any definition of what X is? Yep. Here, Um in order to work out what the value of X is, I need to compute the value of X and add one to it. OK? Um right. Let me compute the value of X. Oh, I don't know what X is. Uh let me. I need to work out what the value of X is and add one. I don't know what the value of X is. I need to commute the value of X and add one. So it's sitting there. It's doing that for me. I'm sitting there thinking it keeps trying to add one to something, right? So it's like, basically, we're going in in infinite recursion. Right? So it's not a problem to declare this, but it's a problem to use it because we've got sort of an infinite recursion set up like that. So variables are not are not like variables, right? They're more. Yeah, I say best. Best way to think about them. Variables are are more like constants and that you can't They don't They don't have this. This value that can change that you can sort of change as you go on. They're more like placeholders as well. We sort of use them as placeholders. So here we use them as a placeholder here, um, for square square, X six. Right. So that's ins, modules, comments, variables, uh, function application. I've talked about function application. Um, right. Uh, what else do we want to do? So, um what O? What other types have we got? We've got, um uh we've got characters which we sort of denote with single, uh, single, uh, quotes. So I can ask what the type of of that character is That's a That's a char. Um, I've got strings ABC. Right. You can, um, concatenate strings. Like so. Alright, so plus, plus concatenates two strings smashes them together. Um, you can take, like, the first three that is of a string. So you get the 1st, 1st 3, you can drop the first three. Alright. So take and drop of functions. Um, actually, let me. I've kind of I've kind of skipped over a skip here. Here. I'm talking about functions, so let's talk about functions here, right? The function in Haskell is it takes it. Ha. It takes one input and produces one output. So how do we deal with functions with multiple arguments? Multiple parameters. Kind of See it going on over here. So take and drop are functions that are taking multiple outputs, multiple inputs. Right. So what am I doing here? I'm actually applying. Um, I'm I'm taking two arguments and feeding them into into into those things. So let's have a look at the type of of take right. And it's got this weird. Wow. Hm. It's probably, uh, a wet list. Just ignore that. Ignore this for a minute. Imagine the the brackets. A says strength. The sake of things, though in fact, let let's define um, my take. Um, it's gonna be a type, takes an in and takes a string. It takes a string, Um, and I'm going to define my take equal to take Nope. OK, so what's the type of my take? Right. So it's a type enter string to string. So how do we How do we interpret this? Because this isn't like one input to one output. It's sort of like one input to something to to an output or something like this. So how do we interpret this? Well, the way we read the type definition like this. So remember when I said my take? So we go if I plug in my take three, string ABC DEF something like this. Remember? I said the the first thing after a function is what you plug it into the input. So this should be interpreted as my take of three applied to ABC DEF, right. I plug the three into my take right, so that three goes in there, and what does my take return? It returns a function that takes a string and turns it into a string. So my take three is a function that takes a string to a string, right? What does the function do? But basically it just takes the first three letters of whatever string you plug into it. So if I take might take three, plug in the string. Um ABC DEF. Uh, it's gonna return. ABC. Perhaps an easy way to understand this is to look at um So there's function here. Log base. Alright, so log base two of 64. Right, So we're gonna talk about log base two of 64. There's the number of the power of two, which is equal to 64. There's two to the power of six. Right log base two of 32 is gonna be five log base, 10 of 100. It's going to be two, right? So log base is another one of these functions that takes two arguments, the first one being the base of the logarithm and the second one being the the number you want to take the logarithm of what's the type of log base again? A little bit complicated just to ignore this part for the time being. This is just talking about the what kind of things a can be. But it basically says it takes an A and an A and gives an A So you can imagine Here, we're gonna define my my log. I'm gonna just say it's an in to an end to an in No sorry, not an in double to a double to a double. Let me say myeloma little base. So reload, right? And then I ask, What's the type of my log? And so it takes a double to a double to a double. And so I can say like so my log two is basically logarithm base two. That's a function that works as logarithm base two. So if I do 64 apply to that. I get 628 I get seven. I can al also talk about log based 10 would be my log of 10. Right? My 10 of 100 and 28 is something different, right? So this idea that basically what we do with Haskell, um for multiple arguments is that we we part we we build up, we build up the function one at a time. One argument at a time. Basically, um, we think of a a function with multiple arguments as being a function that takes one thing and returns a function on that needs to take the rest of the things. So imagine Well, another example is, um, say a right. So the the function, um, say I wanted to find add two right. Takes an inch to an end, right? And what this does is it just adds two to the input, right? So IW I one way to define it might be to say add two of X is equal to, um, two plus X. I could define it like that, right? That would just that would be a very simple, um, very simple definition. But an alternative way to define it right is to say, basically, well, the function. So the function plus is a function, right? It takes an a takes two A's and returns an A. It takes two numbers, returns another number, so you add two numbers together. But what happens if I only give it one number right now? Here? I could say so. I could say add two is equal to plus two, right? And what this what plus two is plus two is a function that just takes a number and then adds two to it right now. I should I should clarify. Here, um, I'm using this. Parentheses. Plus, like, so right. Parentheses is what lets you transport an INFIX operator, like plus minus slash, um, to be a prefix operator. Right. So you can talk about three plus four, right? So the plus there is infix. It's in between the three and the four. this is the same thing. This is syntactic sugar for this particular setup here. So the function bracket plus rac uh, +34. And we saw Yep. Um, so, uh, so what? So you wanted to say, like, plus 3, +45 or something like this? Yep. OK, so what happens if I did? Plus 3, +45 throws an error. Why? Let's have a look. Well, what's plus doing? Plus plus Takes two numbers and returns a number. Right. So what's happening is when I do plus 3, +45, it's gonna take those two inputs. Three and four. Plug them in, gives a number, and then I'm left with seven and five, and now it's trying to apply the so it evaluates this thing here. Plus 3, 4 that was gonna return seven. And now it's gonna treat seven as a function that I'm trying to add that I'm trying to plug five into. So that's why it complains. Because seven is not a function. Great question. Excellent question. Share it with your friends. Oh. Yep. So great question. Great question. You can't. This is one of those things about type safety, right? You can only you can only apply the function to to the number of variables that assess. Um, right. Anyway, so add two, does something like this we can if we reload. Let's see. Add 26. This is just gonna add 2 to 6. Right now. Note here. I should point out that you notice here that in all of these things all of these definitions here I could have said my take. Right. My take is something that takes 222 arguments. An an X and a Y. Right? It takes a it takes a number and a and a string. I can say that. Is he going to take XY like so right. So if if you were doing it Sort of like it might take. XY is equal to take XY. I could do it, I. I would normally think about doing it like that. So why Why was it OK to drop the X and the Y? Well, what does it mean? For two functions to be equal, two functions are equal if for every input, their output matches right. So for if if on input Y So just just imagine this is like hold hold. Just treat this as a function of one variable for the moment, right? So on input Y This thing here right basically produces the same output as if I plug Y into take X. So my take X and take X have the same behaviour, the same input They would produce the same output so I can delete that. Why? And so I'll get my take. X is equal to take X. These two functions are the same as functions. But then the same thing applies right? If we're given X my take X we'll return the same value as take X. So for any given input, my take and take give you the same value so I can delete that X there. I'm gonna say my take. I can complete those parentheses now. Oops. Do those parentheses now. And I'm going to say my take is equal to take the same thing here, like add two. I just say it was was equal to Plus two. This is sort of, if you like shorthand or or simplification of given input. X add two. X is going to do plus two X, Which is kind of what I wrote on the line above. I just wrote, wrote it with prefix rather than infix. Um, so this is what's known as E a, um, reduction. You don't need to know about that, but basically, this is something to keep in mind. Basically, we can We can drop if we say that the the output of one function is the output of another function for every for all the same inputs. We could just simplify that by just saying those two functions are equal. Uh, right. I'm gonna finish that for the moment. Um, on Friday, we'll we'll carry on and go through a bit more, more, um, examples on this front. If there are any questions at the moment, Um, I'll just double check chat. Any sensible chat things, all the names, like OK, Sorry. Uh, so, uh, yeah, the module. So we set up a module? Yep.

SPEAKER 2
On unity?

SPEAKER 0
Yes, exactly. So if I want to, I can I can say my first lecture dot square is gonna refer to specifically this particular function that particular function there. Grab some food on the way out. Um oh, right. How do we do? Recursion Oh, right, right, Right. Um, we will see recursion and multiple multiple and agreements,

SPEAKER 3
right? Like I, um So it's it's it's what we call

SPEAKER 0
a type implication. So, um, it says that a has to be of type number. So if if a is of type number, then um plus returns a fun plus is a function of type A to A to A. So it's sort of like it's it's it's kind of class. It's It's a class based definition. Basically anything which is a number, um plus will work on
