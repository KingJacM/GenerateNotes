SPEAKER 0
thing. OK, Good morning, everyone. I was just waiting for the recording to start. So, uh, we were talking about how miners build blocks. So the thing is like, if you if you remember, I said a block is a sequential set of transactions or set of transactions that are in a particular order, and then pretty much any minor can take a bunch of transactions, put that to a block and claim to build a block. But that is not going to help us because I also said a Blockchain is a chain of blocks where there is a particular seeker. So, like, this is the block. N, this is block N plus one and plus two like that. So we need a way to prevent multiple miners from claiming to build a block at the same time. So how you do that in Bitcoin is you get the minus to solve a problem what we call a proof of work. So I briefly talk about this slide, but let me revisit this. So this is how proof of work work in the sense you you have all the data coming from the block. So you have all of these transactions, there are Merle Tree and things like that. The time stamp is the current time stamp that on the minus machine. And there's this non this is the nuns that we see here. So mine has already figured out everything else other than the nouns and the corresponding hash of this block. So if you look at this hash, there are, like, leading number of zeros, so that's essentially the puzzle. So the puzzle is given all the data from the block that we have on the right hand side. And what would be a good non that when you concreate them together and hash using SH, a 256 hashing algorithm that produces a hash value that has a certain number of zeros at the beginning? So these are what I call the most significant bits. So if if the corresponding hash value satisfy this, the mine has solved the problem. If not you try another nun like how many nuns you can try? There are nouns value. I don't remember exactly. Um, maybe I have written it somewhere. Let's see. It is 64 0256. yeah, 32 bits. So you have essentially two to the power 32 combinations to try as the potential non value. So whoever minor find this first can claim to be the first miner or that can claim to be the one that has the right to build the block. So what this is called proof of work is you have to actually put a lot of computing power to solve and find a good non value. But on the other hand, if you give me a non value and that NBI block data, I can very easily verify whether your non value is correct. So you may go through this loop millions of time to find a value. But once you give me a value, I just need to go through this once to figure out whether your value is correct. So this is more like, let's say, in an exam, we give you an exam question that takes you half an hour to swap. But whoever marking your exam won't take half an hour to mark that question. They are looking for a particular answer, and they can very quickly verify whether that answer is correct or not. So the same idea here So that's why I say you are proving your work. Of course, you have to do quite a lot of work to do this. You need massive amount of competing power to do this. Uh, but whoever trying to verify your work can verify, uh, whether you have done that. So this is extremely computationally intensive, and you usually use specialised hardware. Specialised. I CS to do this in the Bitcoin world. In in Ethereum version one, you use GP US because ethereum mining Uh, the algorithm was a little bit more complicated than this. It was not only computationally expensive, but also memory expensive. So you have to use GP US with a lot of memory to do that as well. But Ethereum no longer does that. So if you if you went to this YouTube video and looked at that, you may have realised it's a multimillion dollar investment to get get something up and running. Of course, you may be lucky you, your very first block that you built maybe the, uh, the block in the longest chain. But that doesn't work all the time. So So you claim your right to build a block by solving this puzzle, but on a global network, when there are, like 19,000 miners, when we look at like a couple of days ago, we realised there were 19,000 miners on Bitcoin. So there is a possibility two miners may solve the problem simultaneously, not necessarily exactly the same time. Like I solve the problem. I propagate that to the network. In the meantime, someone else may have also done that. So now we have a problem, because there are two competing blocks for the position in plus one. So what Nakamoto said was Nakamoto is the one who invented Bitcoin. He said It doesn't matter. Let it be like that for a while. And hopefully miners will choose one of these to be the longest in the sense like, let's say, the chain on the bottom. If the next miner who is building block N plus one, took the one on the bottom of that, it'll build this block, saying, This is my predecessor or my my parent block. And then whoever takes that N plus two as the parent and build the N plus one N plus 2, 3 so so like that there can be a contention for a while, but with time, it will naturally resolve where one part of this chain or one part of this tree in this instance will appear longer than the other one. So at that point, the miners can disregard the one on the top, um, and start using the one on the bottom as the the longest chain. So this is a little bit interesting in the sense it's not a very perfect I mean, it's not a perfect solution. You just wait some time for the problem to be automatically resolved. Because, let's say if I'm N plus three, if I'm trying to build the block after this, there's no point trying to take this one because I have already seen something a little bit longer than that. So if someone tried to build another N plus two here, they have a less chance of being on the longest chain and essentially means that you don't get the block mining reward or anything like that. So you you don't have an incentive to build on top of this as far as you have seen this one, so you have an incentive to extend this further, then take something shorter and extend because your chance of being in the longest chain after a while reduces if you start working on a smaller part of that chain. So the one that get dropped is called the open block, and and the ones that build on top of that are the call the confirmation blocks for block N plus one. Um, now, why are we saying Why am I saying that? The one that received the most computation. So the chain length is corresponding to the computational power as well? Because if you don't have computational power, you cannot build a block. Your chance of solving this problem is very minimum if you don't have enough computing power. So that means to build a longer chain. Of course, you need more computing power. So a longer chain is backed by a lot more computing power than a shorter chain. So that's why sometimes we just call it the longest chain. Or sometimes we just call it the one with the longest computing or the most amount of computation. They they're pretty much the same thing, because to build a block you need computing power. No. So this is essentially a probabilistic approach. If you look at the Bitcoin white paper, just search for Bitcoin white paper. You can find that it's publicly available. Nakamoto even do a simple calculation to show that, like how many blocks you should typically wait to realise you are in the longest change so typical on this idea is in Bitcoin. Acceptance is like you wait for six more blocks like, Let's say, once a block get generated, you wait for six more of blocks to be along the same path. At that point, you consider that your transaction and the block is permanently stored in the Blockchain with a very high probability. Of course, there is a nonzero probability that someone else may suddenly come with so much Mexican bidding power and start building this chain and bidding longer than this one. But more time passes. This becomes very hard to do because you need more and more competing power to compete with the rest of the network. So it's a probabilistic guarantee, saying, if you wait for six blocks after a block get generated, we have a pretty high chance of not being not being dropped from the longest chain. If you don't like six. Wait for 10. If you don't like 10, wait for 12. So 12 blocks is like two hours in Bitcoin. So once your transaction goes into block, if you need very high guarantee, of course you can wait for 1212 blocks. It's just a just it's the convenience versus the risk that you take. So a lot of applications or whoever paying on Bitcoin. A lot of people would be happy with six blocks, but I have seen, like some some some people say, Oh, in our case, we need 12 blocks because 12 blocks probability that you will be overtaken by another longer chain is extremely smaller compared to even 66 is still small. So it's It's a basic guarantee in the sense that comes from probability. So it's not a typical transaction. Commit semantics that you see in databases. Have you heard of acid properties in databases, Atmos, durability, isolation and a consistency. So when you write something to a database once that is written to the desk, Oh, in in general terms, when you write something into a database that is persistent, so whereas here we are not saying something like that, we are saying Even if you get into a block, you still need to wait some time to make sure you are still in the longest change. Um, so pro. Realistically, this is possible. A longer chain could still appear, but very unlikely simply because you need massive amount of competing power to do that. So this is where people talk about this possibility of the 51% attack. So 51% of the attack means one or more minor controls, a little bit more computing power than the rest of the network. So let's say if I have the 51% of the computing power in the whole network, the rest of the network has only 49% computing power. I'm slightly ahead. So over time I can let's say, start building, start building on this one and make maybe make this longer than this one. It doesn't happen in the next block because I only have like 2% more than the rest of the network. But let's say if I have 66% of the computing power, the rest of the network has only 34%. They have a much higher chance So this is where the new Blockchains are a little bit tricky, in a sense. Risky, because when a Blockchain is new, there aren't that many notes. And when you have, let's say, 100 nodes, it is quite possible one of you individuals may control a large number of them and and that kind of gives them a little bit of a monopoly. And they may play mess up the whole network. Whereas something like Bitcoin that is it has been established in the 19,000 notes. It's very difficult for someone to have a disproportionate amount of computing power on their hands so that they can mess up the network. But in a smaller block case, this has happened again and again. And this is why investing in in any new Blockchain not necessarily because of proof of work, but there are other reasons as well, can be risky. But once a platform is established, there are quite a lot of nodes in that it becomes very difficult to attack a network like this in this case, attack in the sense trying to build a longer chain than the current longer chain. Now, this is a life cycle of a transaction. So what we see at the top is like the happy path. So you have a transaction that you submit to the submit into the network. So this goes into what is called the transaction pool or the main pool, and if your transaction is valid, it'll eventually get into a block. And after a certain number of blocks. So let's say some mixed number of subsequent blocks. You consider your transaction to be committed. So in Bitcoin typically six blocks now, there is a possibility. Even though you get into a block, your block may no longer be in the longest one like so in that case, what happens is if you happen to be in one of those open blocks, you go back to the pool and wait to be included again. Now, while you wait, there is a possibility that you may get dropped again. This is up to the minors to define, like, how much time they are going to keep your transaction in their transaction pool. As I remember in in Ethereum, default time is three hours. So if you just download the basic software, use a standard configuration. If a transaction does not get included in a block in three hours. Minor can just decide to drop so you can configure this this just some number of hours so it can get dropped. But if you can, if it get drops, of course, you can resubmit your transaction. So if you realise your transaction is no longer in the pool, you can resubmit that. That's not a problem, and you can also do what is called the superseding in the sense you can submit another transaction, hoping to kind of cancel out the previous transaction. So let's say you were planning to pay someone, but you change your mind. The transaction is still not included, so what you can try to do is send another transaction using the same. If it is utx O use the same XO but pay a higher transaction fee. And and in that case, yeah, it's coming in. In that case, you can get the transaction. Let's say back onto you. So what you can do is let's say if if Alice was supposed to pay Bob and Alice doesn't want to go ahead with this one, Alice can try to send another transaction where the recipient is Alice itself, and you still need to pay a transaction fee. Only thing is, if you pay a higher transaction fee, there is a possibility that the miner may take your new transaction because it's useful for the miner because you are going to pay more fees transaction fees than the original transaction. But this is not a strategy that is guaranteed to work because not every minor is concerned about transaction fees. But when I say not every minor, maybe not even 1% of the minors there's a small number of miners that we call them sick miners who are not very interested in transaction fee but helping the network to keep going and grow so they may disregard your transaction fees. So whether you can really replace a transaction that is still not included and like, make it outdated, it depends. But generally it can work as far as you. You issue a fairly high transaction fee. Yeah, a transaction.

SPEAKER 1
Or is it? The minor system means a selection of minors, so the

SPEAKER 0
miners drop the transaction. But the thing is, each miner can pretty much change the configurations like let's say you have a set of dials to turn and there is a default setting for each of those dials. But of course you can change that. So, for example, like sometimes if you go and see, you can see transactions that are like one week old still not included in the block. But somebody is still holding because they don't care about the three hour limit. Any other questions? So whether this is successful or not depends. But generally everything else tend to happen. You get into a block, you block, get dropped in the from the longest chain, you go back, you retry and and eventually hopefully you will get into a block. Now, why are the miners interested in all of this? Like this is from Bitcoin that is from Ethereum. So you get a block reward of 6.25. So this was before last month. If you build a new Bitcoin block block in Bitcoin, you got 6.25 Bitcoin. So that is like, what? $600,000. So that's quite a lot of money. Of course, you need quite a lot of investment as well, but you only collect very little in terms of transaction fees. I mean, this is small compared to this, but if you look at in this in dollar terms, this is like still $24,000. Not small. Now here's in in Ethereum. So here's the minor. So this is the miner who is gonna get that transaction fee. So by default, Ethereum has a 22 ether mi mining fee or the block reward, and this is a transaction fee. Now, transaction fees in Ethereum is a little bit complicated. Ethereum actually burns part of that. So whoever sending the transaction actually paid this much 1.14. But the protocols rules are such that part of that was burned. So the miner only ended up with 2.12. So only 1.12 is the actual transaction with the minor. Got this is again for various reasons. So this kind of appreciate the value of the currency with time, because the supply is reducing. Yep.

SPEAKER 1
So, uh, mhm, uh, so that that minus is that's

SPEAKER 0
a protocol rule. Um, I don't remember the exact reasoning, but it is more like to kind of prevent minors from going behind transaction fees to kind of dis discourage them to do that. Uh, there's a long discussion. Just just search. Like, why this one you can find there is, like, so it in Ethereum there is there what are called improvement protocols and and they are usually quite a lot of discussions before taking any of these actions. And and there is some discussion around this, but the simple answer would be they don't want the miners to go behind transaction fees. They wanna fo minors to focus on building blocks. So you got two anyway, for building the block and only 1.124 as transaction fees. Anything else? So in in Ethereum terms, this is like, what? About $10,000? But building a block in Ethereum today is much more easier compared to building a block in Bitcoin. So minus get two forms of reward. One is the block reward. That's like anyone who build a block and in the longest chain essentially get this report. Uh, so now from last month, it is only 3.125 Bitcoin. That's why suddenly, Bitcoin price went up from about $56,000 to over 100,000. And so every like approximately every four years, it becomes half. And somewhere in 19, 2000, 140 it's supposed to be zero more than 100 and 20 years from today. Uh, if the network survive that long, I don't know, Um but they don't really talk about this in terms of days or years. It's essentially every 210,000 blocks. The mining rewards half, Uh, whereas in ethereum it it is not consistent like that. It's just suddenly everyone discusses and say, OK, it's time to change our, uh, mining fees. And somewhere since, uh, I don't remember when this was this was probably about 4 to 5 years ago when I started teaching this class. They went to this to eat, and they have been doing like that for a while. But before that, it was three. It was what, um, five initially like that. So this is not quite hard coded into the protocol like this one, whereas in Bitcoin it is hard coded into the protocol. In a sense, every 210,000 blocks, the mining rewards will become half of whatever that is now. There was actually a question after the class last time. Now why this transaction fee matter. I already talk a little bit about that. If you're trying to like, let's say, cancel out a pre your transaction if you offer a higher transaction fee, there is a chance that the miner may include your transaction sooner than someone else paying a lesser transaction fee. So so you decide. Like, let's say, if you go and tap your credit card or debit card, the merchant decides if they are gonna have a credit card surcharge or something like that, they decide, Whereas here is the other way around the user decide how much they are willing to pay. Um, before that, I actually kind of jumped on. OK, now let's talk about this first. So what do you think about the first statement? What we did? What did we talk about in the very first class? More copies you have? Is it easy to keep them in sync or not? It gets harder. Uh, given a hash value. Can we derive? We can. We can derive the corresponding message so hash functions are one way or two way there, one way so you cannot do that. Um, an attacker can fabricate a transaction. Users using Alice public key to essential discredit. Alice, no. So what's wrong with this statement? You need to use a private key, so please read carefully if you get the keys wrong. So if you want to prove as Alice, you need to sign as Alice. How you do that is using her private key, which Alice is supposed to be protecting. So when you when you hear like a wallet attack or someone attack and got everyone's private keys, here's the risk. Because once they got hold of your private keys like they got hold of your password, then they can do whatever. What about the last one? As soon as a Bitcoin transaction is included in a block, it is safe to assume the transaction is final. In the sense, let's say if Charlie is selling bicycles where you pay using Bitcoin. So should Charlie ship the bicycle as soon as transaction got included in a block? No, Charlie should wait. Typically one hour or six. I mean, one hour correspond so usually six blocks, then Charlie's chance of losing the bicycle in the sense you don't get paid is much lower. If Charlie wants hire guarantee. Wait two hours. So it's not a good idea just to jump ahead and do that. But remember, we will talk about something like hyper fabric. So in some Blockchains, as soon as the transaction is included in a block that is done, what we call final but not in a lot of public Blockchains. You need to wait some time, but some could be minutes, some Blockchains. Still, it's still seconds. But whereas if you're talking about a private permission Blockchain like hyper fabric, you're talking about a fraction of a second. Ah, why did I jump? Something happened or not? No, I just talk a little bit too much about transaction fees. I I'll come back to transaction fees. OK, so Ethereum. Today we have the second generation version of Ethereum. If I do a quick comparison between, like what started in 2015 and what changed was it last year or year before 2022 is Ethereum went from proof of work to proof of stake what is mean by proof of stake, we will discuss in a later class like we will discuss different consensus algorithms. But the general idea is you set aside 32 ether to become a minor or a validator in Ethereum two terms. They call it a validator. So you set aside 32 ether and an algorithm randomly decides it's your turn to build a block, and if so, you build a block. But if you don't show up at that time, when you're supposed to build a block, you lose some of your E that you set aside. Part of that 32 E will be lost because you didn't do your job. On the other hand, if you build a block that other miners don't like in the sense they don't think they think that you did something wrong, then you lose your 32 ether. So that's how the incentives are. So you you set aside some money as collateral. If you behave well, you build a block. You get that two eater, plus a little bit of transaction fees. If you don't show up, there is a penalty for you. But if you do bad, the penalty is much more severe. So 32,000 just multiply. Let's say 32 E and multiply that by 5000. That's quite a lot of money to be lost unless you are really using someone else's. Let's say hack the or something like that, but you better sell that and get that money rather than lose it, So it's a different way of putting it. So the idea is, people who own Cryptocurrency have an incentive to keep the network running in the correct way so that they don't lose the value of their Cryptocurrency. Let's say if I have something that is worth 5000 today, Network goes bust that my 5000 worth nothing. I don't want that to happen. That's that's the incentive Here, Um, so interlock time. It used to be between, like, 13 to 15 seconds. Now you would see regularly every 12 seconds A block appearing. Of course, if a minor doesn't show up, you have a problem. So once in a while, very rare. I have seen that the interlock time could be 24 seconds, simply because whoever supposed to build that block at that time, let's say the node crashed or something like that. So actual average is about 12.1 simply because very rarely someone missed their chance to build a block. Um, so confirmation blocks now has actually increased. It used to be 12 blocks, which was about three minutes. Now it's about seven minutes and 7.5 minutes. Again. Why, This is 7.5 If you go to the Ethereum website Ethereum.org. There's quite a lot of discussion on why this is like this. They want to reduce this eventually, but they say when we move to the version two, we want to be very sure we need to make sure this network works. So that's why they have gone for that 64 block. But they want to eventually reduce that pleasure is still replicated. But when they started going for version two, they say we are going to do what is called Sharding. In the sense, if you remember, I had a diagram rather than everyone having the same table. Different notes have different parts of that table, but about a year ago they gave up that idea and said, We are not going to do sharding, and we will focus on what I call Layer two, which again we will discuss in a later C class. What is layer two? Uh, they want to improve performance, still not done. But that's that's a long term goal that they have. On the other hand, power consumption pretty much went from let's say, what was equivalent to let's say something so OK, people would say, like the Bitcoins power consumption is equivalent to what Las Vegas consumes. So you pretty much go from Las Vegas to like essentially, uh, you can run Italian version, too, even on a raspberry pi, so you don't. I mean, you need a reliable device because you don't want to be in a situation when it is your turn to you can't build a block, But other than that, you don't need any advanced hardware to do it. So the native currency is ether. There are slight differences in Bitcoin versus Ethereum, so Ethereum uses this like bank like account balance model. Here's an address. Here's the balance of that address, whereas Bitcoin uses the UTXO. So you have your public key to prove who you are, but you sign your transactions using private key. Uh, every transaction is uniquely identified using its hash. So that's the transaction, ID. Now this don't get confused with this. Nuns in Ethereum. Um, where is this? Nouns? Oh, I don't have it here. So Ethereum uses a nuns to order transactions to say this is my first transaction. This is my second transaction. This is my third transaction, but this nouns has nothing to do with the nuns that we have in this diagram. It just they use the same same term. So that nonsense again, An integer just to say to To to tell the network you should try to include my first transaction before you. You include your my second transaction. It's just a way of ordering transactions in Ethereum. Uh, no, There are a few other additional things here. If you see, there's something called the gas limit. Gas used gas price. So this this the combination of those three helps you determine the transaction fees. OK, now, uh, so the transaction fees are decided by you. In a sense, whoever transacting can decide. And here's a screenshot I got from Ethereum Gas Tracker. In a sense, now, in this case, it is not very helpful. If you look at like, if you if you are willing to wait for a long time. How much you need to pay? So this is called G away. Uh, G away is I think, uh, 10 to the power of minus six ether. Um, even if I look at this morning, I still saw 888. So I didn't update this diagram, but sometimes what I'll see, what you will see is, if you pay a higher transaction fee, the time here is slightly low. So, like, um, yeah, So if you look at this one, this is about 30 seconds. Uh, here, this is about three minutes. This is three minutes. So what this helps you to do is helps you to figure out what should be the transaction fee that you need to set depending on how fast you want your transaction to be included. But in this case, probably the network wasn't very busy. So whether you said 13 or not Oh, not not if you said 13, you may still be able to do with 30 seconds. But if you go to this website on a on a time that the network is busy, you will see a different number here, and that number is usually higher than the number here, but that's pretty much what we capture with that CD F. So, uh, the Y axis is a probability X axis is the transaction fee. Oh, wait, no. XX is the time, and different curves are the different transaction fees. Uh, so if you pay nothing, this is how it will work. It could take forever, but your transactions can still get included in a block, so you have a nonzero probability that will get included. Whereas let's say if you pay something between zero and 20 here's the curve. But if you decide to pay something more than that, your transaction is likely to be included in a block relatively faster than paying. Let's say somewhere between 0 to 20. So how you should read is if you if you pay a certain amount and draw a vertical line, that will tell you what is the probability that your transaction will get included. Let's say if I draw a line somewhere here, I think I should be able to do this is what it says. Okay, so let's say if I'm paying a higher fee, I have a chance like this is on a logarithmic scale. If you look at. So I have a chance. My transaction would get included in about 500 seconds or less, and the probabilities were quite close to 100%. Whereas if I'm paying this much, I have only about 70% probability Probability that my transaction will be will be included in 500 seconds. So more you pay. There's a good chance your transaction will get included faster. This depends like this depends on what you want. If you really wanna buy a bicycle, does it really matter whether your transaction get included now or in other farm aid? Yeah, probably not. Whereas on the other hand, if you are, if you are, let's say, transacting with what is called an automated market maker, which is like an online exchange decentralised exchange. Every transaction happens on that exchange will change the price because the supply demand changes. So there you want to be the first, not the second. 00, let's say when, uh, when A. When a new business starts, a Blockchain based business starts. They they do what is called initial coin offerings. So you you put a little bit of crypto into that business. They offer you a certain number of tokens and then you have some like your hope is that that token will be become very popular in the future so that you can sell and earn more money or there may be other rights associated with it. So, ideally, you wanna buy faster than anyone else. So in those situations, yes, speed speed matters. But speed doesn't matter in every single transaction. Um, so of course, you can set a transaction fee of zero. There are minors what are called ultra strict minors who don't care about transaction fees. So you may still be ab able to include your transaction. So that's why we have that black dotted curve. Uh, but the idea is, if you pay more transaction fees, you have a good chance of getting included faster. Uh, but this is not an easy thing. It depends on so many factors. So here are at least four factors. So if if a lot of transactions are pending to be included, that means the network is busy. Usually you need to pay more if you want us include faster, um, Cryptocurrency price. When the price goes up, usually transaction fees goes down, not necessarily proportionately, but a little. Let's say when a Bitcoin is 1000 $100,000 versus $50,000 you don't necessarily need to pay the same transaction fee because, let's say 0.01 Bitcoin when it is 100,000, it is twice as when it is 50,000, so there is a slight difference. But it's not usually proportionate because the problem is when the as soon as the Bitcoin price goes up, everyone wants to transact. Either everyone wants to buy, hoping it will go further or whoever holding it wants to sell soon. So that's why it's not like when it goes up, everything just goes up linearly. It's more complicated than that, and whatever your urgency depends on your application. And, of course, there are errors and attacks. There are cases even 1 million equivalent to $1 million was paid as transaction fees. It was probably someone attack someone's wallet and just destroy those. I think it was in it. I have seen it, um, so that was a lucky minor. So whoever owns that ether lost it, but the miner got that, and that's a valid transaction. So it can suddenly like you. You may see ridiculous numbers simply here for in a in a short time, simply because someone accidentally or or because if it is an attack may decide to pay something ridiculous. Any questions? Now? OK, why is this thing got messed up? I hope it did not get messed up on your printed slides. Uh uh uh, OK, Now, transaction fees, particularly in ethereum, is a little bit complicated because it has two parts. What is called the transaction of the gas limit and the gas price. Ah, the best way to probably look at this would be, Let's say you're going on a on a trip and how much you ended up. Paying for fuel will depend on two things. What is the efficiency of the vehicle that you are using? Fuel efficiency of the vehicle that you are using and how much you are paying for? Let's say, one litre of unleaded 98 or diesel petrol or whatever. So gas limit is like that efficiency. But it's a limit. I'll. I'll talk about the slight difference here. Gas price is pretty much what you are willing to pay. So let's say if you if you have, like 100 and 91 that comes at a certain price. Whereas if you have E 10 or E 90 E Sorry 191 or diesel that comes at a different price. But the ultimate cost to go on that trip depends on both of them, so if you have a very efficient vehicle, your gas limit goes down. But if you decide to put premium fuel, your price goes up. So so it's more like that. So gas limit OK before that, what is Gas? Gas is essentially a a way of accounting resource usage on ethereum. So what I mean by resource usage is when you have a smart contract, particularly, Miner has to do some computations. So there's a computational cost here. And if you decide to store quite a lot of data, there's also a cost for that. So, for an example in your project one, you store a bunch of friends, friends, addresses and lunch menus. So there's a little bit of a storage used by your smart contract, and then when we decide like which restaurant has the highest number of votes, we kind of go through a loop so that that involves a little bit of computing. So gas is essentially a way of accounting, uh, for the resource usage. So Ethereum has what is called a white paper, as well as a yellow paper yellow paper details like if you run this sort of AC PU like instruction how much gas you are going to consume. So usually, let's say, if you, if you learn, know a little bit about compared architecture, something like doing a hardware level addition is quite straightforward compared to doing a multiplication division is even more harder like that. There is a number assigned to various operations that you do so more complex operations that you run your gas cost will increase. So that's why even in Project One, we say try to reduce the gas consumption of this smart contract because if you do that, it's like your cost of going on this trip reduces because you are using a more efficient makeup. OK, so gas limit is a fixed limit that you set, saying I'm willing to pay only up to this much why this is important. Suppose you had a loop and you that loop never ends. In that case, you will end up pretty much losing all your ether. So that's why you you you set a limit saying for this particular transaction to get included, I'm willing to pay this much gas. But of course, your loop is too long, and it actually requires more than that. Your transaction will terminate. And of course, you lose your transaction fees, so you set a limit to safeguard yourself. Of course, the network also wants a limit because it doesn't want to be in a situation that it is running an endless loop. And because of that, no other transaction can get included in the Blockchain. So it is. It is protecting the network from denial of service attacks as well as kind of helping you to also meet to set some limits. Either way, this can also go wrong. Let's say if you have a transaction that you really need to get executed. But if you set the wrong gas limit, it's gonna fail. So any transaction that you do on Ethereum there's a minimum gas fee of 21,000. If you just transfer, let's say E ether. From Alice to Bob, there's a minimum of 21,000. Anything on top of that, Like executing smart contracts, storing some data there's an additional cost. So if you if you are carefully looking at what is happening in your lab one you may realise some of your transactions like take like 140,000 gas. It's simply because it is doing more than that Basic 21,000. Uh, of course, even to deploy a new contract, you're gonna pay because the contract has bytes, and storing data on on the Blockchain is essentially what you're doing when you deploy your contract. So because of that there is a cost. So if your contract is smaller, cost is lower. If your contract is big in the sense more bits, the cost is relatively high now. Gas price is essentially the market price that you want to set depending on the agency. If you want a transaction to get included faster, set a higher gas price. If you don't care if you are willing to wait, set a lower price so you need to consider the multiplication of these two is essentially what you are offering to the minor. Now, in this diagram, if you look at you set a gas limits of 21,001 just in this example. But only 21,000 was used because this is a very basic Ethereum transaction where you are transferring ether from, Let's say that two address, uh, the from address to the two address, so you set a limit, but only 21,000 is used. So as far as this is equal or below that one all good and here's the price. So the multiplication of this and this is ultimately you will ended up paying, So you pretty much decide how much you are willing to pay. And as far as your I think I talk about everything in this light, Yeah. So as far as your gas used is less than no equal to the limit that you said all good. Uh, so if you want to see, like, what is the impact of this? Just set a smaller gas value in your project one and and just observe the error message that you get. Only thing is, you're gonna lose it because mine already put an effort to execute a transaction. So transaction fails, minus still gets your ether for executing that transaction. Uh, so it will fail, and no state changes will happen, except you lose your transaction fee. Now. Similarly, blocks also have a gas limit if you remember. Like, I show like there were 30,000 Sorry. 30 million gas available for the block. But mine are designed to only, like, put fairly small fraction of that. So maybe no, uh, stick a block. Yeah. So this one. So you could The miner could have put 30 million, but minor decided to put only 3 million. So why does the block has a gas limit? So here the gas limit is the sum of gas used by all the transactions that are in the block. So every transaction offers a certain amount. You add them up and there is a limit. So this is again to prevent the network from doing too much work, and you ended up building block transactions rather than actually building blocks. So this is kind of a safety net to prevent, because early days these things actually happened. So some of these numbers, like, have been refined over the time again and again. And and people find various ways to slow down the network just by running operations in the sense like CPU level instructions at a lower fee. And the miners ended up dealing with those things rather than focusing on building blocks. So the miners said this and typically it's 30 million for a while. So what this means is you can only put 1004 128 transactions in an ethereum block. So how you get this number is essentially, you take this 30 million. Divide that by this 21,000. So if a block contains only ether transactions just at least to bob payments and things like that you can put a maximum of 1428 transactions. But there are a lot more other transactions, like using smart contracts. So that's why you may see a much smaller numbers. OK, there are only 58 transactions here, but of course, minor use, like only 11% of what is available. But it will be a very um yeah, so if you look at this one so this one has Lomo 235. That's the biggest. Let's see how much that one consumed. Mm mm. Oh, this one is good in terms of transaction fees, but I'm not sure why. This is not loading. Maybe in it. OK, ok, yeah. So this one decide to put like, 57% fill it up to 57% but there's no more to go, So you could have done 1000 plus, but the No, no is not doing that. Whereas in Bitcoin, like a four megabyte block about one minimum, about 1 kg byte per transaction. No, it's, I think, probably a little bit more than that. So you can only do like 1005 100 transactions per block. But remember, this is 1005 100 every 10 minutes. This is 1428 every 10 seconds. So which network has higher throughput? Bitcoin or ethereum? What's the definition of through put, what's the definition of triple simple definition? You need time. Yeah, So number of transactions in this case, let's say one second. So which one can process more transactions per second Ethereum? Because if you look at that 1428 divided by 10, so you can actually not 1012 every 12 seconds you get a block, so you get about 100 and 40. That's the theoretical maximum. But because minors are not filling the blocks you you, you don't get about even you usually get about 10 to 20 transactions per second in average, whereas here 1000 500 every 60 seconds. So not 60 10 minutes. So 600 seconds. So that's much lower. Um, so this essentially set an upper bound on the network's throughput. So in in this, like if you compare conventional databases or even like, um, let's say, MasterCard Visa card, which can process almost 100,000 transactions per second, these are nothing. But of course, there are now Blockchains that claims that they can get very close to that 100,000 mark. And at least nobody seems to be interested beyond 100,000 because that should be enough for a lot of applications that we have today. Now, in Ethereum block format is quite complicated. Don't worry about the details. Uh, I just put this diagram to show because ethereum includes smart contracts and their data, not just the ether ownership. So there are, uh, three Merkel trees, what they call in Ethereum again. They use tri, which means a specialised form of a Merkel tree. So there are three things. So World State is essentially everything on the Blockchain, the smart contracts, their data E, the ownership and everything and it it keep track of the list of transactions using another. So that's the world state, which is a Merkel tree. And then you keep track of a bunch of transactions that we have in the blocks and it also keep track of what are called transactions. So if you if you notice what you see on remix ID when your transaction get included, you see a bunch of details like what address got changed. What were the gas used and things like that? So all of that information is also, uh, keep track by the node. So because of that, actually, Ethereum, um, if you are running a ethereum node, you need about seven terabytes today to store everything, whereas Bitcoin, I think is still around 1.5 terabytes or maybe even less than that because Bitcoin only keep track of TXO. Whereas here we have smart contracts that that means they are code as well as all the state that we maintain in the smart contracts. So in summary a block. Keep track of all the account balances, the data that you're storing and the smart contracts. So this is because of that. It's more complicated than Bitcoin. So don't worry about the specifics, because I, I won't worry about them. It's just understand. Like when you have smart contracts, you need to keep track of more things than just exos. Now I think there was a question even around this one, Ethereum interlock Time is much larger than the propagation time, so interlock time currently is 12 seconds in Bitcoin interlock. Time means time between two blocks is a average 10 minutes, and the block propagation time is probably one second or even less now. Only thing that pretty much dictates today. Mm, the latent going from one place to another place in the world is pretty much speed of light. Whether you like it or not, that's that's That's something we cannot reduce, plus any other delay in in between that various networks add. But if you want to, let's say if Alice sits in one side of the world, Bob sits on the other side of the world. If they have a pretty good connection Alice and Bob can communicate under one second, but why there is a 12 2nd interlock time is to make sure the blocks have enough time to propagate before someone starts building the next block. But why? Bitcoin is 10 minutes. Things were not this good like, let's say, in 2008 2009, when Bitcoin was introduced, latency was higher, but definitely not as 10 minutes as that. So even that time you could go from one end of the world to the other end of the world and send a fairly small packet or couple of packets under one minute with very high reliability. But why? Bitcoin is not going down today. It's more of the politics in the sense people doesn't want the protocol to change. Can Bitcoin run? Uh, let's say, run under 12 seconds like Ethereum. Probably. Only thing is, Bitcoin blocks are a little bit bigger than Ethereum blocks, but still getting a one megabyte across the world under 12 seconds should not be a big problem today, So I don't have a technical reason like why Bitcoin is still 10 minutes today. But at least early days, the reason was you need to make sure miners have enough time to propagate their blocks before everyone start claiming that I also build a block because they haven't heard about your block. Um, can't see. Maybe I I'll talk about this slide and let's take a small break. Um, so ethereum A little bit interesting in the sense when they go from Ethereum one to Ethereum two, they broke this node into two pieces. So the other thing is like ethereum. The piece of code is usually called a client, and an instance is called the Node. Sometimes we call the code the framework. Some people call them the Ethereum terms. At least they call the client that is an implementation of Ethereum. When you get it up and running, you call that a node. That's the instance that is running. So in Ethereum one there was a node has only like one piece of one thing. So we are both the transaction execution, and the consensus was handled by single piece of code. But when they transition into version two, they decide not to just touch the execution part of it. The actual execution on the smart contracts. So the transactions they kept that part as it is and they build a separate visa code. But it's called the Beacon node that was that is responsible for the consensus. So now when you're actually running Ethereum, you are running two pieces of code as two separate programmes even and one is responsible for consensus. The other one is responsible for actual execution of the transactions. Only thing is, those two will talk to each other like if one of them stops other one. Stop working in the sense start complaining, saying I cannot talk to like, let's say, uh, the beaker note will say, I cannot talk. I can't find execution plan And the execution client will say I can't sink anything because I don't I can't find a AAA beacon note. So it's just again more convenient, and you have a robust piece of code working. So they didn't want to touch that, and they just went with a new layer to deal with the consensus. Mm. Again, the thing is, you may hear different terms. Execution, client execution, engine client, or just client or eth one client. Uh, the consensus one we can node. Uh, what else? Uh, again eth two client like that, but you actually need both of them to work. That's that's a full node in the sense that is able to receive transactions and transactions execute transactions. OK, so let's take a five minute break. Um, and in the meantime also start thinking about answers to this having a question about the, um, the altruistic

SPEAKER 2
minor, which is the one that maintaining the the, um, the network. They're not interesting about the reward or they're just focusing on building a block. So the the role play of them is not, uh, like, beneficial, right?

SPEAKER 0
It is beneficial to the network, not so much beneficial to them. But they may have other reasons to do it. So for an example on British Foundation, which is kind of responsible for the code and all of the decisions taken, they may be running notes anyway. So I mean, like, for like a like a like

SPEAKER 2
what if, like, for some person, like they are independent,

SPEAKER 0
So then make such as it's just waste of the

SPEAKER 2
computation. So, um, so also, like, I have a question about like if, like, people have a really large competition and then they're trying to build a block, so and that also, we focus on build a block as soon as possible. Right? But the amount of the transition that including in the block not that matters but but sometimes it depends on the purpose that are you willing to, um, get more reward from the church fee or is just getting the reward by building a So so so. But you just mentioned that in the they like the the organisation prefer the people to focus on building a problem. Yeah. So it's not that the benefit of getting the Trans is not that.

SPEAKER 0
Yeah, So that that's a good argument in the sense. Like why Why you do that? Because then people are even less motivated on the transaction fees in the sense including more transactions. Yeah, um, I don't have an answer to that one,

SPEAKER 2
but you can still do it just it's not that much of benefit.

SPEAKER 0
Yes, So that's why, like if you realise like one block had only 11% the other one had 57. So one, maybe 57 month had a good reason to include more.

SPEAKER 2
But what I do have a large computation power and I still like build a block. But I just trying to include as much as the I can do, like the maximum I just talk about, like for less than a little bit less like a 15,000. So, um, I mean, so a benefit to getting the right.

SPEAKER 0
That's that's what I would think, But not necessarily. Everyone would think that way. That's the thing. So that's that's That is why things are unpredictable. You have a reason to do whatever the way you want. And I have a reason to do whatever the way I want it, just Yeah, yeah, yeah, yeah, so But it's actually more complicated than in the sense. Like for example, um, there are attacks what are called sandwich attacks, which we will not discuss in this class. Um, so So they are, Let's say you may. If you try to include other people's transaction, you may get only another let's say, $500. Whereas if your transaction goes into this automated market maker or whatever and becomes the first one, I may actually get half a million dollars. So so those are the more complicated problems around this. That's not visible. So that is what is called the mine extracted value. So that depends on the ultimate goal ultimate goal than than just the transaction that you see.

SPEAKER 2
So so in the Trans, you do have the ability to see.

SPEAKER 0
So that's actually what something I'm trying to fix. Yeah, Yeah, we we we may briefly touch on that challenge, but but not no, that's not no, you don't really need so much competition power if you like, have a full CPU. That's probably like I have a lot of I want

SPEAKER 2
in my but there will be like a like a You have a component. But people also saw that people also see that so and they want to get that so like that will require, like, better of power.

SPEAKER 1
The Bitcoin was criticised by because it's using too much power. But is it really a lot? Uh, consider it's a online global, um, like transaction system.

SPEAKER 0
It is still high because the thing is, whatever you are doing, 10,000 others are also doing. Do you really need 10,000 of them to do it? If you if you look at like a e-commerce database on a global scale. Still, you have about 3 to 5 copies. Maybe, but we have Visa and we have master.

SPEAKER 1
Both of them are running like parallel like we can use only one of them. The other one is like unnecessary.

SPEAKER 0
Um, nope. Because if you talk about open markets, competition and all of that, so there are business reasons to have more than one not to have a monopoly, but But the thing is, is still, let's say Visa have fine notes. MasterCard has fine notes. 10 notes versus 10,000. That's the problem.

SPEAKER 1
So, like too much.

SPEAKER 0
That's the problem.

SPEAKER 1
Another question is like, um, update from one pile to to file it, reduce the like power by reducing the

SPEAKER 0
I would say, like almost magnitude of 100,000, maybe. Yeah, so significantly from, like, proof of work to But

SPEAKER 1
like, um, how does it achieve? Like, who is doing the, um, like only the the doesn't, um, build the block like you, you need computer like to do the, um, like to to build the block.

SPEAKER 0
Yeah, but but the thing is only so So what happens currently is everyone is competing to build a block current with proof of work, whereas in proof of stake if you if you get selected, only you will build the block. So it's like one person trying versus 10,000 trying. So like the richest guy has the right to be no, not richest guy. Because everyone put 32 everyone has equal chance. If you have more money, you can appear as multiple plans, so you have more chance to be.

SPEAKER 1
Yes, but everyone Every node has the equal chance because

SPEAKER 0
everyone is limited by the 32. But there are other proof of stake protocols. Your probability of getting selected depends on how much you

SPEAKER 1
stake. I don't have any. Do I have a chance to?

SPEAKER 0
You can become what is called a part of a pool, which we will briefly talk about later. There was a question about, like Why? Why? Miners are not really interested in putting a lot of transactions? Because if if transactions pay you from transaction fees, uh, and and and particularly like, why why E Ethereum is burning some of the transaction fees. Uh, things are a lot more complicated. Uh, anyone heard of something called minor extracted value. So the thing is, if I'm a minor. I get to see what others are doing before those transaction goes into the block, because all the transactions come to my transaction pool. Now if I see someone is trying to buy some particular asset, particularly a large volume of asset. So depending on that buy, sometimes the price goes up. If someone is trying to sell. Usually price goes down. So I, as a minor, has a little bit of an advantage if I put my transaction before the miners trans so whoever the person trying to buy let's say I buy something at $1.05 and then someone else is going to buy again. $1.05. But 1 million, Let's say tokens. I only buy 100 but after that, 1 million token buy price is going slightly go up. So then I may be able to sell my asset at a slightly higher price. So there are other reasons for miners to put few transactions and quickly move on because I may benefit more from that buy and the sell or buy you the sell rather than the transaction fees. So this is where things are more complicated and and What we see on the surface in terms of number of transactions does not necessarily tell the full story. And and there are estimates like over one year, like how much value is extracted by miners simply because they have this added advantage of seeing what is happening. That that accounts to about $100 million in a year. So just being being the first to do something before. So it is already talking about what is called encrypted transactions so that the miners can't even see what they're doing until the last moment. So so trying to kind of negate negate those advantages. But don't worry about those. They are a little bit too complicated. What you just need to do is miners can decide to do whatever. As far as they comply with the high level protocol rules, others will accept your block. OK, so what about the first one? Immutability in Bitcoin is probabilistic? Yes. No, I don't know what is immutability. It cannot be changed so true or false. So in this case, immutable. You can think of this in terms of a transaction that goes into a block. You consider it to be immutable but after a while you are no longer in the longest chain. So we call this probabilistic immutability. Because of that, it's a probabilistic guarantee. Not that it's like guaranteed forever. Next one, Bitcoin uses account balance and Ethereum uses TXO. Paul at the Ethereum uses account balance. Bitcoin uses UT exhaust third one. Even though a transaction got included in a block, eventually it may get dropped. It goes with the first one throat. Last job, we just talk about this. Yes. Ethereum has a higher throughput. Now I'm going to talk about hypered fabric or hyperedge in general and then hypered fabric, which is a private permission Blockchain. So this is not in the public space, a set of organisations or even an organisation. Usually a consortium of organisations can deploy something like this within their firewall. So other people don't know what is happening. But you know who is involved and who is running these notes. It's not just some random guy sitting somewhere, you know, exactly who are the members of this, uh, consortium. Uh, so this is, uh this was initially developed by IBM, then became a Linux foundation project and hyperedge comes in various flavours in the sense hyperedge fabric is the most popular, perhaps, and hyperedge bizu is essentially ethereum for a private network. So, uh, hyperedge bizu is a private permissionless Pretty much you can run solidity code on bizu. Only thing is, you are not paying any real either at the transaction fee. Uh, hyper lure. Indi is, uh, identity management one or I'm not sure. Aurora, which one? One of the two. So So it comes like a set of tools together, uh, to run various Blockchains and applications around them. It's a module architecture. In the sense, at least this is how we started. Like you can change, plug and plug and play in the sense you can change in the consensus protocol. So, early days, Hypo Fabric supported two or three protocols for the consensus. But today it's pretty much going going with what is called proof of authority. So you designate who can build blocks. Uh, but very later we will talk about something called, um PB FT practical Byzantine fold tolerance protocol. So that's kind of their their approach to go or where they wanna be. Uh, other thing is for a reason. Smart contracts in hyper are called chain codes, but essentially, they are smart contracts. Uh, but one advantage is in Ethereum. You mostly write in solidity, but you can write Go no Js or Java. You can use any of these three language. Yes, and they work. Uh, so no concept of transaction fees, but being private and you know who you are, Who who the nodes are. So you you have You don't need to, uh, untrust everyone. In a sense, you have a certain level of trust assumptions about who is in the network. And if they misbehave, at least you can take them to court because, you know, Alice and Bob are the ones in the network, not some random ideas. So because of this, you get much higher performance. But of course, these networks are not as secure as let's say, Bitcoin Ethereum. So so you. You rely on the trust to build the most simple solution, but you get better transaction performance in the sense latencies are in seconds. So typically in hyperedge fabric, you build a block every two seconds. Not every 12 seconds, not every 10 minutes. So every two seconds, and you can do about 1000 plus transactions per second, depending on your hardware setup. They also have what are called private transactions. So private transactions are a little bit more complex, so you can't run at the same rate. But at least you can do about 400 plus, uh, internally, this is very similar to hyper fabric. You have a bunch of sorry, uh, very similar to Ethereum. You have a bunch of transactions. Those transactions becomes a block. A block is linked to the next block like that. Only thing is, when it comes to maintaining states in your smart contract, you manage them as key value pairs. Now, in your lunch venue contract, you have hash maps. You have variables, things like that. But behind the scenes, though, it is not visible to you. Ethereum Virtual machine VM manages everything as a key and a value. It's not directly visible to you, but in hyper fabric, everything is visible to you in the sense. If you want to keep track of, let's say, properties of cars that is in your stock or that that you are selling, let's say there is a key and a value, so this is just like some unique key, like car one, car two like that. And here this is this is pretty much adjacent object. So again, each of those has a name and a value. So Car three has a colour is of colour yellow. And it's a Volkswagen and Passat like that. So pretty much anything that you can encode as adjacent object can be stored. Only thing is compared to, uh, solidity. This is a little bit more visible sometimes a problem sometimes. Good, because you can just put a json object and forget about it. OK, so who is not aware of what adjacent object is? Everyone knows what a Jason object is. OK, so pretty much, uh, object in javascript. Now, this is where hypo gets too complicated, how they build or how they validate transactions and build block. So if I have a transaction, So for example, let's say, do we have an owner here? OK, so there is an owner. So let's say we are gonna sell this car. Three, uh, and current owner is Max. Let's say it's gonna be Alice. So you issue a transaction to the network saying car three ownership need to be changed to Alice. Other things won't change. So what you need to do is you need to figure out that particular record and change the owner from Max to Alice. So you create a transaction. So this is called proposing a transaction and this proposal need to be endorsed. Let me check. So this is interesting in the sense rather than getting the whole network to validate my transaction, what I will do is based on whatever policy I will decide. He need to validate my transaction and she need to validate my transaction and she need to validate my transactions. So I'm I'm getting few others to look at my transaction and indoor for me. So each of you have will look at whatever you know about that car three and say its current owner is Max and all. Max is Cindy saying that change the ownership to Alice. So if the transaction is signed by Max Private Key, have you verified that he's using Mac public key? And that's a very transaction. So I get few others to look at my transaction and indoors. But if they don't like it, let's say the transaction was issued by someone else other than Max. Then you can discard the transaction. So you get the endorsements. If so, we call. The transaction is actually created. So now I have a transactions and three people vouching for my transactions. So those three will need to also sign my transaction with their private key saying so and so is endorsing this transaction now. Then I send this transaction to a special node, actually a cluster of nodes called the order The order. I validated the transactions to make sure my signature is correct. And I have three endorsements and the three endorser signatures are also correct. If so, it is a valid transaction. If not this card, if it is valid, it will put the transactions in a particular order saying Here's the first transaction in this block. Here's the second one third one like that and here's a block containing all of them. And then he broadcast that to a set of notes that keep track of the ledger. And at that point you record the transaction. If I wanna miss like if If, uh, maybe so. This is how it happens. So you get these endorsements so endorses will actually execute my transaction to make sure I am Max. Um, now, in this car, ownership is easy. You just need to change the owner. But there may be other things. Like, let's say in your voting example, you need to count whether there are enough votes, so so like that you will execute this transaction. In a sense, you simulate this transaction and indoors put a stamp on that, and this creates something called a re write set. Now, this is probably where you're gonna get messed up in the sense, uh, this this takes a very different approach in the sense, um, if you remember here there's a version number. So the read write set pretty much remembers it like that. So it remembers current version number is zero, and the Reed said is pretty much whatever you have here. And the right side is, once you update, this becomes Alice and that will become version one. When you do a change on this record, you just include the version number and you get enough endorsements and you send that to the order. So the only thing that the orderer will do isn't just verify whether the transaction is valid. It doesn't verify whether Alice or the Max Max is doing the correct things. It only validate the signatures and the endorsements. If so, it will say, Here's the first transaction and it takes another transaction and say Here's the second transaction like that. So this just creates a global order of transactions. If you remember again, going back a block is a sequence of transactions. So this is what the order is doing. It is putting a block set of transactions into a particular order and and label that, let's say this is block N. Then after another two seconds, it takes a few more transactions. Put that into a block and say Everyone believe me, this is blocked in plus one and again after another two seconds. Here's another block. So this is where we are saying, Is this proof of authority? There's a particular node or set of notes that we designate saying you have the right to build blocks, no one else. So there's no competition here, like in proof of work or proof of stake. You don't randomly pick someone. There is someone always building blocks pretty much every two seconds. As far as there are transactions to be built to be put into block. So then you broadcast this one to everyone. Uh and so this is pretty much doing an ordering service. You just order the transactions in a particular order and then at the very end. So whoever received this block, they will validate every transactions in in that block and make sure that read, write set is still valid. So OK, this is how it can go wrong. Let's say Max is selling the car to Alice, so there's a transaction for that. But Max decide to double spin. Max is also selling the same car to Bob. So let's say there are two transactions. But because of the sequential ordering, only one of those two transactions will appear as the first one and the next one appear as the second one. Network doesn't worry whether I'm actually sold that to Alice or the Bob. Only thing is, it will make sure the car is not sold to both of them. So this is pretty much what he's trying to do. So he put them in a sequential order. And what happens is this. So this is where you validate the reads right set. So if this ownership changes from, let's say, Alice Max Max to Alice, this version number becomes one. Now let's say you have the second transaction where Bob is trying to sell. Sorry, Max is trying to resell this car to Bob now. At that point, initially, the version number was zero because now the ledger has been updated. This version number becomes one. So you have a grand section saying When we endorsed this transaction version was zero. Now version has changed. At that point, What happens is second transaction. Get discarded. Now, if you understand a little bit about detailed databases, enterprise databases, how they work, this is nothing new. Now let's say there is an airline reservation system when you go and when you want to book a seat on the airline, everyone like you can go to the website say I'm going from Sydney to Melbourne this day, this time this flight, and let's say it shows you there. Seat number 23 B. While he is, she's looking at 23 B. He can also look at 23 B, but until whoever pays first they will keep showing that 23 B to everyone. So when her U I loads in the sense when the Web page loads she C 23 B is available. He also sees 23 bees available. Maybe he also sees 23 bees available. But if he's gonna pay for that first 23 B is now gone and on the database. Also, that is not visible to you. There is a version number. Now let's say she's willing to pay for that, and she put her credit card details and all of that and say, say, pay. But at that point, the database will realise when I show it to her. Let's say the database version number was two. So she has two. He has two, and he had two. But as soon as he got the T, uh, got the seat, that database entry changes, So that becomes version three. Now the database realise, or someone is saying that they wanna book the seat. But when they look at the database, they had version number two. But now the version number is three. So that whatever she is saying, no longer valid. So you go back to the client and say sorry CD is no longer available. Do you want to pick something else? That's that's how they really work. So this is a way to make sure multiple people can see the same data at the same time, but only one can update. This is how you essentially deal with any any pretty much banking or any particular problem where you allow people to see something. But take an action later when you take the action later. If the version number that you are seeing is same as what you had at the beginning, then the data has not changed is good to go. But if the data has changed, you are not allowed to go ahead. So that is pretty much what is happening in this day case that you revalidated whether the red site set is still valid. So that means between initial simulated execution of the transaction and its actual commitment If nothing has changed, that's a valid transaction that can be persisted on the ledger. But if something has changed, then you cancel the transaction. At that point, why this is significant is it allows you so much parallelism. It allows you to run so many transactions parallel only the transactions that have conflicts in the sense version number change will get invalidated. Everything else go ahead. So let's say you had 100 transactions. Most of them won't be offered the same account or or same same car. So 99 pro probably will go ahead while one get cancelled and you need to retry. So this is how these systems get a much higher throughput than, let's say, Bitcoin or ethereum By allowing parallel things to happen parallel, but only when there is a conflict, you just deal with that conflict. And the other thing is now, if it is valid, if it gets stored on the ledger immediately. At that point, the transaction is final. So your typical latency to start from the top and to go here is about two seconds, or typically 2 to 3 seconds. It is not 12 seconds or more important, another 65 blocks as confirmation blocks in ethereum or, let's say, six blocks in Bitcoin. So so your your transaction goes into finality as far as the value transactions somewhere between 2 to 4 seconds, it's just a delay that you have in in getting into a block. Now this is there's too much here to understand. I'm happy to answer any questions that you have. Even if you don't understand a lot, don't worry. But what you need to understand is compare things like Bitcoin and ethereum. So you execute a transaction. You put that to a block and you try to make build up block here. Your execution and actual persistence of that into the ledger are two separate steps. You execute a lot of things parallel. You end those a lot of things parallel and later you put them and save them in the ledger. Any questions if you are interested in the details uh, this paper explains, But again, to understand that you need to understand this idea of the read write set. So essentially, the idea of the read write set is when you read the data, you may remember the version number. And when you actually try to write the data, if you still have the same version number data has not changed. But at the time of writing, if you realise the version number has changed, data has changed and you're not going to write that transaction. So user will feel a little bit of a problem here. They need to retry to get that transaction included. But on the other hand, someone like Max trying to sell the car twice. That is always avoided because only one of them can own either Alice or the bob, but not both of them up wrong here. Uh, OK, so going further. So let's say if this is the hyper fabric network. So each circle is a node that runs the software, or let's say the client in you can actually have sub networks. So let's say whatever happening in these nodes are not going to be visible to these nodes. All of them are part of the same network, but you can logically partition on the network, saying whatever happening in this channel is not going to be visible to others, whereas this one, this particular node is in two separate channels. So this is a way of segregating data, in a sense, like whatever happens in certain set of nodes are not going to be visible to everyone in the network. So this is another form of permissions we are talking about. So let's say whatever happens between me and my supplier can stay in one channel, and me and my customer can stay in another channel. So, for example, let's say if I'm in some sort of a business, I get something from someone I may add some value or not, and I sell it to someone. I buy something for $10. I sell it to $15. My customer should not see that I'm getting something for $10. That's at least how the business world works. So whatever between my supplier and me is in one part of the network. One channel and whatever between me and my customer is in a separate channel. So those are kind of the reason that people also use channels. And there's something called the membership service provider. It's actually not really a service, just a file. You add your public key to that file to become part of the network. So this is where the nodes get registered into the network. So again you cannot just randomly add anyone. You have to follow a particular procedure in the sense, uh, you have to go through the membership service provider, which is an authorised node that can introduce more nodes into the network. So membership service provider is trusted in the sense the whole network trust relies on. This one said that it will not add some random notes. So it will. It will do whatever the due diligence before adding someone, Let's say Company A and company B are gonna work together. So if you are gonna add a node, you really need to make sure that node belongs to, let's say, company B. So MSP has that responsibility, and what you really do is you just add the public certificate to introduce that organisation and that particular nodes. So channels are like subnet. Networks allowing you to have reduced transparency, like whatever is visible to certain set of nodes, are not necessarily visible to everyone. And if you do, if you want even further privacy, there is what is called the private data collections. So you can have a situation that my customer sees. Let's say I got let's say, 10 to 10 tonnes of let's say beef. My customer would see that I got 10,000, but the customer won't see at what price. So private data collection allows us to share certain data, but not everything. So, like the volume of the transaction, the date of the transaction can be exposed to everyone in the channel. But I can still hide the price I pay to buy that beef from the farmer. And the farmer would not see how much I sold that for, So you can further separate things. Uh, so there are three other roles in the network. Clients are the ones who want to transact like Alice Bob Max, who wants to transact? They are the clients. Uh, so a client can be a member of multiple channels like remember that circle that was in two boxes. So each of those boxes are a client. But there can also be, uh, like plants with two special roles either a peer or an order. Uh, so peer peers are the ones who are actually going to maintain this ledger. So it's a key key value to you can either run level DB or couch DB. Those are key value stores. If you are familiar with the idea, these are no SQL databases, so default is level DB. But if you want to run a larger hyper fabric network, you can just change that to Kaus DB. Um so piers, they receive the order, uh, order transactions from the ledger in the sense from the order, and they maintain the ledger. So they are the ones who will remember, uh, there is this car called car three that belongs to Max. So they maintain this information, but they can also play these special roles like indoors. So remember, I said, like, three people will look at my transaction and say that's a valid transaction. So they they can play additional roles in the sense they execute a transaction. Look at whatever you are claiming is true and they put a stamp on it. How they put a stamp is essentially by digitally signing, whereas the orders are the ones that would say that will get all the transactions and put them in some sequential order that everyone in the network agree. This is the order. This is the first transaction. This is the second transaction, the third one, and he has blocked one. Let's say this is block two. Transaction 123. Like that. Uh, so these are like the the miners or the validators in Bitcoin and Ethereum terms, they are the ones to put things in in order. These ones are the actual ones that maintains the ledger, so they are very different design but gives you certain advantages like let's say your transaction is final as soon as it is written to the ledger. And, of course, it can allow so many transactions to happen. Parallel. So that's why you get numbers like these last slide on this one. So what do you think? OK, I didn't talk about this, but you should be able to logically deduce the answer for this first one. As psychology fabric uses the MSP, it's not required. Assigned transactions false MSP will introduce you to a network saying you are a valid node you can transact, or if you are a peer, you can keep track of the ledger. If you are an order, you can order transactions. But that does not mean that every transaction still needs to be digitally signed. Now I didn't talk about like why there are three endorses or two ends or whatever in high pressure fabric. This is based on policies set of organisations can define a policy saying any transactions need to be signed by, let's say two organisations. That's a simple policy or you can have a policy saying any transaction need to be signed by three organisations in the consortium. And if it is something like a smart contract, what they call chain code if you are deploying a chain code default policies if a new chain code to be deployed onto the network installed onto the network, everyone must sign. So let's say if five organisations work in a supply chain, each organisation need to approve that transaction, so it's a policy. So the thing is, there is a policy to define policies. If you are changing a policy, everyone must agree on the policy. But once the policy says only two signatures are required, you can go ahead so you don't need to go and ask all five organisations as far as any two defines. So those are not the things that are not visible here, but it's a little bit more complicated, but it it nicely fit into enterprise systems like what enterprises? In the sense, let's say banks, financial institutes or large. Let's say retailers and all of those have been doing for a long time, so it's nothing new for people who understand that domain. It's just like, let's say you probably as undergraduates, are not so much exposed to some of those. So Readwrite says database versioning. None of those are new, and this was developed by IBM, who anyway knew that for what, 50 plus years? Um, so that's that's how it is designed. OK, second, one consensus algorithm is hyper fabric is based on proof of work. What's the answer? Proof of authority? Um, that's the most dominant one. But the general idea of high pressure fabric is you can change the consensus protocol by essentially like upgrading a plug in third one. Both ethereum and hyper fabric maintains the world state as account balances. Yes, so here's an example of an account balance. That's the key value store. So this is like the account number, the unique number. And he is the balance in the sense. This is your as an object that maintains anything. Yep. Um, last one finality in hyper fabric is immediate. I mean, immediate. In a sense, it still takes. I said, remember, I said like 2 to 4 seconds. But as soon as it is written into that database or whatever the node because it had to be final. Whereas the idea is with something like Bitcoin and Ethereum, you still need to wait for those confirmation blocks. So so don't consider, like, two seconds. DeLay does not mean it immediate in in the sense here, the idea is, once you write that you consider that to be persistent or or stored forever. But before writing, of course, you go through all of these, you simulate the transaction, get the readwrite set, you validate the readwrite set and all of that. But that's that's once it goes into that step, it's done. Um, I'm really behind in starting the next topic, but anyway, uh, I'll I'll discuss with Helen what to do about that. But let's see, whatever we can, we have about another 10 minutes. But before that, any questions based on whatever discussed so far from last Monday to today? So what's the Blockchain? What's the block as John?

SPEAKER 1
Fine.

SPEAKER 0
Yeah, anyone else was on the final Blockchain. What would be your definition of a Blockchain?

SPEAKER 2
A chain of blocks.

SPEAKER 0
OK, so what's the block there? So what's the transaction? OK, so if you pretty much like like three sentences like that. You you define a Blockchain at a high level, so I I'm not worried about the specific answer. But as far as you understand, it's a way of ordering transactions that everyone in the network agree what that order is. That's essentially a Blockchain. How Ethereum does that is a little bit different from how Bitcoin does that. How hyper does that is very different from anything else. And there are a bunch of protocols called PB FT, which are even more complicated, but they can do 110,000 transactions per second. So, as far as you understand, what we are really trying to do is to provide a consistent way of keeping track of who owns what in a global network by coming up with some way of doing it. That's that's essentially what the Blockchain does. So Blockchain can be this linear sequence of blocks or can be something a little bit more complicated. Uh, you already know about smart contracts, at least because you have played with them. But let me see how much I can cover today, but, uh, and I'll I'll discuss with Helen what to do about the rest of these slides. Um, OK, so Blockchain is a combination of platform. It's more than a distributed database, in a sense, because you can attach business logic, not just record data, but you can also decide what to do with that data. Um, have you heard of stored procedures? Stored procedures in databases? Who has heard of it? Please raise your hand 12. So with databases, you usually write SQL, but you can actually put SQL queries into the database itself. So those are called store procedures at a high level. So again, if you really think about this is not very new, you can still attach logic with data and and get your database to run things for you. So anyway, uh, so it's user defined code, but at least all procedure are defined by the database admin, not by any user. So here, anyone can define them, uh, and executed by the whole network, you maintain the ledger, and if you talk about this in in general programming, smart contract code is like the class the actually deployed. One is like the the object. And because of that, because this is still programming like General Software Engineering still apply. So the idea is, let's say, if you are talking about Ethereum. So here's a smart contract that has a bunch of functions like what you have in your lunch menu contract and you have some storage that keep track of the list of friends who can vote their votes, the restaurants and things like that. So that is this. So this data can only be manipulated through these functions unless you mess up your access control. Remember, we had, like, Manager only manager can add friends. Manager can add restaurants like that, but in in your project one you're not using any of the E a balance. But in one of the later labs, I think we just play with a little bit of ether, just just for fun, in the sense. So you can also have an ether balance as well. In addition to whatever your, uh, data in the smart contract, so code is deterministic in the sense. If you always give the same input, it should always give you the same output. Now, something like the random function is it deterministic. Random function in python or Javascript or anything like that is a deterministic No. If you call random dot whatever, depending on the language, what you get is probably not going to be what I'm going to get, even if he is. I mean, usually if he said the same seat he should get you, you should get the same value. But generally what you get is not going to be the same as what I get now. This is not good in smart contract programming, because when you when you have a solidity programme, solidity does not have a random function. Because when 10,000 mine, let's say 10 10,000 ethereum nodes try to execute your smart contract. Each one is not gonna get the same value. So there are minors won't agree. What you execute is the same result as what they get so generally in smart contracts. We don't use functions like those that are not deterministic because it depends on who he is executing. Now the thing is, I said, hypo fabric, you can use javascript if you put random function in JavaScript because JavaScript supports that in hyper lure. You're going to get into a problem, but language won't prevent you from doing that. It's just you need to know that you should not be doing it, whereas a purpose built language like solidity. Make sure you cannot do that simply by not providing such a function. So as far as you give the same input, you should always get the same output. But there are two things. One is the input that you are giving into the smart contract function. The other thing is the current legislate. So let's say when you vote, remember in your court, we keep track of the total number of votes that are received so far, so current vote, plus the total number of votes. If they exceed the majority, then you take a decision. That's how it works. So there are two things. It's not just what you give us input. You will also remember what is already stored in this private state. Because there, if you if you remember, some of you may have seen this, there was a question about like my contract was not executed in the way it was supposed to be. It's simply because the student gave the uh, student did a vote before adding a restaurant so that that previous vote was already counted so that that private storage is also going to affect. So the thing is, you can only execute a smart contract using a transaction. Um, now, in the ethereum terminology, they call this also a message called You Send a message to execute a function. Why the smart contracts. Execution is trustworthy because we deploy a smart contract as a transaction and only someone with a private key can do that. And and the whole network can see that it is immutable. It is transparent and deterministic code. So if you can only execute a transaction Oh, sorry. A smart contract only by sending a transaction. And it also depends on the ledger state. You have a very clear idea what is going to come out of that transaction. So the output is also transparent and there is integrity. Why did you get this output Because of this input and this code. So that is why it becomes trustworthy in the sense code is visible. Code is behaving the way that it should be. And then we have all the other properties of about, like immutability transparency, properties of the Blockchain and high integrity. So no one can let's say go and mess up the code once it is deployed. So what happens is someone goes and deploy a smart contract and then others start executing them later. And then let's say there is someone else who is just looking at what is going on and they can see OK on this block. It got deployed, and on this blot it got executed. And what are the results? So of course, it is possible, even on the same block, to execute this. But usually you execute a smart contract more than that. So that's why you kind of drone it like this. You can execute it again and again until it is disabled.
