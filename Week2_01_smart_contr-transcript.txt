SPEAKER 0
Hello, everyone.

SPEAKER 1
This is a continuation of the lecture that I could not finish. But what I'll do is I'll go through all the slides and even the few slides that I covered. So the idea is rather than you somehow ask cover in this one as well as also having a guest lecture. We will replace the guest lecture with this one because we will anyway have some industry representatives coming and talking to you during the latter part of the term. Uh, during what we call the Blockchain Peak. So you already have some idea about what smart contracts are at a very high level. These are programmes that you can run on a Blockchain. So what I'm gonna discuss through these slide is like, what are smart contracts a little bit more formally and also kind of compare and contrast smart contracts and legal contracts. Then we'll talk about tokens that are some form of an asset that we can issue using a smart contract and then oracles are the mechanisms that allow us to connect the Blockchain with the real world. So we are. We can have bidirectional data flow between the real world and the smart contracts. So let's let's start with smart contracts now. Smart contracts can be a Blockchain is a computational platform. If you remember, Blockchain can play four roles in a software architecture. We said it's a storage element. It's a computational element. So this is where you can run some sort of a business logic. Uh, a block like Blockchain like Ethereum becomes more than, let's say, Bitcoin because Bitcoin is most like a distributed database that keep track of the Cryptocurrency ownership. Whereas Ethereum, you can do a lot more interesting things, then the other things that we said is, uh, a Blockchain can be a communication mechanism as well as asset management, uh, framework. So at at a high level, smart contracts are user defined code that is deployed and execute across the whole network. So this is why when you deploy your code to, uh, let's say, the test network ethereum test network, you can go and see those transactions on the scan so a smart contract can maintain its state on on the ledger. So, uh, so if you look at this as the Blockchain, a smart contract is a bunch of functions that you can call. But the contract itself has some PRI private story. So this is how we keep track of, let's say, the restaurants and the friends who can vote in in your project one. And of course, a smart contract can also, uh, maintain some Cryptocurrency balance if it is a public Blockchain, whereas in in something like hyper Ledger, you won't see the account balance. But you will definitely can maintain various data. So a smart contract can hold and transfer various forms of digital assets that are managed by the contract itself. If you try to relate smart contracts to, let's say, general programming, So if it is, it's like a Java programme where the source code is like a class and the deployed contract on a Blockchain is like an object. So in that sense, many of the designs patterns around software still apply to smart contract development or, let's say, smart contract engineering. So Blockchain uh, behaviour is deterministic in the sense it is transferal, and everybody agrees how we are going to change the ledger state. So in that case, the code is persistent because when you deploy or when you put something on a Blockchain it is immutable. But what? So we call this deterministic in the sense, if you always give the same input, a smart contract should always give you the same output. But this could. This depends on two things. One is your input as well as the ledger state. Say, for example, if Alice has 500 tokens and and as soon as she let's say, transfer 200 of them to Bob, the ledger state changes. So when you when Alice does the second transaction, the state has already changed. Uh, so this is why what I'm saying by like, however, from the, uh, from the viewer's point of view, a state may not be deterministic in the sense like when you send a transaction to the Blockchain. Let's say Alice has already 500 whatever tokens. But if another transaction get executed before your transaction, So in that sense, uh, the state on the ledger has already changed. So a smart contract can only be triggered via a transaction, uh, in in ethereum terms, we sometimes call these message calls. And of course, a smart contract can be invoked by another smart contract. Only thing is that smart contracts must still be invoked by some sort of a transaction. Now, sometimes people say smart contracts execute automatically. That's not quite true. Smart contracts will always execute against some sort of a transaction. Someone is going to issue onto the Blockchain now. Why Smart contracts are trustworthy is the same reason like why Cryptocurrency transactions are trustworthy. Because Blockchain is immutable, we have high transparency. And when you also add up vitamin the code where the inputs, depending on the inputs, you will always get the same output. So because of that, we have this predictable behaviour on on a Blockchain. And as I just said, like a smart contract can only be executed through transactions and it depends on the current legislate as well. So because of that, we have a transparent and integrity on what is going to happen. So if everyone could ideally look at the code and understand what the code is supposed to do and and be and and be able to agree, like if you give this input, this is what is going to happen now. Life of a programme on the ledger. What I mean by this is like, let's say, somewhere in in some block. Someone issue a transaction to deploy the smart contract, and after that you can start interacting with it. So let's say, Alice, deploy the smart contract. Bob is the one who execute a transaction on that. And let's say, Charlie, sometime later, I can also see everything that happens on the Blockchain. Charlie can see that someone with an address of Alice deployed the smart contract. And let's say someone with an address of Bob, uh, executed that smart contract. Of course you see the addresses Not necessarily Alice and Bob, unless you know who who those addresses belong to. So they would see the Charlie would be able to see everything that happens on the Blockchain. Of course, that depends on the permissions. Now, on things like Ethereum, you would pretty much see what everyone is doing. Whereas if you're talking about running a smart contract on hyper fabric, if you remember, we talk about channels and other ways of segregating data and preventing people from accessing others data. So in that case, what you really see on on a public private permission, Blockchain like hyper fabric depends on what are the permissions that are set. So what are smart contracts? Good for? If you remember, we said Blockchains are good for new and trustworthy ways of working together. And they're also good for exclusive control of digital assets. In the sense, if you remember, we talk about this cute digit. Uh, P, uh, photo of a digital photo of Let's say, this dog that we can convert to a non fungible token. Now the photo is in digital form and and the non tangible token will be on a Blockchain. So both are on digital form. So So the same applied to smart contracts because Blockchain is, uh is immutable and transparent. And now you also have a piece of code that is deterministic. If you always give the same input and the same ledger state, it will always give you the same output. So because of that, smart contracts pretty much inherit the same properties of a Blockchain. But the interesting thing is like if you only think about something like Bitcoin, we are talking about the Cryptocurrency ownership that is some form of data. But it can also give you shared behaviour. So if you think about your project one you you have a bunch of restaurants, you have a couple of friends and you together. Try to decide where you want to have lunch, so that's that's a form of a shared behaviour. So in a supply chain, for example, when a good passes from 11 organisation to another how you are to pay whether you're going to pay everything part of that so all of that you can qualify and put that into a smart, smart contract. So in that sense, smart contracts allow you to have new or even better ways or programmable ways of working together So you can programme how these various assets are managed or how you manage What are the forms of data like, uh, where, where, when and who had access to an item in a supply chain and things like that now, something to understand is smart. Contracts are mostly used to control various digital assets. Uh, like non fungible tokens. Uh, we'll talk about what? What? That is very soon, Uh, but there also can be digital assets itself. So there's a smart contract called Forage. So what is called an a Ponzi scheme? That what this is if you pay to it and become a member of that. So you become you have partial ownership of the smart contract. So if you if you get someone else to sign up using your handle or let's say your reference and then you get to get some get paid part of what those people invest in when they join the scheme. So there are various interpretations around that. But what you need to understand is it. It's usually used to manage various other forms of assets, but of course it can be an asset. So let's talk about how someone would interact with a smart contract. So someone goes and deploy a smart contract onto a Blockchain, and after that you can issue transactions to invoke various functions. Now, if you if you think about in in what you have been doing with solidity and Ethereum, so you create a smart contract. And in that sense, the two address, which is the recipient address of the smart contract transaction, is set to now. But once the smart contract get deployed on the Blockchain, you get an address which is a globally unique address to interact with that smart contract and as I said earlier. A smart contract includes some bunch of code executable code, some private storage, uh, like the restaurants and the friends. And their votes are like that. And of course, there can also be some Cryptocurrency balance. Now, the type of transactions that you can issue to a smart contract can be broadly classified as monetary transactions and invoking transactions. So what this means is, let's say, if you are just transferring it in and out of this contract that is a monetary transactions. Whereas if you are, let's say, adding a friend, adding a restaurant or voting, that's we usually call as an invoking transaction. So what you need to do in this sense is you need to know what functions you are invoking and what are the inputs to that function. And, of course, like in general programming, a function can also call another function, even in a different smart contract. Now, smart contract deployment in Ethereum Um, so we are already talking about solidity, which is one of the high level languages that are supported in ethereum. Uh, there is support for other languages, but I would say solidity is the the de facto or the most dominant language. So what do you Ha! What happens is you write your small solidary code. It goes through a compiler and you generate a byte code. What is called the Ethereum Virtual Machine Byte code that runs on the Ethereum virtual machine. So So, the ethereum node that runs this piece of code, uh, is called the Ethereum Virtual Machine. This is like a virtual machine, um, in in in, let's say, cloud computing in in general. Um, now, when you do that, there is something called an application binary interface which you will encounter more and more in in the upcoming labs. This is essentially the specification about these functions. So let's say what what, uh, what is the input? What is the name of the function and what are the inputs to that? So solidity is a high level during complete language, which is also object oriented as well, and syntax particularly more similar to javascript. But you will also see a little bit of python, uh, kind of behaviours in here and there as well. So this is what is called a statically typed language. So in that case, when you compile, it will check whether your variable types and things like that are properly specified and whether they map properly. And and, of course, there are other things like inheritance are supported. And, of course, there's a bunch of libraries that you can use to reuse other people's code. Now, something interesting in the Blockchain space is I mean in software in general today is we wanna re reuse as much as other people's code simply because they have been developed over a long time and well tested. And they we know that they tend to have less issues compared, let's say, someone writing their own code. So here's a simple solidity example. If you look at we, we have this pragma solidity. This is what we call a preprocessor directive or an instruction to the solidity compiler, saying this piece of code must only be compiled with a compiler version about 0.7 and less than 0.8. So this is to make sure when you compile this code, there is a well defined, deterministic behaviour. So in this case we just have a unsigned integer called to data, and here's a get function and here's a set of function, so this function is a read only function. If you see, there is a keyword called view. So that is how this function becomes a read only one where this is an A right or update function where you can set the value of this store, uh, store data. So you pass an un signed integer as the input and that will update the value. Now, something to understand is if it is a read only function, you can pretty much go to any node on the Blockchain and and they will give you the current results based on the ledger state so it will store return the value of store data. Whereas if it is an ex, uh, the right writing function like this one where the ledger state would update then, of course, this has to go through the mining process where someone include this transaction on a block. And then, of course, that block need to be on the longest chain. Now, here's a little bit more complicated. More real life, real life life code of what is called an escrow O contract. So in in general, what an escrow O would do is it will hold on to like money for a as a third party, so that let's say, if Alice and Bob is engaged in a transaction just to make sure, let's say Alice pays Bob and Bob runs away with money without delivering. Let's say the bicycle to Alice. You can rely on an intermediary like, let's say, Charlie, where Alice first give the money to Charlie and and both Bob and Alice trust Charlie to do the correct thing. So if the bicycle is actually given, Charlie will give money, too. Uh, Bob, uh, if not, Charlie will return the money back to Alice. So the contract name is Crow. There are multiple addresses. So here we have the pair. So in this case, this is like Alice, who is going to be the beneficiary of the recipient, which is the, uh, which is Bob in this example. So Alice is paying Bob and Charlie is the third party who would approve whether it's good, uh, that the transaction has happened properly. The transaction in this case, let's say, uh, selling the bicycle so that the money can be released. So when you deploy the contract, we have the constructor. So we specify who the approver is so that's Charlie. And who is the beneficiary? The recipient is in this case, Bob. And of course, we identify Alice is the one who is deployed in this contract using message dot Send them. So this is the way you find who would send this transaction. And you said that as the payer. So pay. I said to the whoever deploy in the contract, and there are two addresses. One is designated as the approval. Other one is designated as the recipient, so someone can call this function pay. Um, so in this case, you would check whether the message sender is that approved. So only Charlie can, uh, request the to pay. Otherwise, uh, uh, the transaction will revert at this point and you get an error message essentially, uh, in in this case, not the There's no message. But the idea would be you would say, Oh, you're not an approver. So because of that, you cannot execute this pay function. If it happens to be the approval, what will happen is you will transfer. Uh, whatever the Cryptocurrency locked in the smart contract. Let's say this is solidity. We are talking about ether So recipient, which is in this case, Bob's address recipients will address will see a transfer. Now, this is again a little bit more complicated. So this is the this contract. So you take the address of this contract, and whatever the balance that is here, you would ended up transferring the And of course, there is another function read only function. If you see view here, uh, that is added to check what is the current balance? Let's talk a little bit of it about the features of solidity. So being an object oriented language, you can do things like you have interfaces and extend those contracts in another contract. So in this example, let's say, base is our the main contract uh, the the the initial contract where you have a function for. But we haven't even defined its implementation. So you can import this function, uh, smart contract in another contract. So in this case, let's say the derived contract is import in the base contract and then you define the implementation of function F, so you can, of course, overload functions. Uh, only thing is, be careful when you do that, because you have now multiple functions with the same name, just different parameters, so things can go wrong. If you're not careful, you can define arrays. And like, let's say, here we define an array of size three and then define, uh, set the first value to zero. Now, one thing to understand is like in object programming. Usually when you instantly a class, you execute the constructor. So like that when you deploy a smart contract, you can execute the constructor. So in that case, when you deploy a smart contract, you can, of course, pass input. So in this case, we are passing an un signed integer called I into this contract. Here's another example, uh, that that keep track of ballots somewhat similar to what we are doing in in project one. So let's say you have a strut call voter which keep track of who is going to vote. What was the vote? Uh, whether the person has already voted. And of course, if you want to give weight to this vote, So for an example, like if it is something like stocks, and if people are going to work, uh, vote on what a company should be doing, usually your vote is weighted based on the amount of stocks that you own. So if you own more stocks of a company, you usually have a higher say, um in in whatever the decision, uh, you want the company to take And, of course, let's say in this example, you also have a delegate where you define some other address address to vote on behalf of you. So here is another structure called proposal. Just count the votes. And and then there's a chairperson who kind of managed the whole voting process. So you have a bunch of voters. Uh, this is a hash map. Uh, this is hash map or a hash hash hash table. So there's a There are two things. There is a key and a value. So the address is the key, and the value is whatever the the vote in in the list of, uh, so the water and and and the name of this hash map is the votes, so you have a bunch array of proposals like that. So here we have a constructor and you have certain number of proposals that you pass as input to the constructor. And when you deploy the contract. You said whoever deploying the contract. So that is the message that sender as the chairperson, of course, the chairperson has a weight of one. So that is pretty much what we are saying in this hash map. Chairperson A is the key, and and the value is the structure, the water struct structure and that structure has, um, a AAA parameter or or, let's say, a variable call weight. So which you said to what? And and then you said, What are the proposals? So which is an array? Uh, and and the length of that array is whatever you're passing as into the, uh, the construction now a little bit about like, uh, being objector in the programming, you may have come across like public private functions. Now there are two types of function calls in solidity, what are called internal calls and external calls. So internal calls are the function calls originating within the contract itself. Let's say a transaction calls function a and function a may call function B within the same contract. But whatever that transaction, that call function a is the external one that is being executed by someone issuing a transaction. Now there are four types of visibility. Function visibility in in solidity. So the public is the usual public. Pretty much everyone can invoke that function, whereas private means it can only be called within the contract itself. So let's say, if someone calls a, which is a public function, a may call B, but nobody can directly call B and not even in a derived contract instance. So let's say you have a contract and some another contract is, uh, extending that contract. Even in that case, you cannot call that function, whereas internal allows those derived contracts to call that function and external means. There can also be functions where you designate and say this function cannot be called within the contract, but it can be called using a smart, uh, transaction. So So, for example, here's an example. Like if if a function F is marked as external, um, so you can't really call if within the function itself. But there is a work around. But when you say like this dot F, this always refers to the current contract, and in that sense you can call F within the contract. So this is kind of a way to bypass that. But that means you have to explicitly write it this way. Not that you can just go and call function F.

SPEAKER 0
Here's a couple of examples to demonstrate function visibility.

SPEAKER 1
So we have a contract called Contract One and it has a private variable called data. Because of that, you cannot directly change this variable or even read that. So you need to go through a bunch of function. So function C essentially takes a value and set that increment the value, uh, and return that to you. But this is marked as a private function, so it cannot be used in anything other than within the contract itself. So data set is a function. This is a set function that you give some input X, which will be used to update data. So if you know this, it's a public function. Whereas this is a read only get a function, but interesting. It is now marked as view. Probably a compiler is gonna complain about it, but it's also a public function. So here we have another function called compute, where you give two inputs X and Y. You just add them up and return the results, and this one is marked as internal. So in contract two, what we are doing is we have a function called data read. It is going to create an instance of this contract one, and we can manage that using variable Z. So now what we are doing here is, uh, here we call the the contract Z, which is Contract one, and we are trying to call this function. Now, if you look at this is marked as private, so anything that is marked as private cannot be executed anything outside that contract. So in this case, contract two is not the same contract as contract one. So you're gonna get an error, which is kind of indicating you don't have access to this function. Whereas if you look at data set, it's a public function, so anybody can call that now. Data gate was also a public function, not a problem. But if you again look at this Z dot compute. So compute is marked as an internal function. So if I remember from the previous slide, internal functions can only be called within itself or any derived contract. But in this case, contract two is not derive contract one which is just using an instance of contract one. So because of this, that reason this function call will also fail. Now, if you look at contract three, it is saying contract three is contract one. So contract three is essentially extending contract one. So in that case, this is a derived contract. So now we have a function called G and you create a new, um, a new instance of contract one, and and then here you you try to just call the compute, and and here you're not doing really anything with this disease. It just there. Uh, but when you call compute, you are directly calling the function that is here in the parent contract. So this being internal, it can be executed by anyone extending that contract. Now, a few things to understand when it comes to, uh, developing smart contracts. Try to keep your contract simple so that other people would understand. You also understand what you are doing, and and there are less issues. Now there are a bunch of best practises, which we will discuss in a later, uh, lecture briefly. Um uh, especially around security. So you need to follow those ones to make sure your pro programme is ideally bug free. Um, and and And you will not be in trouble because, as we discussed, there are no safety nets. If something goes wrong, Ethereum won't worry about that. Let's say, unless let's say it's $100 million loss or something like that. Everyone in the network is affected because of that. Uh, so look at the documentation again. This is related to lab as well and and follow the documentation because these are fairly rapidly evolving things. And and what I say today may may change in another week simply because, let's say there's a new version of solidity. Um, so, ideally, in in this space, particularly, most of the smart contract code is open source because the idea is, it's You wanna be transparent other people to look at your code, understand your code, and then be able to understand what's happening. So, for example, you will come across, uh, contracts like ER C 20 which is a a standard contract to managing what are called fungible tokens. Again, we will discuss this in one of the labs. Now the thing is the interface of a smart contract is not visible from the deployed code. So that is where this, a B or the application binary interface becomes very useful. That's where you keep track of OK, there's a function called Foo, which takes two input. Let's say two integers, X and Y. Um, so as far as you know that that's enough for you to interact with a smart contract. So you don't really need to know the fun implementation of a function. What you really need is the function signature. Now, decentralised applications are like mobile applications. So when when applications are on mobile devices, we call them mobile apps or mobile like that. So the apps or decentralised applications are the ones that runs on top of a Blockchain, so they usually use smart contracts as the business logic. Uh, so they they use the Blockchain to store the data and using smart contracts, you manipulate that data. Of course, there are interfaces, the API S, which again you will interact with some of the coming up labs to interact with the Blockchain. Now the thing is, sometimes when you have applications or most of the time not too instantly, sometimes you need to have some sort of a user interface. So of course, if it is a mobile device, the user interface will be on the mobile device. If not, you can You can store them somewhere. And sometimes people even explore decentralised storage systems to do that. So again, this could be become become very handy. Your project where you can decide to store, uh, what are called off chain data. The data that you don't store on the Blockchain on some decentralised, uh, database, uh, data storage platform like IP FS What? It stands for interplanetary file systems. So? So the idea is, rather than relying on conventional, let's say, cloud computing or whatever to host an application. This application, this is it Data. Uh, and and whatever the data that you store outside, you just store on a Blockchain and using some sort of a decentralised storage. Now, if you go to this website called State of DF, you will see thousands and thousands of decentralised applications that are around. So here's a question. Um, I'll give you a couple of some some time and, uh, for you to think about which of these are true. OK, so if we take the first one. Smart contracts are good for managing data and achieving shared behaviours. So this is true if you remember, We said Blockchains are good for shared data like Bitcoin but ethereum, uh, through smart contracts even allow us to have shared behaviour. Then the second one all smart contract languages are Turing complete. We only talk about solidity and say solidity is a turing complete language. I don't want to define what Turing complaint is. If you have taken a programming class, you probably may not discuss, but the general idea is A during programming language can pretty much do anything. Uh, this is not necessarily true because there are smart contract languages that are not turing complete. And this is by design because when you have a Turing complete language, you can have certain, uh, behaviours that are not necessarily deterministic across a network of nodes. So So for example, let's say if you have a random function, if we generate a random value on your ethereum node and if I generate a random value on my ethereum node, it's quite unlikely those two to be same. So in that case, we cannot achieve consensus because the two values we have doesn't match. So whatever you say as correct, I'm not gonna believe because my random number is different. So in general, this is not a correct sentence. Like there are enough. There are many smart like languages that are T incomplete, but not everything. Now smart Contract Ledger State may change between issuing a transaction, and inclusion is in a block. Yes, Why is, that is, Let's say I look at the ledger. I see. Let's say I as Bob, let's say I have 500 tokens. So I issue a transaction, too, um, to Alice. So I'm gonna transfer that. But maybe in the meantime, Charlie was supposed to pay me something, and Charlie may come and pay me. And if Charlie probably put a higher transaction fee, there's a good chance that Charlie's transaction make it included in the in the Blockchain before me. Now, in this case, this is a good, good one in the sense Charlie pays me anyway, so my balance goes up because of that. I can still pay Alice, but let's say I was supposed to pay Charlie. It's just Charlie never submitted this transaction for a long time in. In that case, somehow, if Charlie's transaction get included before my transaction to Alice, I'm going to be in trouble because my second transaction won't go anyway. Coming back to this question, yes. Smart Contract Ledger State may change simply because other transactions may get included before your transactions. Changing the ledger state Now the last one in solidity, a private function can be called from another smart contract. Now what do we remember? So we have things like internal and private. But if you remember, private means no one other than this con. This contract can call this function, so in this sense, it's wrong. So first one is correct. Second one is wrong because not necessarily every language is still incomplete. Yes, the state may change, and this one is not correct, because private functions cannot be called from another one. What can be done is if it's a public one. You can call that if it's an external one. You can call that, uh, if it is an internal one. If it's an extended contract, yes, you can call them in this section. We are gonna talk about whether smart contracts have any relationships to legal contracts. If so, what kind of things may be, uh, possible Now? What do you think about this? So is a vending machine. That may be, let's say, sitting on a hallway as contract. What do you think? So there are different views on this, and it depends on who you ask. Answer. Pretty much so. Some some people will say yes, it's a contract in the sense there is an obligation. If I pay, I should I should get one of these drink bottles or whatever the bottle that I ask, Um, when on the other hand, like some people may say, Nope, it's not really a contract. Only thing is, contract get established if you actually use the machine. Um, on the other hand, it'll be interesting to see how a lawyer would look at this. They may come up with various arguments to say it's not written anywhere, and and things like that or for us, we we can essentially say we don't know because we are not lawyers. Um, and even lawyers would may, May may even say, I don't know, because I don't see a contract written anywhere, But probably there is AAA contract. Let's say if if you see a vending machine in in, let's say there's probably some sort of an agreement between the university and the machine provider, at least to put that machine there. But there's definitely not a written contract between you and and the machine in the sense that about that obligation to give you a drink bottle. So whether you can take the company to court, I don't know. It will be an interesting question, but more importantly, so we We credit Ethereum for having a platform to have smart contracts. But this happened in 2015, But as early as 1997 Nick Sabo talked about this idea of smart contract. So what he said is this is part of an extraction of the link that is below which I will highly recommend you to go and read. It's a very interesting read so contractual closers can be embedded in hardware and software, and he used this vending machine as a good example of that. Now he then also go go and further discuss and say smart contracts can go beyond the vending machine in in proposing to embed contracts in all sort of properties that is valuable and and of of, more importantly, in digital means. So one of the examples that he discussed in in the link that is below here is like, Let's say you, uh, get a car on credit. So you you have a mortgage. I mean, we have a loan from the bank to get that. So as the creditor, what sort of access that the bank has? Let's say if you miss three months of payment, can the bank essentially lock you from getting into the car? Of course, you don't want to lock the car while you're driving on a highway, but only and let's say when it is parked in a safe place. Um, so he actually talked about some of these ideas. So it it's It's something that happened a little bit earlier and now has come into, uh, practise. This is how the I used to stand and define smart contract so they define it as the computer programme stored on a disputed ledger system, where in the outcome of execution of the programme is recorded on the ledger itself. So this is where you you record the the the Ledger state, Uh, depending on the the changes to the state, depending on the transactions that you execute. But I also ISO also has a note attached to this one where it says a smart contract can represent terms in contract in law. So essentially, whatever accepted in as contractual law, maybe, uh, create a where you can create a legally enforceable obligation under the legislation of applicable jurisdiction. So what this essentially says is there could be a legal obligation to perform something based on whatever that is codified on a smart contract. Only thing is, it depends on which country regulation we are talking about. So at least today, not many countries would consider a smart contract to be, uh, a legal contract. But of course, it may consider it as a part of a contract. Countries. Look now, Laura Lessig had this, uh, proposed. This idea of code is low. So what he said is like code requires choices about values, because if you realise today, large language models and GP T is redefining everything that we know about what the machines can do. So it is, of course, affecting our life. It is going, it's telling us that it's gonna rain whether you should take your umbrella. But those are like the things that Alexa and the city was good at doing. But now this whole story has changed, and and it is pretty much de designing, like when, when, like when the train should run and and everything. So there are a lot of implications about, uh, in our day to day life and and even, like, let's say what you see on Facebook, you may already realise, or any other platform that we use today like that just depends on what you, uh, look, start looking at. Um so because of that, he said, because of those implications, cost should be governed like low. So we need, uh, But on the other hand, he said that doesn't mean that the government should be managing or or being the central Party and enforcing everything. And he he promoted this idea of societal governance for values and the rules. How we manage software. Now, the thing is, some people take this, uh, with a different twist of what we call the crypto anarchist, uh, slogan or the view where they think this means the power of code can take over from the law. So essentially you don't need garments. You have a Blockchain and everything is codified into smart contracts and everything should work. Fine. Uh, well, that doesn't really work that way. And we have enough examples that that that approach is not working. So the idea is OK, you can replace the low by using software code. But the interesting thing is, uh, what should the smart contract do? Of course, it is what we need. But But when you ended up writing a programme, you will realise there are certain behaviours that you did not even anticipate that the programme would have so usually these are bugs. But on the other hand, people may figure out interesting ways of executing your let's say functions in your smart contracts. If you execute them in a particular order, you may get a behaviour that nobody really thought of initially at least so whether it's about what you said it should be doing, whether what he's actually doing is ultimately what matter So court will tell the machine to do certain things, and that's the result you are going to see at the end. But so so going back to this idea. What this really says is court can't really take over from the law, but it should be governed by the law. That is at least what the, um Lawrence Ele was really trying to say. Though people interpret this in a different way today. Now, one of the best examples of code going wrong is this the decentralised autonomous organisation Do da stands for that. Um So what they were doing is they were essentially a venture funding entity, uh, deployed on Ethereum as a smart contract. So they were able to raise 100 and 50 million within the first month or so. But there was a bug that ended up leaking about $50 million worth of ether. Uh, this was somewhere in 2017, so that was quite a lot of money at that time. Even then Now, in in this in I mean, what I say is the size of Ethereum and and the value of it and all of that now. So what? This is what even the code said where in in their documentation, they said nothing in this explanation. So this was off the Blockchain this is not on chain, but the documentation says nothing in this explanation of terms or in any other documentation or communication may modify or add any additional obligations or guarantees rather than whatever deployed code the solidity code deployed on Ethereum at that time. So here, essentially what this says is this is like the specification is the code. Um, so they're saying, like, whatever code is gonna do is whatever it is. But the issue was because this is 2017 early days of Ethereum loss of 50 million was a big problem. So in that sense, a lot of people came together and they decided, OK, we should change the protocol rules where this 50 million should be given back to whoever that lost it. So the the the so so source code was updated and minors start running the new code and majority of minors decide to run the new code. And because of that, that 50 million that was lost or actually there was some part is still lost, but most of it was recovered. Um, that that kind of reflect this LASIK laws on LASIK view that code should be governed based on societal needs and and values. Whereas the miners who did not agree to this change they just continue to run the whole code and that that is where the Ethereum Network was split into two. What is called Ethereum today and and Ethereum Classic. So the value of Ethereum classic um Cryptocurrency is about Hun 1/100 of what? Uh, Ethereum is today. So this kind of indicate a lot of people will go with the societal value rather than the anarchy view of not code is everything. You should not change that code. Um, so about this idea of smart legal contracts and and definitely smart contracts and help you operationalize certain aspects of a legal contract. So let's say if the conditions are right, you would pay someone so you can have an insurance contract deployed on a Blockchain. If you get a notification saying in this particular area this particular time, there was a severe hail event, So because of that, all the farmers in that area should be compensated. So you you disperse some money to them, of course. Typically in some sort of a digital form. Um, let's say it could even be Cryptocurrency now, so The interesting question is, can some smart contracts also be legal contracts? It depends like the ISO. No, it depends on which jurisdiction you are. You're talking about, uh, well, whether this would happen globally or not. But probably it's quite likely that some contract be closes in a legal contract. So maybe you may write a legal contract saying this part of the behaviour is defined in in this smart, smart contract. Now again, there are interesting things here. Now, what is what is that part of that contract? Is it the programme, the byte code? Whatever, actually is running on ethereum, Um, so or even the specification. So if you remember, like in the DAO attack, the specification says, whatever said in the specification is not what matter. Whatever set in that code should be what matter. But the thing is, not everyone would understand the smart contract code. And definitely don't expect the judge to understand that now. If if there is a dispute, whether what? Who who's uh whose interpretation matter? Probably Judge is not going to interpret your solidity code. They will probably get an accepted, let's say, domain expert to come and look at the code and at least give their view on it. I have been mentioning about tokens for a while without really defining them. So in the next couple of slides, let's discuss what tokens are and how do how are they a little bit different from There are three examples of tokens. So these are very simple paper based token that says, Admit someone to a movie or maybe a park or something like that. And these are poker chips. We will use them in a casino. And this one is an old fashioned airline ticket that is usually attached to a specific name and may even indicate the passport number. So what each of these represent is some sort of a right. So this gives you a right to admit to the movie. So this give you right to. In a sense, you can spend this when you gamble, and this gives you right to board on a plane like that. So at a very high level, we can define tokens as acid that can be whole and you not to be copied. Now, of course, copying something like this is not very hard, but the thing is, you are. You're not really gonna gain much by doing that, because movie tickets are generally not very expensive. Of course, you may be inclined to, uh, copy a poker chip, but generally, copying them is harder compared to this paper token. And so there could also be some constraints attached to this. Like, Say, you can use it once, so admin you. You can go into this movie this particularly at this particular time, that's it. And sometimes you can transfer something like a poker chip can be transferred. Or you can even give them as a tip to a waitress or or uh, you can even sell them. Now, something like this. The airline ticket cannot be solved because this is bound to a particular individual. Now. Whoever issuing this token can can claim a lot of things and say, OK, it it represents certain authorization. So you have the authorization to get into the movie, uh, or a licence to use or do something so you you can get on board a plane and it could indicate ownership of a property. So if you happen to have a poker chip that indicates $100 that means you have ownership of that. You can take that to the casino, and you can redeem that for Hun $100 or anything close to that. They may probably have some fees, but but and of course, they may also ask for your driver's licence or passport or something like that to make sure who you are and they can keep track of that. So anyway, all of these represent some kind of a right or bunch of rights. Now here's a little bit more formal definition of a token, so it's a in in In the Blockchain context. It's a digital representation of an interest, which may be of value to whoever holding it and gives you the right to receive benefits or performance spec specified function So rights could be, Let's say you can give the poker chip and get dollars, or it may allow you because you have five tokens. When you vote on some sort of a decision, your vote is counted five times. Uh, like you, you get a weight of five like that, or sometimes they may not have any specified purpose, Say for an example. Most Cryptocurrencies are like that they don't cryptocurrencies are something of their own. They don't represent any other rights. Now with tokens. We also talk about this idea of tokenization. So this is essentially the process of issuing, uh, some some sort of a digital tokens again some something else so that something else could also be in the digital form. Remember this cute dog digital photo that's in digital form? But on the other hand, if you are trying to tokenize this aluminium I mentioned earlier and and in that case, your your digital token represents something physical now, tokenization. Generally when we talk about that, of course, happens on a Blockchain. Uh, but you can, of course, do tokenization on centralised systems as well and and those kind of solutions actually emerging. So why TOKENIZATION is useful because it allows you to have this automated behaviour in the sense you can use smart contracts to manage them. But remember, as I said, a smart contract must always be executed using a transaction. Uh, so you can you can have this distant mediation in the sense you don't necessarily need to rely on third parties. It enhances transparency because it's on a Blockchain, and then there are other advantages like, uh, finance advantages. So let's say, include liquidity. So that is what it really means is, let's say, if you have a if you have some sort of a property. If you issue 1000 tokens for that particular property, that means so whoever gonna buy one of those tokens don't need to have the same amount, like the full amount of money to buy that property. So they only own fractional ownership. So this also have other advantages. Like, let's say, if it is trading, you can have more efficient clearance and settlement in the sense this is where you settle the transaction and and some party get hold of the asset the other party get usually hold of the payment. Or it could be, Let's say you are trying to so Bitcoin and Ethereum so so that in that case, one party gets the Bitcoin the other party gets the it, uh, the ether. Now here's a comparison between cryptocurrencies and tokens to to understand that how they are slightly different from each other. But But the thing thing is, both of these sits on a, uh, in digital form and on some sort of a shared ledger. But some of the differences is in Cryptocurrency. They They are baked into the Blockchain platform by the developer in the sense like how Bitcoins are managed, how they are minted and, uh, and who who gets get the ownership of those minted Bitcoins or ether that is well defined into the protocol. Whereas here, uh, anyone can create a token by deploying a smart contract and and they define how how the tokens are created. So we call them minting or how the tokens are destroyed. Uh, that's we call burning and and how they are, how they change hands. So you will see in one of the labs we will actually use a Create a token. So you will see like you, you can create your smart contract and you can create your own token. It's a very, very straightforward process. Uh, only thing is, you wanna do it on a public Blockchain, you need to pay the pay the transaction fee. Now, the accounting and validation rules are hard coded when it comes to cryptocurrencies. Uh, this is again This is what I just mentioned. Like how under what conditions can someone get Bitcoin or ether. That is usually when you build a new block and who has the ownership and things like that. Now, II, I miss talking about this one. So things like Bitcoin and ether they are called native currencies. So that is the currency that is used in the platform. And even the transaction fees are usually paid using the native currency. But of course, on Ethereum there are so many other tokens. So what are called stablecoins and and what I call ER C 20 tokens. Um, like, let's say we we talk about US DT, which is, uh, a US dollar representation as a token. So they're not native to the platform and and they are just managed through a smart contract. Now, in this case, uh, when it comes to tokens, all of these accounting and validation rules under what conditions you can create them, destroy them. What do they mean, all of that? Those are defined in a smart contract. Now, in this case, no, no single individual can issue, uh, let's say create Bitcoin or ether. Whereas in the smart contract who were writing, the smart contract can decide, uh, when new tokens are created and when they are destroyed. So, for example, theta is what we call a stable coin so theta the organisation behind theta defines how theta tokens are created and destroyed, and non fungible tokens are mable by the contract. Um, so generally, cryptocurrencies do not represent other rights. So that's why I say cryptocurrencies are a thing of their own, whereas usually other forms of tokens represent something like If you talk about Teta, one Teta token is equivalent to $1 and cryptocurrencies are usually on public. Blockchains tokens can be on both public and private Blockchains. Let's say, if you are using, um, something like hyper fabric to manage some assets like, let's say, um INO or copper or some critical metals and things like that. Of course you can create tokens, and you can trade tokens, but not necessarily on a public Blockchain of you can do that on a private Blockchain as well. Tokens can be broadly classified as fungible and non fungible tokens, so fungible tokens are fungible in the sense they are identical and they can be interchanged. Let's say if you have a $2 coin, and if I also have a $2 coin. My $2 coin is not different from your $2 coin. They have the same, uh, value. And on the other hand, let's say if you had a $10 note, you can ask someone to break that into, let's say, 5 $2 coins or, let's say, 2 $5 note so they they can be interchangeable and and one is not un. Uh, no, no, no. Single token is unique so they can be displayed. So generally with those kind of tokens we talk about how many you own now, something like Binance coin Teta, which is a stable coin that I just mentioned. US DT And and then also there's what is called a Perth Mint gold token that that represent the gold ownership. So they are fungible, uh uh, considered as fungible simply because it's just they can be interchange for one another, whereas non fungible tokens or NFTS, they are unique. So, for example, let's say, even if two of us have, uh, two apartments in the same building, your aspects and and how we let let's say whether it's looking at the city or or whether you don't have a view and and CLO let's say in which floor and all of that makes it unique, unique from let's say, my my apartment. So houses, artwork, patents and things like that. Everything is unique. Um, so in that that sense, like one, is different from the other one. So you cannot really interchange one for another because they always have some sort of a different in terms of values that people associate with them. And usually you also don't split. Uh, those non fungible tokens in the sense you're not gonna break the token into two pieces and and assign that. But this doesn't mean that shared ownership, let's say, like the like. Two people can own a property. You can, of course, have shared ownership. But that doesn't mean that one person owns the living room. The other person owns the bedroom. Now, with NFTS, we talk about which ones because some of the NFTS are extremely valuable. So, for example, a couple of years ago, this digital kitties called crypto kitties uh, one of the kitties, was sold for $1.3 million. So that's that's a lot of money in the sense how this works. This kitty has about 40 features. Like they say, the shape of the eye, the colour, the tail and all of those. They even have a bloodline. So you can, of course, breed kitties. So So, depending on these different properties, these kitties are considered very valuable and depends on people's interest. Now, broad ape is another one. And then this, uh, portrait where someone took a photo of the person that that person took a photo for, I think, 500 days or something like that that was sold for multimillion dollars. So so 11 token has a very different value for a another compared to another token. So that's that's the idea with non fungible in the sense you cannot give one thing and and get the other thing because they are always unique. And because of that, they have some sort of a differentiation in in value. Now, here's a very high level overview of of what is called ER C 20. So ER C comes from ethereum, um, improvement protocol. So that is E IP and and so ER C means that the request for comment. So someone put a comment Number 23 2. Sorry, comment. Number 20 Say OK, this is how you should define a fungible token. So it became a standard. And then there's something called ER C 721. That was the 721 so that you just give the number anyway, So we will talk about this in a lab, But before that, let me give a very quick overview. So what? This contract smart contract key track of is essentially a simple table. It has an account. So let's say a bunch of, uh uh Ethereum addresses and the balance of each address. So this this could be either a balance or it could be some other one. So let's say if you're talking about tether so this could be the titter token ownership. Now there are a bunch of functions that this smart contract would allow these users to call. So there is a transfer transfer from a prom temper. Now let's start with these two. mint and burn functions are used to create new tokens or destroy tokens. So someone says, like whoever the manager of this contract or whoever deploy usually will say, OK, create 1000 tokens and assign to this approve address So let's say the deploy would call So the first deploy this smart contract. Usually you define at least three things like what is the name of the token? And you usually have a three letter symbol like USDA UD like that. You can have a, uh a symbol like US. DT is one such example And and then, uh, the total supply, uh, and and the minter a few other things like that. But at least you will define these two. So what it says is, let's say someone like Alice, if you meant 1000 tokens, you can assign that, too, Uh, Alley. So in this example, this is a little bit different because you are also specifying a minter. So the deploy is not same as the Minter. So Minter's near address is given, so Minter can mean and burn and and then, when minted, it may. Let's say Minter designs that to war or Charlie or someone like that. And and of course, you can destroy tokens by burning them. In a sense, let's say, if you had someone had a balance of 500 if you are gonna burn 200 you will just update the balance to 300. Now transfer is the function that we use to transfer tokens from one user to another. Now, usually, when you do a transfer, you have to have a from address and a to address. But this function only has a two address and the value like how much you want to transfer simply because, depending where you can always figure out who is calling a smart contract function using message dot sender. So because of that, there's no need to specifically send the from address whoever signing this transaction digitally and sending that is the sender. But of course, you can allow a third party to transact on behalf of you, so that is where the transfer from function comes in. So in that case, you would say from this account to that account and how much. But in order to call this function, of course, you need to call this approved function beforehand. Well, let's say Bob allowed Charlie to spend Hun 100 tokens on behalf of Bob. So now, later, Charlie, could you go and use this one? So this is very useful in some of the smart contract trans transactions. Let's say you agree to sell something at a certain price, but someone may not be there to buy at that particular price. So let's say this third party is running what is called a decentralised exchange. When when someone is interested in in actually doing that transaction at that price, when they find that they can execute that on behalf of you rather than you always looking at, OK, who is having, uh, who wants to transact with me now? EC 721, which is the non fungible token standard in Ethereum. The that I would say the de facto standard has a similar set of functions with a little bit of differences in the sense. So, for example, if you look at minting, uh, a new, non fungible token, essentially two things you need a token ID, which is just a 256 bit unsigned value. So you have a unique ID that is 256 bits long and an address. Who is the owner? So there is a table inside this contract which essentially keep track of a token ID and an address. Now let's say if you wanna destroy that non fungible token, you use the burn function and just indicate which token you want to delete. In that case, that entry would be would disappear from this table. So there is. There's a transfer form. There is also like, uh, something called safe transfer form. This is a function with a little bit more added features to ensure your recipient can actually receive an ER C 20. So this is like a guard rail to prevent, like people get messed up by transferring tokens that to another address that they can never recover and things like, uh so so to avoid some of those kind of problems. And and we have the usual approval as well. And and there are other additional functions, like set approve for all. So if you if you go to github this particular page, you can download this to contract the latest version. Only thing is, you may see slightly different additional set of functions in addition to these basic functions, because they may do a few additional things as well. So what are oracles? Oracles are a piece of code or programme. Let's say that helps us to have this data flow between the real world and the Blockchain. So Blockchain is kind of isolated from the rest of the network because everything is recorded on the ledger and pretty good at dealing with digital assets, purely digital assets. But as soon as you want to connect this with real world things, then oracles becomes important. If you remember in in the first topic, Uh, I said, like value of the Blockchain is the difference. It can make our lives of chain. So how we can connect that to the real world Now there could be a situation like, Let's say, whatever happens on the Blockchain may depends on whatever happens in the real world, like the insurance example that I mentioned a couple of slides ago. So if you are, if you are going to pay, um, some insurance pay off, you need to know what was the weather. So someone like, let's say, Bureau of Meteorology Bomb Need to tell the smart contract. OK, this day at this time here, this was the weather. On the other hand, II, I talk about another example. If you remember that, let's say Alice wants to buy a bicycle from Bob. But maybe Alice is repaying using Bitcoin or ether. So in that case, you need to first make sure that ether transfer happens before Bob. Let's say, hit the bicycle. So what happens on chain have an impact open sequence on things that are happening, uh, of chain. So off chain actions depends on what happens on chain. So oracles are the component in in an architecture that enables this bidirectional link between the real world and the Blockchain. So they're usually run by third parties because you want the oracle to be independent. So whole idea of Blockchain was to prevent, um, the role of the third parties. But unfortunately, or we don't have a better solution than relying on oracles when we want to interact with the real world. So you need some trusted party helping you to establish this bidirectional information. Let's say data flow now. Oracles may have a non chaining component, an off chain component, and and again, you will S, uh, play with an oracle in the sense you will develop an oracle in one of the project, uh, one of the labs and you will you are quite likely to need one in your project too, as well, now being third parties, of course, they become a single point of failure and create a lot of others. Let's say security and trust and privacy concerns anyway. They are an extremely important component when you want to. Let's say link this on chain world with the off chain. Now here's a way of kind of classifying what's happening in this space now inbound in the sense this is about the information flow. So let's say here the information is flowing from off chain on to Blockchain. Something like, Let's say whether report is submitted to the to a smart contract, whereas outbound is whatever happening on Blockchain is being communicated to the outside world. Let's say Alice pay Bob using ether now being communicated to Charlie, who is waiting for that payment before sending the bicycle. Now again, this flow can happen in two ways. Push your pull If you have heard this in one of the classes or something that you do so generally, there are two ways that that things can happen or data can flow in in computer system. So that's where there's this idea of the push and the pull. So let's say if you talk about impound and a pool. So what this means is on chain component, which is essentially the Blockchain requests off chain stage from an off chain component. So let's say this insurance smart contract most who know whether they are. So let's say someone goes and tell the contract. I want my, uh I wanna submit an insurance claim because there was hail. Now the contract needs to make sure there was actually a hail event in that particular area so it can emit what is called a, uh, an event so that the off chain component can listen and respond. Now, what are events and things like that? We will discuss in in that that lab where we talk about oracles? Uh, whereas if it is a push in the sense of chain component by itself goes and tell the unchain component something has happened. So, for example, my, uh, bomb Bureau of Mythology, when there is a hall event, may directly go and tell the smart contract by sending a transaction, of course, that there is such an event in this particular area. Now, outbound data flow again can be a pull or a push in this case, the off the pool is off. Chain component retrieves on chain state from the on chain component. Now, How you can do this is essentially by looking at the ledger state. So or you can, let's say, invoke a view function to see how much balance is locked in and a contract. Uh, whereas the push is the the the the data flow in the other direction, in the sense when something happens on Blockchain and it just generates an event that the off chain component can listen to. So if you are talk about, let's say, publisher, subscriber or or some event based systems in in any of the classes or projects, this is pretty much what is happening. If not, don't worry, we will cover them in a lab. Now oracles can be classified into a couple of categories, so I'm gonna talk about the three most common ones that we would encounter. Or, let's say this these three classifications are enough to cover pretty much the design space of all the oracles at a high level. Now this oracle, what it's really doing is it is introducing some external state into a smart contract, so What happens is it essentially sends a transaction by signing that transaction using its private key. So Oracle injects the state into the Blockchain using a signed transaction. Now, how does the Blockchain validate? Whether it's the oracle that is actually sending this? It can validate the digital signature and the sender's address to make sure that the transaction is indeed coming from the Oracle. So that means, of course, the smart contracts need to know who is the oracle that I'm going to trust now. This creates a couple of interesting problems, like, of course, the oracle must be trusted. Third party, uh, and and of course, you need to configure the smart contract to trust that address. Now if this third party says anything like if it misbehaves and says something that it should not be saying, well, there's no way to validate that external state coming from the Oracle. And this also leads to what is called a single point of failure. In the sense, if the Oracle fails, there's nobody that will send this information onto the Blockchain. So having having a single party is a problem, so why not have multiple parties reporting the same event. So that's the idea of what is called this decentralised oracle. Now, in this case again, this can be implemented in few ways, but at a very, very simple level. Let's say if there are three oracles, each one will independently send a transaction to the Blockchain to report the incident. So let's say if you don't trust me, Bureau of Mythology, only there are a few other weather services uh, that can provide you with the information. So the idea is, you introduce the external state into the Blockchain using multiple or oracles. That usually means each of them signing a transaction and sending that to the, uh, smart contract. So in this case, smart contract can again go and check. OK, I have appointed these three oracles. Are these transactions coming from all of them now? Of course, you can have a situation. Some of these articles may be lying or or they may be failed. Uh, or they may be out of service at a given point, so you can have even a situation like you are going to have some M number of votes out of M. So let's say you have five articles as far as three of them report the same results, you consider that result as authoritative results. Now the interesting thing is, well, of course, you can have different oracles. But if those all those oracles derive on the rely on the same data, so So let's say you may use bomb. But if, let's say, National Weather Service or let's say the weather app on your smartphone, if all of them look at the same data source, they are actually not independent data sources. So that's that's something sometimes a little bit of a problem, because Blockchain doesn't really know whether they are coming from independent sources, so that can create problems. But of course, compared to the single oracle or the centralised oracle model, this enhances trust because you are no longer trusting and in one party. But now you have you have a collective and you are looking at, like some sort of a majority decision. So it also reduces the single point of failure because there's not a one place to fail but multiple of them, and all of them failing or majority of them failing is quite unlikely, and but the downside of this is everyone gonna send the transaction to the Blockchain. That means each transaction is going to cost some transaction fee. So overall cost of this solution is higher than the the centralised oracle because everyone need to sign and send. And the other thing is like each transaction takes some time to be included. Now, if you if it let's say you you have 100 and 95% of the chance that your smart can. The transaction will be included in 55 minutes. Now, if you have three transactions, that does not mean that all three will happen in five minutes. It may not necessarily need 15 minutes, but it's it's quite likely to be more than five. So because of that, the process can be slower and and until you reach some sort of a majority, you cannot take a decision on your smart contract. And, of course, there is a possibility. Let's say some of them may have other, uh, vested interest, and they may collude as well. Now we also have these oracles. Sometimes we just call them just again Oracle or reverse Oracle or pull based Oracle. So compared to the other previous two slides, in this one, the information flow is reversed so earlier we are talking about you have some real world thing happening and you are reporting that to the smart contract, whereas this one now listens to whatever happening on the Blockchain and go and tell that to the real world. So it's an off chain component that rely on the smart contract to check some sort of a condition and provide that information to the, uh, real world real world in a sense, maybe some sort of a computer application to a user like that. Now again, we can have the option of push or a pool, as we discussed earlier. Now, how you pull the data is essentially by calling a smart contract function, particularly something like a regular function of view function in solidity, or if it is a push in the sense you scrubs crib to what are call events that are generated on the, uh, Blockchain. So, for example, you can subscribe to a payment event. So whenever someone pay, let's say, do a transfer on an ER C 20 contract or even ER C 721 contract. You can get a notification, so this is like push notifications on your mobile devices. Same idea and but something interesting that could happen on Blockchains that that have what we call the Nakamoto consensus. If you remember Nakamoto, consensus means your transaction is not final as soon as that is included in a block. So you have to wait for a certain number of confirmation blocks. No in in that sort of a se setting. So let's say just because you get get got an event. Saying your transaction got included in a block does not mean it is finalised. So after a while, it may not even be in that that particular transaction and the corresponding block may not even be on the longest chain. So be because of that. This can lead to problems in Blockchains, where the finality is probabilistic so essentially like, let's say, Bitcoin and Ethereum that that's a problem. But as we discussed like hyper fabric, as soon as the transaction is written into one of those peers, we consider them to be fine. OK, so here's the last slide and a couple of questions to think about. I'll give maybe a few seconds, Um, or if not just post the video and and think about it before we discuss each of these answers.

SPEAKER 0
OK, so let's talk about maybe the first one.

SPEAKER 1
Not all smart contracts belongs to AD app. So decentralised applications or D apps are applications that you run where where are their business logic uses a Blockchain. And of course, Blockchain may also be used to usually used to store the data as well. But but not not not necessarily every smart contract need to have AD app. So, for example, your project one you don't have AD app, but you have a smart contract. So while D apps use smart contracts, but not necessarily every smart contract belongs to AD app. So in that sense, this is the statement is true. So not everything is, uh or not every smart contract is, uh, uh, the app. Then an asset can only be tokenized as an NFT. So we said tokens can be broadly classified as fungible and non fungible, So that, of course, means this is wrong. Oh, then the third one smart contracts can operationalize legal contracts. Now, we said it's not very clear whether smart contracts will be considered as legal contracts definitely not today, but things are changing. But at least we can agree. They can help operationalize part of a legal contract like, let's say, do an insurance payment when the weather conditions are adverse. So this is true Last one, A a centralised oracle enhances trust, availability and cost. Now, if you compare centralised versus decentralised, which one actually enhances trust? So we consider the multi node or multi oracle situation to be more trustable than relying on a S single oracle. So centralised oracles are not as trusted a or available in the sense if that that only Central Oracle fails, you don't get data. Whereas if you had five and you are looking for any three of them you to to submit the correct results then, of course, a decentralised oracle has much higher availability. And interesting thing is enhances cost. So a centralised oracle, actually, yes, it is better in terms of cost, but not in terms of the other two. So, as a statement, this statement is not correct simply because of the first two parts are not correct. A decentralised one is more trustworthy and highly available. But of course it has a higher cost as well. So that's this is the last slide. And if I if I summarise smart contracts are essentially some piece of code that runs on a Blockchain because of that, you you you can have shared behaviours because everyone see what that code is supposed to do, and everyone can interact with that code. So this is simply because immutable property of Blockchains transparency of Blockchains and we also talk about what is called is deterministic behaviour. If you always give the same input, you always get the same output. Given that the L state remains the same. Of course, if the Ledger State changes, you may get slightly different outputs. Then we talk about the relationship between smart contracts and legal contracts like this third statement here, So they are related. But they're not quite the same thing, at least not today. Maybe it will change eventually and what else we talk about. Then we also talk about this idea of tokens. So how tokens differ from cryptocurrencies, or what I call the Big cryptocurrencies or the native Cryptocurrencies is that tokens can be issued by anyone just by deploying a smart contract and then finally we talk about oracles as a way of flowing data in and out of a Blockchain. So both the tokens and the oracles will be discussed in, uh, one of the upcoming labs. So we can we can stop here. Thank you.
