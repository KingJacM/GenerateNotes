SPEAKER 0
Alright. Um, OK, so we lost a few. Maybe they didn't like the food. I don't know. Um, maybe they they lost. Maybe they were in Keith Burroughs. Hopefully, they'll maybe they'll turn up. Um, well done to the rest of you. Thanks. Um, I would like to say thanks, uh, to people that, um, sent me emails over the last I. I do like feedback. Um, so a lot of a lot of, um, interesting things. Um, a couple of people expressed a little bit of concerns about the mathematics. Um, the the reason why I had the slide saying that, uh, math 1081 is neither necessary nor sufficient. Um, the math is the math is not not essential. Essentially, where I say the the idea, the maths, the maths is basically the motivation. The the reason why we're doing the things, um, you can sometimes if if you don't follow the maths. Um, if you if you find you're a little bit weaker in the maths, it's it's ok to just sort of, like, take things as granted. Um, basically, I'm just gonna be using mathematics to explain why we're making decisions that we're making um, and that's by and large, by and large, the thing you don't need to know what a mono is. You don't need to know what a category of Endo functors is. Um, we will talk about what a monad is later on. I mean, clearly it's a Monod in the category of Endo functors. But, um, you don't need to know any of those words. I barely know any of them myself. Um, so don't don't stress so much about the mathematics. Um, apologies. I still, um I'm still trying to get the, uh, the quiz and, um, and and exercises set up. Um, they will be available later today. Uh, I've just got to sort of translate into into web C MS. Um, that's the other thing. Uh, the course website will be web C MS. It will be completely based around Web C MS. Um and that's just in the interest of of going forward and maintainability. And, um so on, um so please Oh, yeah. Uh, if you have any questions, post them to, uh, the Ed forum or or, um, emails and I. I do pay attention and also, uh, post them to chat. Um during the during the lecture? Um, some, I guess. Food back. Um, based on the what was eaten and what wasn't eaten. Apparently, nobody likes salt and vinegar chips. Um, if you do like them, then basically, you've got free rein. But I threw, uh, basically, I had I think I had all packets of salt and vinegar crisps, uh, chips left over. So, um, I'm trying to I I'm trying to experiment. To find out what? Uh what set of chips, Um, makes you most happy. So keep coming in. Keep eating. Um, and I did notice that all the fruit fruit got eaten, so I'll continue bring bringing that, um when we have a bin today. Uh, right. So carrying on from where we got to last time we were talking about, we were just sort of walking through some basics of high school. Um, and today we're gonna just I'm just gonna continue that just sort of like, um, fleshing out a little bit of high school so you can actually sit down and do something, and that's what we're gonna do with the second half of the lecture. We're gonna sit down and do something. Um this is all sort of like pl, uh, padded out in the, um, in the lecture slides. What? We're what? We're going to be where we're going. Um and so this is this is the Friday lecture. Um, So next week, uh, Ruff will be taking the Friday lectures, um, or from next week, where Ruff will be taking the Friday lectures. And it'll be more, um, walking through some of some of the practical exercises which will be available, um, on the course website. Um and so the best. Of course, the best way to get involved with with high school is to sit down and and play around with it. So let's let's walk through some, uh, some some more basics. Just a reminder of where we got to last time we were talking about, um Well, sort of like basic basic has syntax. We'll start with, um, and the the almost. Because it's, you know, the it's in. The clue is in the name paskell is functional programming. And so high school is really all about all about functions. Um and so that's our basic building block for a lot of a lot of things. And so What What exactly is a function? Well, how do we How do we write that? Our functions we give, um, a type definition. Uh, so we specify. Um what, uh, the behaviour of the function. And then we actually, um, write out the the, uh, the function behaviour. Like so, um, the type definition should point out that, um, Haskell is actually quite clever. Um, it can often work out the type definition for you. So it's not. It's not actually, um, essential to to supply the type definition, but it's a good idea. It's good. Good in practise. Why? Why do we prefer typescript over JavaScript? Right, Because type typescript has strong typing. Hasel has strong typing as well, but it will work out the type for you. Um, but often, often it's sort of like it's it's useful. Um, certainly, when planning, uh, planning things to to write, write out the type definitions, um, in the first place. Alright, Um, a function in high school. So a function that functions, um, in high school, they have the type. They always have the type. No, that's true. Um, of whom a goes to B. Alright. Um, now that a goes to B can be can can be complicated here. Right. So in this particular case, my square function has type in goes to in. But we can have other more complicated functions. For instance, B itself could be a function type. And so we could have, um but A and B can be compli complicated. Right? EG we could have like, um, a function like or maybe a could be, like a type it goes to in, um, and B could be of type in it goes to into or something like this. Right? Um, and so we can have the this this this this the actual types themselves can be can be very, very messy. Um, but they're always the form. Just one thing. One input type goes to one output type. So functions only ever. Take one input and always produce one output. However, we can sort of work around that particularly we we started talking last time about how do we sort of, um, deal with functions that want to take, for instance, two inputs, like for instance, addition, uh, in addition, takes two numbers. Um, how do we deal with that? Well, basically, what we do is, um so, for addition for so for multiple multiple inputs, right. The idea is that we take we imagine addition as taking, uh, not not not as a function that takes two arguments and returns a single argument, but rather as a function that takes one argument and returns a function that will then take the second argument and return. Um, and the third. So, for instance, plus So I'm gonna find like, this. Um, we take an integer and return a function that takes another integer and then returns an integer so you sort of like you start at you. So, like, say, two plus three would be evaluated as sort of put put two into the function. Plus And that now gives you a new function, which just adds two to anything. You give it. And then when I give it three, then it can can evaluate to five. Uh, So, plus has this particular type. It takes an integer and then returns a function which gives an integer to an integer. And because this is a very common, um, common set up. Uh, the way, um, we we write in high school, we actually can drop this outermost parentheses here. And so we actually say, um, pluses of type in, goes to in, goes to in Right. So these are equivalent statements here? Um, when we write a SA a sort of chain of of arrows like this, we assume that the the arrows are are right. Associative if that's the bracketing is occurring from the right and this is this is a very different function. Should point out this is a very different function. Type to some other function that might have type in goes to in as to end What? So what sort of what What's what's the behaviour of that kind of function? What's taking his inputs? Yep. Exactly. So it's taking a function as input and then evaluates it or something like that. So, um, uh, one example might be, say, a number that takes a function that goes from integers to integers and evaluates it at five. Right. And so this is very different. Um, these are different types of functions. Um, so that's something sort of to to keep in mind. And thanks. That was really wasn't It was Oh. Oh, Well, see. Should have gone one road further back even more. Um right. Yes. So exactly, um, so in into in is a way of specifying functions that take multiple inputs. But then the way to think about them is that when we we plug in multiple inputs, we plug in one, and that creates a new function which can then accept another input. Right? And then So I've been talking about function types and we've had functions, and we are We take arguments and plug them in. Um, the the technical term is apply. We apply an argument, um, to applying arguments to functions, arguments function. So we've got a function F to apply an argument to it. We just stick it a space between it and then the the next. The first thing that comes across is the argument, so importantly, and we have something like FX Y. What's going on here? How do we actually interpret that? Well, when we're talking about function application function application, this is left associative, which means that we we take, um how we we interpret bracketing from the left. Right, So this is actually should be read as F applied to X. So you do that and then you apply the end result to Y, right? And so this is how we can sort of, like, write now Imagine if F is a function that takes two arguments, we can sort of like plonk. The two arguments one after the other, right? And so when? So the idea is that basically what's happening is X is getting fed into F, and that's gonna create a new function which we call G say, and then we feed Y into G. Right? And so, in particular, this is going to be different to say something like, um FX Y, Right. What's going on here? Anyone? Yep. Um, taking a couple. Great thought. N. Nice idea. Not quite. I mean, I've told you I've Yep, It's taking two arguments. Um, not quite again. Good thought. Yep. Yes. Bingo. It's playing. So for those that in here it's applying. It's taking the Y and throwing it into the function X. Right? So it's like saying OK, X is a function that's gonna take an input. That input is gonna be Y. I'm gonna throw that into Y and then take that output and plug that into F. That's OK. Sit closer. Next time. Um, sorry. Name, Max. Thanks, Max. Were you the one that sent me an email? No. We've got no different Max. There's two maxes in this class at least, um, which is good. And there's lots of people who begin with a, um but And Brodie's the only one I can remember. And he doesn't begin with a So, uh, and Lucas, um, because I got Luca's name wrong. Um, right. Yes. So this is this is applying Y to X and then taking that output and throwing it into F. So, for instance, if I tried to do something really silly like, um uh, sorry if I had a function A I tried to do add one and two like this. It's gonna throw ass, Gonna throw a AAA fit because one's not a function. Right? So I can't I don't I don't add multiple functions. I don't. I'll add multiple variables like this. What I do is Well, let's comment this out. Sorry. Um, it's not the same as what I'm gonna do. What I should do is technically, um, if add is a function that takes two variables, go add 12, which is the same as, um take a put one into it and then put two into that end result. So that's how we deal with with multiple inputs. And, um and this sort of, like highlights the key. The key fact that I was talking about, um earlier functions are first class citizens. Functions are things that you can return just like integers. Just like booleans. Um, just like characters. Um, so on that note, we have we have bullions so true is true. Is a bullion false? Is a bullion notice the capital letters? Um right. Um and we can do various things we can, uh, true and false is is And in fix? No, and not in fix. And it's prefixed. No. What do I want to do here? Mhm. Yeah, that's a good point. What is? The topic is an list. OK, this is one or one and and Yeah, OK, so yeah, right. Yes. So and and so Yeah. So this is the thing. So what was going on? Right. I can ask what and is and takes a list of booleans or it actually takes a foldable, but, um takes a sequence of of bullions and ans them all together, right, whereas and And is the is the pair wise one. It's a type and end and just complain because I want the type of and and right Um and this is where I remember what I said. The parentheses will turn an infix operation into a into a prefix operation, and bacti will turn a a prefix into a into a infix so I can say, like, 10 Div three like so, um so div is a function that is normally defined as prefix is. You would say div 10 3 like this, but it's it's often often common to to wanna wanna stick it in between, right? So that's how we, um, can input multiple parameters into into a function. How do we How might we output multiple parameters? Um, so those that know Well, how do how do you do that in normal other in other programming languages, like, maybe I want a function that returns like three outputs, like maybe the length of the list as well as the list as well as you know, the date of birth of the person pulling the pulling the the function? Yep. Yep, Exactly. You turn a composite data type like a structure, a tuple or if you're in Java, an object. Or if you're in Python, you can Yeah, a tuple. Um And so So that's exactly what we do in in high school as well. Alright, we have a composite data structure, and the composite data ty type we we talk about in high school is the idea of a pair. So pairs are are, um are like python topples, right? They they are, um they are. You can't You can't extend them or anything. Um, so you you can have so you can compare. Take the pair. 12. I can take the pair one. False. Right. Um, these are all composite data type guys. Mm. Hang on. Not forgotten, Simon. I didn't did I. I didn't ask you yesterday. No. OK, thanks, Simon. Chocolate. You're nice and close. I can probably hit three people behind you. Oh, OK. Bad throw. It's alright. Um, yes. So this is how you can return multiple things so it can take a function and return a pair or a tuple or or a triple? Um, so we also have triples. Um, so, like, 1231 false and true. Um, I can also throw in. Uh well, let's say I can throw in functions into these things as well, right? So you can Oh, I can't. I kind of do that. Uh, it doesn't Doesn't know how to show Div. That's why. But you can You can do things. Um, you can You can, you know, return functions and you can turn functions within, um, pairs and and so on and so forth. So this is that's how you sort of get around that, um so multiple, uh, multiple multiple, multiple return values. Um, you can do in, uh, pairs or triples or just general topples. Um, that's one way to do it. Not necessarily the most elegant, um, on that mind on on. But on that note, couldn't we just pass in a pair as, like, the single input into a function? Could we just do something like that? And so it sort of like it said, Define my ad. Alright, so just let me show you. So the type of say 12, right. Um ooh. Well, type of 12 is a pair of of things. So I could say in my ad I take a pair of inks and it returns an inch. Alright. And what am I gonna do? I'm gonna say my ad and you give it the pair XY. And that's just gonna return. X plus Y. So could I. I could do something like that, right? Um yep. No hassles. Not complaining about something like that. And so, yes, I can, um can sort of almost recover. Oops. Um, sort of normal programming. Normal programming quote. Um, we don't like to do that because we're we're functional programmers. Now, what we like to do is we like to have this idea. So the the disadvantage or can anyone spot a disadvantage to doing it? That, as opposed to doing something like that? True. Sorry. No, that colour is one right? As opposed to having, like, a function that takes sort of, like, just one thing. Why, why would I Why would I want to do functions that take one thing? Sorry. F functions that take one thing and then produce another function versus taking pairs. Yep. Ready? Limit your options. In what way?

SPEAKER 1
Probably more stuff than what your input is. You write?

SPEAKER 0
Yeah.

SPEAKER 1
So with this version of my A You have to have a two size input, I guess when you can, like one.

SPEAKER 0
So what do you mean? Like so Maybe there's something like that.

SPEAKER 1
Um, with the previous version, we couldn't assign like Y to be. Plus, the best wasn't.

SPEAKER 0
Yeah. Yeah, that is exactly it. So you can do this This, um, partial, um, partial evaluation, if you like. Right. So, like, plus one, it's just a happy little function that I could call, Um, my funk. I don't know, Right. And I can sit there, and it can. It can do. And so I've got this, like, extra ability is, like, sort of sitting around like going this. This thing that's primed and ready to go. Is that kind of what you're getting at with, like, limited or or you you want You want to claim the credit or you No, it's OK. Um, no, you already gave me one. yes. Exactly. So you can the advantage of sort of like having this partial, um, th this one function, um, to 11. Input to one output is that you can have these partial, um, partial applications. Um, building up. Um But this, incidentally, is sort of what's known as currying. It's named after Haskell Curry. Um, who, which is the person who Haskell is named after? Um And so currying is the idea of turning a a, um, a multiple input function into a single, uh uh, sort of chain of single input functions and decrying uncurling Sorry is the is the opposite, right? So that's, um so that's sort of, uh, sort of recapping on on functions. Um, let's talk a little bit about characters. So we saw last time. So some inbuilt types, um, in high school, let's say inbuilt Haskell itself. Um mm. You can actually sort of, like, almost get vanilla Haskell, like, literally has nothing to find. Um, most things when you start up Haskell, they load what's known as the prelude. Um, and the prelude defines a lot of useful things like booleans and so on and so forth. You can actually go off and read the prelude and, like, sort of see, you know, um, things like true and false being defined addition, um, and numbers and so on and so forth. Um, but anyway, um uh, and that's that's what I did one time, it was like, um But there's actually much, much easier ways to, uh, dealing with that now. So, yeah, back in 1998 that's what That's what we had to do. But now, um, we do that. OK? Question. Couldn't you still do that with topples? Um, like, right in my funk X equals my ad X one. Yes, you could, uh, you could do something like that as well. Um, so he ba basically, um, filling in the the my ad. But, um uh uh, Yes, yes, you could do it that way around. Um, that's kind of backwards thinking, though it sort of like reverse reverse engineering. Um, so it is possible to do it that way around. Thanks, uh, for the question. Right. Anyway, cha, uh, characters, um, And strings. So strings quote, quote in double quotes. And as I showed last time, you can do a number of operations on strings. Um, you can concatenate two strings, right? Like so you can take You can take the first three, first 12 characters of a string you can take the first zero characters of a string. You end up with the empty string like, So you can drop things as well and drop the first two characters. Oops, as long as you fill in any quotes. So, um, but these take and drop. Um, these are actually, um, not functions on strings, but rather they're functions on lists. And so what is a string? A string is actually just a list of characters. So sequence of characters, Um, in C, you might call it an array of characters, but in in Haskell, we call them lists. Lists of the sort of the sequence building block, just as in python. In fact, I think a lot of python decisions are based around, um, Haskell's design principles. So you have lists you have tuples. Um you have anonymous functions, which we'll get to, um, later today. Um, and so a list the way we define lists is with square brackets, just like in in python. Um, right. And so So 123 is a list of integers again. Ignore that bit. Uh um, So right. So how do we How do we describe the type of a list of integers we put square brackets around it, Right. So I might say that um, X is a type list of integers. Um oh, actually, no. Sorry, we didn't say X. We say Xs, um, very common thing. Something that's that seems unique to high school is really interesting. Um, when you talk about multiple things, they pluralize it put an S on the end of it. Makes a lot of sense when you when you read it like that. So whenever you see, um, people talking about lists, they're usually sort of like X's or Ys, Um, and sort of like it's kind of neat, so you can sort of see see an S on the end of it. So X is is a type in, um, and say X is equal to 123, right? Um and that should hopefully not complain. And until we ask, I can ask what Xs is and so I can do the same thing with Xs. Um, as I did before, I can, uh, take, uh, two from Xs That's gonna give me the first two items in the list I can drop, um, through from X's are gonna take. Give me the third item in the list. I can drop three things. What's that gonna give me empty list. What does the empty list look like? Oh, that's very nice and trivial. Great. Ok, I can concatenate two lists, right? So right, so concatenate smoosh them together. So that's probably not immediately obvious what's going on. Um, let's call that 456 just so you can see right concatenation is not commutative you The order matters obviously. So that's not not too not too problematic. And so um so we see lists here. What's a list of characters? Right. So maybe I can go Oops to a list of characters like so And Oh, look at that. A list of characters is a string Fantastic, right? Makes a lot of sense. Can I do? Can I mix my types in my list? Uh, nope. Right. So all your types, if you have a list all your types have to be the same. They all have to match so you can have a list of characters. You can have a list of S. You can have a list of booleans, right? Right. But you can't have a combination of Boolean and integers, right? And um unlike C, true is true. One is one. True is a bully. And one is an entity you can't sort of mix and match them like that. Um, So, um, so we get that that there. And so, in order to go, um, if we want to return multiple things, possibly multiple types, we can't return them in a list. We have to return them in a tuple. Right? And the tuple is a very defined thing. So you can't You can't extend a tuple. Um, in the same way that you can extend lists like by doing concatenation. Um, alright. And so this sort of brings me, Let's sort of, um, just take a little step back and sort of like ask what exactly is a list? I mean, you can sort of see here it's a sequence, But let's let's talk about, um, how it's how it's sort of intuitively implemented. And it's implemented like a linked list. I say, like a linked list because, um, how many of you have seen the recursive definition of a linked list? Yep. OK, just one. Alright. So what is the link list to you? Anybody? Hm? Not you. You know, not not the recursive. What's a what's a No. What's your understanding of a link list the non recursive version, then maybe think about one EE elements connected by point is you say Yeah, yeah, so But, I mean, you know, that just gives me a graph, doesn't it? Maybe So what? What makes a link list? Not a graph. No cycle. They just give me a directed Ay, one day. Someone else wanna tell me what a link list is? Yep. OK, this sounds very recursive. Um, So what? What? So what a node and I with with the pointed to another note And which points to another node which points to another node. When does it end? When the pointer is null. So one pointer might point to null, but then everyone else points to someone else, right? OK, that's that's That's the general. That's how how you're taught, um, linked lists. It's It's perfectly fine. Um, here's another interpretation. So OK, so you can imagine, um, linked lists are like like like a stack of papers, right? Here's your first node and it points to the second node, which points the third, not a stack of papers where every page points to the next page in the pile Yep. Now, here's another way of looking at this pile of papers, right? I can describe this pile of papers with two definitions. The pile of papers is either empty or it's a piece of paper sitting on top of a smaller pile of papers. Yep. So that's a recursive definition, because I've used right. So there's my base case, and then my recursive case is a piece of paper on top of a smaller, um, smaller pile of papers. Right? So why what's the advantage of a recursive definition? Get ready. Simplicity. Why is it is it more simple to say, Um OK, so the recursive definition of a linked list would be an empty list or a node, which points to a smaller list. The same idea, right? Is that so? Is that more simple than just a sequence of nodes pointing one after the other after to the end? Yeah. So why? But why do we teach? Why? Why do we teach the the node chain rather than the recursive definition? This is This is now philos philosophical. Yeah, very easy to verify. Using induction. Yeah, I like that idea. Right. So But I mean, we don't use induction early on. So why do so? Yeah, the recursive definition. Um, easier to verify using induction. OK, so what is induction? Uh hm. OK, we're getting a little bit circular here. Well, this is kind of nice, right? Um, I've given a recursive definition of a linked list. How? What do I mean by recursive definition? I mean that my definition of the complex object, right? I think list is defined in terms of simpler objects. Either the empty list or a smaller list, right? And so this notion of recursive definitions, um, absolutely. We use it all the time in computer science. So the question is, why? So it's simpler, maybe. Why don't we teach it? First off, um, we use induction. OK, but that sort of like seems like a a benefit at the end, right? It's like going Yeah, but you know why? Why should I give recursive definitions of of data types rather than like, um, sort of like structural definitions? If you like. Yep. You can think of it as a function in what way? Yeah, I, I like that idea. Um, when you learned recursion OK, you've learned recursion, right? What? You learned recursive programming. What was the what was the first example you learned? Uh, example of recursive programming? Fibonacci. Fibonacci, didn't it? Did you not learn factorial first? It's like factorials or right factorial. So the factorial function. Um, Now, this is where I'm gonna go. Do do, do I say on both so it gets recorded. So II I use for whiteboard purposes. Um, I I will use my stack of papers and this is being very slow. No, no, we got some pages that zoomed in. No, this is how I normally lecture. By the way, I don't normally lecture with, um but yeah. So normally we we have, like, the the factorial function. Say, um And so you might say, in fact, takes an integer N And you say if N is equal to zero, return one else. Um, return N times Fact N minus one. Excuse my, my mixed. I'm just doing semi pseudo code here. Um, so you might do something like this, right? So how's the factorial function? Why is this a good definition of the factorial function? I'm defining the factorial function in terms of simpler objects. Right? Either it's the simplest object when N is equal to zero or I'm I'm using the simpler version factorial N minus one to define factorial of N. Right? So it's like using simple or defining complex behaviour. Um, in terms of simpler right? And so that's the whole point of recursion. Well, that's that's what's again, not one of the benefits. What's the point of recursion? Um, so what's the point? The point is that we can define arbitrarily complex things, right? There's no limit to how big a linked list is when we say a link list is either the empty list or one of of one page on top of a or 11 node pointing to a smaller list, right? We don't have to sort of say, and then and then and then and then and then and then it points to null right. But there's nothing wrong with that definition. It's just like an iterative definition. But the advantage of of of recursive definitions is that you've got this arbitrarily, arbitrarily large complexity, right? It's not infinite. There's a difference between arbitrarily large and infinite, right, But this is like saying OK, yeah, here. My factorial function is defined for any integer it doesn't bail it when when you get to the integer overflow, right? Because I can mathematically it all it does is they say, Well, I you know, I'm just gonna take the next one go down and eventually I'm gonna get down to the the base case, assuming I take positive integers to be clear here. Right? Um and so yeah. So recursion lets us define arbitrarily complex things. And, uh, so recursive data types lets us define arbitrarily complex objects like lists like link lists like the natural numbers. How do we define the natural? What's the easiest way to define the natural numbers? Zero is a natural number. And if N is a natural number, then N plus one is a natural number. Beautiful, Right? So it's like, OK, now I have to find all the natural numbers. You give me any natural number, I can tell you that it's a natural number by saying right. Well, 100 and 42 that's a natural number because 100 and 41 is That's the natural number because 100 and 40 is, and that's a natural number. 100 and 3090. So I might be there for a while, but I'll get there eventually because, uh, all the way down, I get down to the last case. Zero is a natural number and so therefore all my chain of reasoning works and so recursive data types that's just define arbitrarily complex objects. Recursive programming lets us work with these arbitrarily complex objects. So here, right this I'm programming on the integers. But I'm using the recursive nature of the integers. The integer is either zero or it's one more than a smaller integer of a smaller natural number. So literally this This definition is built around the definition of what a natural number is, right? And so all your If you look back at all your recursive programming what you what you're recurs on. So merge sort quick sort. All of those things are built around recursive definitions of the underlying structure. Right? Merge, sort you. A list can be defined as either a single item or two lists of roughly equal size smooshed together, right? And so then you your your merge sort it says right, I'll I'll Either I'm either in my base case or I'm in my recursive case and I recurs on my two smaller lists. Pom pom. Right? So if you go back and look at all your recursive programming, you say, Oh, yeah, Actually, all of those things are defined on the recursive nature of the thing that we're we're building on. And now we get to your point. Sorry. Name as is It's alright. It close enough, um, about proving things by induction, right? Induction is recursive proof, right? How do you prove What? So if you under those of you that have seen induction before, you might see something like you want to prove that the sum of, um from I equals one to N? Sorry. Let's do it. Let's do it. Not mathematically. The sum, um of all the numbers up from one up to N is equal to N times N plus 1/2. Right? You might want to prove that by induction, right? So if that if this is don't stress if this isn't ringing your bells, it's OK, right? We'll talk about induction later on in the course anyway, right? If you want to prove this by induction, how do you prove something by induction? Will you have your base case, Right. So you prove it's true for N equals zero. And you have your inductive case, right? And it says so. How does the inductive case work? You assume it's true for N equals K, and you show that it's true for, um uh, K plus one. Right. But that's the recursive nature of of natural numbers. You've either got your base case. N is equal to zero. Or you've got your recursive case. You're looking at one more than a smaller natural number. So induction proofs are just recursive proofs built around recursive data types, which defining recursive functions. There's just recursion everywhere. Um, and why do we like recursion? Well, because I I mean, Brodie says it's simple. It kind of is so natural numbers, right? Zero is a natural number. And if N is a natural number, I'm gonna use I'm gonna use set notation. Um, then N plus one is a natural number. And in two lines, I've described all natural numbers as

SPEAKER 1
true in the opposite direction.

SPEAKER 0
Sorry. Which one?

SPEAKER 1
Yep.

SPEAKER 0
It might seem like that way, but it so it depends on how you so we we cos what you tend to think of you say OK, um, the way I would evaluate Factorial is I start at a big number and I get a smaller number and a smaller number and a smaller number. Whereas the thing about induction, I prove it for a smaller number and build it up like that. So that's, um if you think about it that way.

SPEAKER 1
Yeah, and And that we go from basic.

SPEAKER 0
Yes, but, um yes. No, you're right. So in induction, you sort of like you prove the base case, and then you prove that the base case implies the next case, and that implies the next case. And that implies the next case. I want to argue that they're they're kind of the same still, because what I'm doing here, So, yes, If I were to evaluate Factorial, I would go down the chain. Right? Um, but the fact that factorial is defined is going up the chain because it's F. Factorial is defined for zero. And if factorial is defined for N minus one, then factorial is defined for N. Yep. So does that make sense? So it's like the definite sort of going up and the same thing with induction proof, right? Yes. My induction proof starts the base case and proves everything up. But flip it on its head and say OK, why is the why is it true for N equals 20? It's true for N equals 20 because I'm gonna prove it's true for N equals 19, OK, and how do I prove it's true? For N equals 19, I prove it's true for N equals 18 and use the use the step up and then so so and so forth. And so I descend down. So it's all just just a question about your viewpoint. So it's a good, good point. You're gonna a bit Chucky. Um, yeah. So in our in our natural, in our natural interaction with these things, we might think of recursive definitions as going down the chain and induction proofs going up the chain. But it it is. It is just a matter of viewpoint, right? Because it's like what I'm doing when I'm when I'm evaluating. Factorial is I'm just like I'm evaluating factorial at a particular point. It's like the same thing as saying Well is, is my statement. True for N equals 15. That's like I'm evaluating the truth at that point. So anyway, we will cover. We'll cover more on, um, induction and recursion later on. Um, I just wanted to go back and talk about what? What a linked list is or what A what a list is. Um, it can have school, uh, are of two kinds, right? They're either, um, the empty list. Um Or, um, they are the form node pointing to a smaller list. Right. So node pointing to a smaller list. So, uh, remember, X represents lists. And how do we actually construct this? Um, we actually use the the single colon operator. This is called cons for construction. It's a list construction. It's a, um you can see here. You can ask what the type of cons is, right. It tells you it takes an object of type A and a list of A's and gives me back a list of A's right. And so I would say so if I take the list 123, this is this is the same as this is syntactic. It's It's what we call syntactic sugar for one prepend to the list. 23, right. And that and of course, 23 is synthetic sugar four. so let's see, EG, um, 123 is just what we mean by one, prep depended or consed with the list. 23, Right. And then that's just, um, or 23 is just two cons with the list containing three. Alright, so I'm putting parentheses in here. Cons. If you ask if you actually ask about it, uh, please tell me and tells me that it's It's an INFIX. And it's right associative. Right? So that's what infix R means. So that means that if I go, um, So this thing here actually simplifies to, um so I can drop the brackets. Basically one cons with two cons with three, right? And then this, of course, is just There were 31 cons with two cons with. I'm putting spaces in here. You don't actually have to put spaces in here. Two cons with three cons with the empty list, right? And so that's how lists are built up. So you build build them up from from the from the left to the right. Um, you don't have a You don't have an app end. Basically, the cons is a is a pre Well, knock is Yeah. Knock. No. Oh, sorry. No, no. Knock. Um, sometimes some. Some versions have sno, which is sort of like the opposite idea, but, um, sort of cons written backwards. Um, yeah. So the things remember here that this is talking about list construction, and this is how we build up a list. So in particular, the thing on the left of the cons operator is an object. And the thing on the right is a list, right? And so you have your your base cases that it has to be the empty list. Um, And so what that means is like, if I want to find functions, and this sort of, like comes back to, um uh, question I had earlier on. So suppose I want to do something like, um, add up all the elements of a list. Right? So I want to sum sum all the elements of a list. Right. Um So how how would I do that? Normally. So if I If I take an in and I say, um, some and I'm gonna take a well, I'll just I'll just use, um I'll I'll use, like, you know, again a semi pseudo code or something like this. So imagine we've got a list. So we know what lists are. They're They're They're defined in this recursive way. Not not. Don't think of them as a raise. Think of them more as linked lists as I say. So how would you sum up the elements of a linked list? Um, well, you might do something like, um, if the length of, um this is is zero, then return zero. And I know I'm flipping between, um um, programming languages here. Um, python is just so much easier sometimes. Um, um, otherwise, what are you gonna do? What are you gonna if the if the length of the list isn't zero, then you've got a head and a tail. Right? So you're gonna say we you're gonna take take the head and add it to the sum of the tail of the list. Right? So that's a recursive way to build, to define, like, summing up the elements, um, of of a of a linked list, right? And so we can translate this very easily to sort of high school, um, in the following way. So sum. So what's the type of sum. It's gonna take a list of in, um, and return an in. And how am I gonna do that? Well, so the way I'm going to define some I want to define it recursively or I will define it. Recursively. Um, the way one way to do it in high school, um, and probably arguably the easiest way is to sort of break it up into into the two cases. So we don't have an if then sta uh, if then arrangement. Is that what I say? Right? Well, um, you talk about defining functions I want to define. What's the value of sum at the 0.0? Alright. Sorry. Not the 0.0. I take a list at the at the point of the empty list. Right. So what's the sum of the empty list gonna be? Well, that's just gonna be zero right now, so I've partially defined some as I've defined some for all empty lists, right? I haven't defined some. Well, there's only one empty list. Of course, I haven't defined some of, like 123 or anything like that. So how do I do that? Well, um, in that case, my input, I was gonna be in form. Well, II, I always put brackets in it. Sorry. Um, if it's not the empty list, it's going to be a an object con consed with a smaller list. And in this case, I just say Right. Um, take the object. X and Recursively call some on the smaller list. Right? And so there we go. There's some What about factorial? Factorial takes an end to an end. How would I define it? Um, factorial of zero is equal to one factorial of N or maybe even go with. I'll go with N. Um, that's equal to, um N Times factorial and minus one and minus one in brackets. Make sure we, um, apply the minus one to N before applying it to factorial. OK, what's going on here? What happens if I plug factorial of zero into this thing? Which one is it going to choose? Let's have a look. Not gonna like that. Why it is I do one brackets. Yeah, OK, I I knew I knew there was a reason I wanted little brackets in there.

SPEAKER 1
Uh, no, the brackets are correct, but you you the sun is already defined. You breath in.

SPEAKER 0
Uh hm. Oh, yeah, my son. Sorry. Uh, yes, thank you. Is Factorial no and plus one? Oh, yeah. Yeah. Thank you. Yes, correct. Right. So I can I can do my sum of Oh, sorry of 123, and I'll turn six. And the way it works. Well, how does it work? So my son of, say, 12 Let's go with that. Um, that's gonna be equal to my sum of one cons with the list containing two. And so I mean you Hopefully you're all very familiar with how recursive recursive things work. But the thing to remember with high school is that every time we see an equal sign, I can replace the left hand side with the right hand side. Right? And so this is why it's it's building. It's it's building on this. Um, it says this, it says, OK, my son. One cons with two. Ok, now I'm gonna replace the left hand side with the right hand side, and so they I get equality, and I say this is equal to one, plus my sum on two and so on and so forth. And it's equal to this is equal to this. And eventually it's gonna get down to a point where it can, um, simplify the the the arrangement. Alright, What's going on with factorial? So if I throw a factorial zero in there, it doesn't complain. So what's happening? Well, it's matching against It's matching against the Does it match the first? Or does it match the best factorial? Or when? When you pat a match, it does match the first. Yeah, right. So it matches the first one. So if I'd swap these two lines around, right, Um, it should throw up his see fit. Ah, yes, it Yeah, it already throws up his fit cos I've already defined factorial of zero by virtue of the fact that I've defined factorial of N have above. Right, Um, if I throw in, if I just turn this into N plus one is it might fix it, does it? You can't. You can't. You ok? Right. Fine. Sometimes I can never remember what you mean. Yeah. Anyway, so yeah, So, um so a pattern matches It says, Ok, a is factorial of zero defined. If it is, I'm gonna go with that. If not, I'm gonna find the the thing that matches the best matches. So I haven't defined it like like this, right? It's gonna load happily, right? It happily loads. Um, but if I try to work out what factorial of zero is in fact, if I try to work out what factorial of anything is, it's gonna go into an infinite loop. Yep. Max to define, like, just below the type of Ah, you can do it anywhere. Um, S. So you, um it's I mean, it's it's good practise to keep everything together. Um, but yeah. Um, because you don't even have to provide the type definition. So is is the main thing. Um, yeah. And and it reads and reads at top to bottom. Anyway, So this is this is, uh, one way to do to do that. Um, another way to define um, multiple multiple cases is with what we call, um, guard conditions. All right, um, and then for that, we use bar. Alright. And what it says is, OK, I'm gonna break it up. I'm gonna split. It's like, you know, another instance of case. Oh, sorry. Not that right. And so if N is equal to zero, then, um factorial N is equal to one. Otherwise, it's going to be fact, uh, N times factorial minus one. Right now. What? What it does what this does is it sort of goes through, you know, it takes the input N and and plugs it into the guards. And if the guard evaluates to true, then it goes to the first thing. And so it does. The first, um, evaluates the first time a guard is true. So what about this, otherwise or otherwise? This is actually syntactic sugar that I jumped out of kikki. Otherwise, it's just syntactic sugar for true, right? So that doesn't work. And that doesn't work. And if that doesn't work, then the very last line is just gonna be true, right? And so this is always going to evaluate to be true. And we're gonna, um, say OK, N times. Factorial of N minus one. Right. Um, so that's lists and recursion I want to do. Oh, Yep. I'll quickly talk about higher order. I mean, we kind of touched a little bit on higher order, but I wanted to talk about a particular kind of higher order function. Um, so higher order functions. So what do we mean by higher order functions? These are functions that take as inputs functions themselves. Right? And a really useful one is map. So let's look at the type of map. Right. Map is for, um for those of you that have done I, I think it's inbuilt in python as well, right? It takes a function that maps A's to BS. Um, a list of A's and a list of B's. Oh, I should should should point this out. Yeah. What are we What are we talking about here with the with the with the type. So So far, um, if you look at the type of square, Um, because I haven't loaded the function, he doesn't like that, Um, on the equal sign there. That's right. Yep. No murder related. Yeah. Oh, yeah. And that's the case.

SPEAKER 1
That make sense.

SPEAKER 0
That's Yeah. Sorry. Yeah, that's where the equal sign is. Sorry. Yep. Syntactic. This is This is why I'm getting raft to do these things. It's like I keep I keep forgetting the syntax, and it's No, it's not. Um, it's not in your interest to be told the wrong syntax. Um, right. Yes. Uh, so I can ask about the type of square right square says it's from in to in. But map has this sort of it's not. It's not talking about anything in particular. It's talking about A's and B's. These are what we call type variables so we can define Oh, no. So if we wanted to talk about apply twice, that's what I want to do. Um, yeah. No. Yeah, I'll I'll I'll I'll I'll come back. I'll come back to this. Uh, yeah. No, no. Yeah, yeah, no, I'll come back, I'll come back to it, right? Let's, let's let's let's take a break. Let's take a break and then I'll come back and and, um, deal with these things. Um, let's say five minutes. Grab some food, get some fresh air if you need to. Um and then I will, um, get on and do what I'm supposed to do in the in the right order. And, uh, I'm forgetting things. Thank you. For I was like, Yeah, so there's always always dread this cos like I. I always did pattern matching, um, definitions it like I the garden conditions. I never I never really took on board, and it's like Yeah, there, OK, because it isn't it. Uh oh, yeah. Maybe the ari in tax, isn't that? Yeah, that that is the case? Yeah. Yep. Uh, no, I don't think I'll touch on that just yet.

SPEAKER 1
Integers OK?

SPEAKER 0
Oh, sorry. Not Yeah. Natural numbers are like the issue here is like, you haven't defined one. Um, yeah. So this is That's a really good point. Excellent point. Excellent. Excellent point Kit Kat Point. You're right. I haven't defined one, and I haven't even defined addition. So actually, what we do technically is we say the successor of N is a natural number, and then so natural numbers are either So then So then so two is just syntax or successor of successor. Yeah. Yeah, so yeah. So So So that's we're doing So it's like going OK, so N plus one. So this is a really interesting question. So it's like So what? What is one? So we can define one to be the successor of zero. OK, but what about plus Ah OK, So how do I add two natural numbers? OK, now I've gotta go back and sort of say Ok, well, how do I add two natural numbers and And you can define this recursively and say like N plus zero. Well, that's just going to be +00, sorry. N even, um, an N plus successor of M. What's that gonna be? And plus successor?

SPEAKER 1
Um, successor of M plus M.

SPEAKER 0
Exactly. Yeah, right. And so now I've defined addition. Right. This is so so now I've defined addition. So now I can sort of, like say OK, um you know, so claim N plus one is equal to successor of N. Um, now that's a That's a statement. Now, because successor of N is like a construct and N plus one is talking about addition is like a question. This is actually you know, this is like a deep theorem, if you like. It seems really silly, but it is a deep theorem. Even better, like another claim, N plus M is equal to M plus N, right? And then, based on this definition, that's not at all obvious. That should be true, right? Yeah, exactly. So that's what you would do. You would use induction to prove that. Mhm. Yeah. Fix one of the variables, use induction and prove that. And it's like and it's like such a such a simple statement. It's like everyone takes this for granted. But I know it's like, Well, if you define addition like this, if you define national numbers like this, you can define addition like this and it's like Maybe it's not so obvious you do the same thing. You can do the same thing for associative distributed. Well, you need OK, we need to define multi application. How do we define modification? OK, N times zero. That's gonna be zero N times successor of M That's going to be what it's gonna be. It's going to be M plus N times M. And now we're gonna use my addition. Right? OK, now and again Another another statement N times M is equal to M times N. Is that true? Uh, that requires a proof. So, um no, I love I love talking about This is what I talk talk talk about in 9020, is I basically the literally the first question I asked. My student is six times four the same as four times six and it's like if you have to define everything from scratch like this, then six times four is something like this, and four times six is something like that. And it's not at all obvious that they should be the same. But anyway, But so when people say, 01 plus one is equal to two, right? That's really what you're saying is successor of zero plus successor of zero is equal to successor of successors. Suck of zero. And now that's a again something that's not obvious. But anyway, well, it's It's actually not too bad. It comes out quick pretty quickly on this line here, but let's see. But this is like it's fantastic and it's like, um um, this will come up again And so it's like, um but it's great that you're asking us right now. It's like I love talking about this, as evidenced by the fact that I talked about this for far too long. I think I I'm investing in future future me, So I haven't haven't looked ahead that far in the slide in the in the content yet where, where we talk about recursion, say invest, invest in the future or something. If you don't get it now, you'll get it next time. New messages, new messages no new messages. Oh, all right, all right. Let's start talking about doing doing functions using functions as inputs. Um, so building up higher order functions. So these are functions that use functions, um, as their input. Um, And what I'd like to do is I'd like to define a function that raises X to the power four. Right? So I've got a function that raises X the power too. I've got square. Um, any idea for a name? Like you've got square. You've got Cube. What's when you raise the power four Power four. OK, that sounds like a good one. Alright, So power four. Oh, right. So that's it's gonna take an inch, and it's gonna give me back an inch and right? How could I define it? Well, I could go. Power four is equal to X. Oh, sorry. Power four of X or even is equal to X times. X times. X times. X. Yep. I could go like that. Um and that would work perfectly fine. However, I've got this lovely function square defined in my lecture. One library. Um and maybe square is better at doing things than multiplication. Unlikely. But maybe you know. I don't know that. So I want to to find powerful in terms of square instead. So how might I do that? Yep. Square twice. So what do you mean, so squint. So so SS square. Now this. OK, so do I want the pres or not? Hey, you don't think it will work without the parentheses? Yeah, OK, good point. So if I didn't have the parenthesis, it would put the parentheses. Um, remember, it's left associative. It would try and apply square to square and it would go. Oh, no, square is not an integer, so it's gonna complain. So you're right. I do want the in the, um the parentheses. And I'm gonna give you a kit Kat in a second. Thank you. Yeah. Um yes. So name beginning. Anna. Anna. Here's right. OK, right. You were sitting OK, OK, fine. I just gotta I've gotta do a remapping every time we change Lecture Theatre, right? Yes, Anna. Thank you, Anna. Um, yes, we can do square of square of X like this. That's very nice. We like this as a functional programming style. Um, cos we're using functions. We're using functions as first uh, for citizens. This is good. Um Right. So that's one thing we could do. Um and, um but there's a sort of a general pattern going on here. Um, so I want a sort of general pattern. Um, Alright. I'm applying square twice, if you like. So I could define a function, so apply twice. Um, now what am I gonna do? So what? So what is apply twice apply twice is is gonna be a function that takes in a function. So in this case, I'm gonna plug it into square. So I take a function. So I take a thing of, like to in, um And then it's going to apply that function twice and give me give me a new function. In this case, say something like power four, right? And so that so. Power four, of course, is an in to in Right. So so apply twice takes in a function that takes ince to Ince and applies that function twice. So how do we define? Apply twice. Apply twice. Um, you give it a function and an argument and what I want to do, I want to basically I want to apply that function twice. F of F applied to X. Like so? Yep. That makes sense. So So, like, I'm I'm being a little bit more abstract. So I'm lifting, lifting things up into into a more abstract world we like. We like things to be abstract. Um, because because why, Yeah, Look at hm. Does this match the type definition? Oh, sorry. Yeah. Um, sorry I missed it. You're right. I missed an in there. Um, and sorry. Yeah. No, I Yeah, yeah. No, I had my break brackets wrong here. I wanted to do this. I want to I want to actually evaluate it. Sorry. Um, I was I was jumping ahead, jumping ahead, but thank you. Errors get chocolates. Um, OK, but not make too many more mistakes. Um, yes. OK, so what was I gonna say? What was I saying? What did I ask? Why do we lack abstraction? Why is abstract good? Yes. So we don't repeat code? Um, sure. Uh, yes. Yes. Oh, God, no. Oh, close. Um OK, now I know how far I can throw it in this lecture theatre. Thank you. Uh, Sue name Luke. Ok, good. That's good. If I stand here, you're lined up with Lucas. Um, and then the A's can take the rest of the field. Um, yes. Um, so we don't re code, so we can We can, Right? Yeah, we take We take things generally so that we can sort of like, um concrete things, Uh, make things more concrete on the way down. Right? Apply twice. It's gonna work for square and give me power four, but I can use it for other things as well. Right? So I've defined my function, apply twice and so I could define um, Power four, power four. the second definition of power four, um, as follows. So powerful two. I could be, um I could just, uh, apply twice. Um, square right now. Notice. Here. I've I've dropped my X. Right. So I say powerful Didn't even type it properly. Um, powerful X. It could apply twice square, apply, squared twice to X like this. But as we said yesterday, uh, not yesterday. Wednesday. Um, if F of X is equal to G of X for all X, then that's just the same as saying F is equal to G, right? And so we can actually drop this X here and we get that Power 42 is equal to apply. Apply twice square. Um, and we can see this Go to. So take two to the power four. I get 16, I take, uh, to the power four. I get 16. Great. It all seems to work. Work? Fine. So nice. Um, so I can do it that way. Um, now, I started to talk about this idea of type variables, so apply twice. It doesn't have to be for integer to integer functions, and it can actually be for any function. Um, could we use, uh, instead? Um, sort of. Could we use a instead of in for reply twice? Yes. Great. This is exactly where I was going. Um, thank you, Adrian. Um, doesn't work like generics. Um, yeah, it is precisely generics. Um, we can replace a We can place in with a here, right. If we've got a function that goes from a to A and an A, then I, um I can play. I can repeat the function from A to a and, um, do that, and this will work. All fine. So we have here, um, in what we call in java generics, generics, um, in high school, this is called This is called polymorphism, which is the the technical term for it. Right? And so the idea here is that apply twice can be used for any function that, uh, the A here stands for any type, right? A stands for any type, but the same a means the same type again and again and again, right? Right. So if I wanna do other types other if I want to introduce other or have other generic variables floating around, I would use other, um, variables like B. Um, can can use any, um, any. What do you want to call any identifier? Um, and it has to be the key thing here is it has to be lower case. Right? So I could say and tonnes and one. Right. So we have a function that goes from Anna to Anna. An instance. An object. That's an honour. Um, I can apply a a twice, but this is I mean, AAA and a stands for anything as well, right? Um right. And so this is why I Why I when I highlighted when I talked about before. Um, so I haven't, uh, look at the type of square. Alright, Type the square. Um, let's go end to end the S. The types start with capital letters. So capital letters for concrete types, lowercase letters for type variables for generic types. Um, right. And so that's That's our our our polymorphism. Of course. Uh, do do, do we say, um, can I can I do apply twice? Apply twice? I think I can I know. No, it was powerful. I got it. No, I would do. I can't remember. No, I won't. I won't do it cos I can't remember. I can't remember what I wanted to do But you can You can feed, like, apply twice into its own own thing and so on and so forth Um right. And so this sort of highlights, Um one key point, Which is, uh, polymorphism, um, And talking about higher order functions. So now I can talk about map. So map let's look at the type of map. Map is an inbuilt function. Um, what is Z? It takes a function that turns A's into BS and lists of A's and turns them into lists of BS. Right. So what do you think? What do you think is, um let's have a look at nice success Successor. So successor just adds one to the number. Pretty simple. Straightforward. So what do you think would happen if I say map successor to the so to this, right? Well, it's just going to apply successor to each individual object in the list and then return the list of those things basically just, like map in in python for those that are familiar with that, I do apologise to keep referring to Python. Um, I have very limited knowledge of python, but what I do know about Python is like, um so I'm just kind of assuming that you all have at least as much knowledge of python as I do. Um, anyway, so map successor does does this? It basically takes the function. Applies it, um, across across there, Um, and that's all well and good. What about, um, if I wanted to check if, um so if I want I wanted to Oh, sorry. It's a map. Oh, no, no. I say, um, I wanted to get a list of say, um I wanna identify whether the number is in in my list is odd or even right. So I want to know I want to do something like map is even or something like this. 1234. Right. Let's go throw an error because there's no such function as is even, um there, maybe one in the code. But actually, I that I can do is even relatively easily if I use anonymous functions. Right. So what's an anonymous function? Anonymous function? Um, well, in Python And this is where I am gonna slip into Python New terminal. Right. So let's open up, Python. Um, Right, So so you do list map because map returns a map item? Um, you might say Lambda X. Now, now, now I'm draw, um, and say, XX mode two is equal to zero. So I wanna map that function across. Say my list. Uh, 1234. All right, it's gonna work now. Uh oh. Sorry. Syntax switching, syntax. I want to make that function to that list. Right. And so that's That's how you would do it in python. Right? So you take the function divine An anonymous function. This here. This is what we call a lambda function. Right? Which is is basically a a placeholder function that you just like only want to use. You don't wanna ever refer to it by name. Sort of like temporarily want to want to use it up. Um and it is often very useful in maps or philtres and that sort of thing. Well, so what do we do in P in high school? Um, we pretty much exactly the same thing. Alright. Except instead of using the word lambda, we actually use the symbols Backslash, which looks like a lambda if you drop like a little bit of it. Um so Lambda X And is it a now? Um right. And so now Lambda X goes to and then what did I say? X Mod two is equal to zero, right? And I want to map that to 1234 And we can see I get exactly the same situation. So this is what, uh, how we define anonymous functions in high school. It's almost identical to how we do it in python. Um alright. And so we use that that syntax instead of this syntax literally the same, but effectively the same thing. Um and you can, um you can, you know, you don't. It doesn't have to have to be X. It could be like, uh, Y there or I think even XY right, that will still work like this if you want to use multiple arguments going in. Oh, is it dangerous? My ex wife or something? I think it's slash I. I don't know. Don't Don't do it yet. Experiment. Find out yourself is perhaps the best way. Um, it's not gonna work necessarily. Well, with with map. OK, so that's anonymous functions sitting in map. Great. And that's that's probably enough, um, mucking around to sort of give you something that you can play around with and sort of, uh, something to do. Let's now return back to the lecture slides quickly. Um, so notice a lot of these things I've been talking about are here, um, in the slides, we're talking about a function. We have the name of the function has type, and then we talk about the domain, which is the first thing in the co domain. We only have a one domain. I only have, uh, we have one co domain. That's what a function is. Takes inputs to outputs. Um, they're not quite functions they're partial functions, but that's fine. Um, and then we S We declare a function by writing, you know, by sort of verifying the the, um argument and then putting the result on the on the right hand side of an equality sign. Um, and think of them more as, uh, think of equality as literal mathematical equality rather than, um, assignment, and that will help you get through a lot of a lot of these things. Um, when we talk about currying So that's the idea of, um, having multiple multiple arguments applied to our functions and then how to deal with with multiple returns. We can, um, return topples on that front, talking about higher order functions here. Called it Fourth Power Power four. and we see those those things there, um, and lists and the type of map is this, um, and strings are strings are S are syntactic sugar for lists of characters. Right. So now I'm gonna for the last half an hour of the of the lecture, I'm going to try and solve this particular problem. So, given a, um, what I wanna do is I want to write a function. Let's call it Word frequency or something? Um, given a number N and a string containing some English words generate a report that lists the N most common words in the given string. S. So how might we actually go about this? Well, actually, let's let's sort of like, um, there are There are multiple ways. Thankfully, um, the slides have provided an algorithm cos I could spend all all lecture coming up with this algorithm, but here's a sort of, like a straightforward process. Start with the input string. I want to break it up into words. I'm then gonna sort those words. So then it's gonna Oh, sorry. First of all, I'll convert them all to lowercase because, like, for instance, if my string was literally the the content of this box here, like the word given here and the word given here, I'd want to count them both the same. So first I'll shift everything to lowercase. Um, and then I'll sort the words in dictionary order if you like, and then once once I've sorted the words like all the occurrences of the word given will be all next to each other. Right? So I wanna group the adjacent occurrences or runs of the same word. So if I might say, given, given, given given I want group that together into a single, um, single run, if you like, and then I'm gonna sort sort my runs by length, and I'm gonna take the end longest runs of my sorted list. Right? And then that's gonna and then I'm gonna generate a report, Alright? And so how do we how do we go about this? Um, in high school. So, um, forgive me if, uh, if this if this goes horribly wrong, but I'm gonna try my best to replicate, uh, re replicate the the process. Um So, first of all, um, what we're going to do is I'm gonna demonstrate a what we call a type driven design, and so I'm going to I've got my algorithm. I'm going to sort of, like, lay out a bunch of functions I sort of want to use to piece together to build up my my answer. Right. And if you look, look back here, it's like So what? What have I gotta do? Well, first thing I gotta do, I wanna break the input string into words. So I want to define a function, say, break into words. Right? And I'm going to sort of say, Well, what does that do That takes a string and it's going to return? Um Hm. Yep. A list of strings. Yes. OK, that's a great idea. Yeah, it's gonna return a list of strings. They They're gonna be my words. OK, now, um, for a placeholder, I'm just gonna write undefined, right? Undefined is fine. This will let me compile happily. Right? Um, but if I ever try to, um, work out what words is, um then it's going to, uh, throw an error. Right? And this is this sort of highlights. One thing about Haskell Haskell is what we call a lazy language. It evaluates things on an as needed basis, so you can sit there and it can be defined. And if it doesn't need to be evaluated, it won't evaluate it. So, for instance, um, I could have something like, um, yeah. So So, uh, so two divided by zero. Oh, sorry. What I can do. Let's say something like X is equal to two divided by zero. Right? Uh, hopefully X isn't defined. Um, and it'll compile quite happily even though two is divided by zero, it'll only throw an error if I ever try to, um, request the value of X. And now it throws an exception. Divide by zero. Right. And you'll note that I can do something like, you know, um, if I do something, like true or, um, X is equal to two, right? What's gonna happen here is we're gonna try and evaluate X to see if it's equal to two. Uh, well, no, it's not because the or right when or sees true. It just knows that the answer has to be true. So it doesn't actually evaluate what X is. Uh, the X is equal to to and so this is quite useful because I could define a function. Um, I can I can sort of say, Y is equal to say square. Remember, X is X is un uh, X is gonna be problematic. Uh, this is Ah, fine. Oh, OK. It thinks it thinks of ex expenditure, but, um, I could, in theory, I could, in theory, like, define something like Y is equal to square X. And that would still not complain. It would not evaluate X to work out what Y is. It will only evaluate X when I need to evaluate what Y is. Right. So this this DEC declaration, sort of like keeps going forward. And so you can have all these these these nested declarations. Um, and they won't never throw an error unless you You definitely need it. So on an as needs basis. So it's OK to say that a function is undefined. It sort of lets us define functions down the track, like, Oh, I forgot to do composition. Um, but another way to write this, um so apply twice. I'm here. I'm talking about. Apply twice. F is equal to F dot F. So F dot is function composition. So you give them two functions dot will take. Um, do you need this? So F dot G, um is the function, uh, defined as so F dot G applied to X is just take F and, um or so take G, apply X to G, and then take that input and fit it into F. Right. So it's functional composition. Um, I always like to I always like the picture. Um, a functional composition. All right, So you've got your your sequence of things here. F. Um well, I see it. G, Let's go with G and let's go with FG maps Things from here to here. F maps things from here to here, Right? So usually we say Well, actually, look, we can look at the type of of dot Um, it's a B to C. Um, and an A to B gives you an A to C. Right? So think of this as my A's, my SC. So I take it F which mats things from BS to CS My GS which match A's to BS and F Um, mathematically, we normally write F composed with a circle like this F composed with G. This is the function that basically does G and then does F That's backwards. We read cos we read functions from right, uh, from left to right from right to left. Even so, this thing here is the is the function that is the the value of it is defined as you take G of X and then you apply that to F. All right, so dot here is is shorthand for functional composition. And so what we can say is that I could I could have written Apply twice. Um, as F dot F And now I can drop the I can drop the X altogether. It's kind of nice, but so that that's kind of useful, Because if I want to compose um, sorry. I know I've got spaces going over here. You can write F dot F. Sorry, F space. Let's put space in there. Um, just to make things, um well, I don't even need parenthesis. Um, Right, So So? So I might want to compose break into words with my with my my other functions and we'll come back to defining What break into words is, um, shortly. What else? What's the next thing we do? We want to convert to lowercase. OK, and so now what have I got? I've got a I've got a list of words and I want to convert them all to lowercase. So what's my type of convert to lowercase gonna be? Well, it's gonna take a list of strings. And what's it going to return? Alyssa strings. Yeah, right. Um and again. So let's say undefined and we'll go. Thanks for that. Ok, next step. Um, O, I want to sort the words. I was going to take a list of strings and well, it's gonna turn them into again a list of strings. We're gonna put them in. Put all those strings in that list in order. I'm defined. Right? And now, next one, I want a group adjacent. Now here. Here, it's here. We we we're slipping. We're slipping into some new nomenclature here. I'm gonna I'm not, um I want to take my list of strings and turn them into a sequence of runs. OK, so, um, but what? What What really am I doing? Well, what? What? What? You know so well. What? What is a run, I guess, is the next question. What? What? What's one way to WW? One way I could view a run. Yep. A pair of a word in the in the number. We could do that. Yes. Um, so here. So here. I'm gonna sort of talk about, um a T definition. So type synonyms. Um, this is sort of one way to sort of, like, you know, keep your code, um, clean. So as I said, we we can take our list of strings and turn it into a list of runs or a list of runs. So my question is, what is a run? Um, so, um as, uh, as forgotten as as has suggested, we could say that it's a tuple, right? A pair where we've got, um, the number of the number of occurrences and the and the string itself. We could do something like that. Yeah. Anna, did you have a solution or at least a Yeah. So I think what's what might be slightly easier is sort of like you're sort of like almost jumping a gun a bit here, Um, cos it's like, um might be just better to so cos I just want to group them. I just turn them into I just take my list and sort of like, just put in brackets essentially in my thing. So let's so rather than sort of, like is is sort of what? What? Your suggestion there is sort of like it sort of seems like two steps down the track. Let's let's keep things simple. Let's just just go One thing. Let's just group them first. And then, um um and then we can, um, talk about that. So group, um is undefined, right? next thing, sort by length. Right? So that's gonna take a sequence of runs, and it's going to arrange them into the sequence of run. It's gonna arrange them in, um length. Decreasing. Uh, oops. Uh um, take Oops. So take longest. Right? So here. So now we're gonna get something interesting. So take longest. So now and now I want to take the end. Longest runs. So, what's my type gonna be? What? What things do I have to feed into this function? Yep. Ma, uh, Luke, The array of runs and an inch. Let's take the in first. Um, and the the list of runs? Yep. And what's it gonna return? A list of runs? Yep. It's just gonna be the just runs. Remember, lists can be empty, thankfully, so if I take too many, then it's fine. Ah. All right. Um, and then I want to generate a report. So what? What's what? My generated report. Well, I'm gonna have my list of runs that I've that I've that I've taken for the longest, and what I want to do is just pro produce a string that, um is my is my final report, so I don't I don't I'm not gonna I'm not worried about displaying the string. Basically, I just want the return value to be the string. Um, cos we'll talk about printing things later on. Uh OK, so I basically I've built up all my my building blocks. How do I piece all of these things together to get my function? Um, word frequency. So, first of all, what's the type of word frequent? What should the type of word frequency be? We give it. We're giving it a string. Um, and an in right. We look at the the specification. Oh, sorry. Given a number, and it go the other way around. Given an in it doesn't matter so much, um, does make things a little bit easier. So given a number and a string, I want to generate my report. I know I'm going to the wrong thing, so I want to generate my report. My report is also going to be a string. OK, so given a number and my string that I want to count the frequency within, I then want to generate a report. How how do I define word frequency? Given my number N and my string S. So what I'm gonna do? Well, let's let's look back. What? I'm gonna break it into words and break SS into words, and then I'm going to convert that that break into lower case, and then what am I gonna do? I'm going to, um, sort, I put I put it in thingy, and then I'm going to group adjacency, and then I'm gonna sort by length right now. I'm gonna take longest. Um, but now I'm gonna take So now this N comes into play, so I'm gonna take the N longest ones of that, Alright. And then I'm going to, um, generate my report closing up brackets. OK, so right, Essentially, that's what? So that that's what my word frequency is. So I can actually put some put some white space in to sort of, like, see, see what's going on. Oh, so so that's so that's my word frequency. So that's, um right. Seem Seems simple enough, right? So basically, I'm building. I'm I'm taking my words. I'm then feeding that into my break. Uh, so take my string feed into break into words. Feed that into convert to lower case Feed that into sort words feed that into group adjacency for see that into sort by length and so on and so forth. Now, I, I said right at the start. We're talking about type driven design. If everything is all right, If all my pieces all match up, then this should be perfect. This right? I said, this is This is the type I want. This should all match up, so let's go. Let's just go. Oop! Where's it gone? Where's it gone? Oh, fine. I deliver a new one. Not there. Right. So hopefully if I reload it, I won't get any any errors. And that means that everything is matched up and and it is working accordingly, Which is good. All right. Now, of course, if I try to if I try to, um would apply work out word, word, word, frequency like one. And then ABC ABC DEFDF something like this. It's gonna complain because no, nothing's defined. So now we go to how do we actually go about defining these functions? And here's a neat little trick. So a lot of these things are a lot of things here can be built up on inbuilt functions. So how do we find out what those inbuilt functions are? Well, thankfully. And this is what I've learned recently. Um, there's a thing called Hogle, and Google lets you search the the standard libraries for various things. And you can search in, uh, lots of different ways things so you can search for, uh, like, just keywords. Um, but one of the key things is you can sort by type, right? And so, for instance, look at our very first thing we want to do. Ah, the first thing we want to do. We want to break break it into words. So that takes a string and breaks it into string. And that seems like something that most programming languages might might want to do. So I might say, OK, tell me all the functions that turn a string into a SA a, um, list of strings and you can see here that there's there's, um, one called lines. Right. And it sort of like say, OK, splits the argument into a list of lines. If you take out their slash ends, that can be I. I imagine that might be quite useful if you were, um, reading a file, for instance. Um That's so that's not quite what we want. But here you see words, words, um, breaks up a string into a list of words delimited by white space. So it does does pretty much what we wanted to do. So if I said, um so if say words ABC, ABC DEF something like this, what's it gonna do? It's gonna give me my list of words. Fantastic. Great. This is exactly what I wanted to do. Um, and you know what happens if I put, like, lots of spaces in there? It sort of ignores them. That's all. Good. So break into words. Well, actually, so first of all, just double check. Where is this defined? So some of these are are defined elsewhere, but this thing is defined in the base or the prelude. Um, and so that means that it should be, um, something that's already there. So Well, I mean, I've already just seen it, but if it's C check type of words, it's there. Where is it actually defined? It's defined in this case. It's defined in the base, right? And so that's great. So I can say break into words. Well, actually, all what I want to do is just That's just the function words, right? So I don't even have to I don't have to do anything. It's already built. Built in Fantastic. What about convert to lowercase? OK, so maybe I might look up. Sort of like, OK, is there anything for doing converting it to lowercase? Ah, here we go. Uh, so now my lowercase I wanna convert the lowercase I'm trying to convert a list of strings into into all lowercase. So how might I do that? Uh, so there's no there's no list of strings to list of strings here, but I've got a string to string. I can do one thing at a time. So how might I then use that? Yeah, Brodie recursively base cases. Hm. Nice idea. Yeah. Huh? Use map. Yes. So what I might want to do is use map. Now, let's have a look at this. Lowercase. OK, so we notice here, lowercase is defined in the cabal distribution. I'm not using the kabal distribution in Ed. Um, so it's not It's cabal distribution dot simple dot U tills. Mm. OK, so we'll see. Is there anything that's that? Mm. No, there doesn't seem to be, uh, anything I know that there was There was one that was in something. But anyway, so how so? Ok, so this is not the base. It's not the base distribution, but how would I actually sort of make use of that? Well, this is where we use something like, um, an analogue of import. Um, all right, we we can import the the data, so I might just, you know, if I just grab that. I know I'm in Windows now, and so how do we import, uh, code from elsewhere? So, you know, good practise. Put it at the top. You don't have to. Oh, I forgot to set this as a module second. Look, um, alright. And so I might want to import. Say try, try to import kabal distribution to simple tills. Um, and I don't want to import the whole thing, cos I don't wanna I, um impact my name space, so I might just say I just wanna import the lower case thing from that and let's see what happens. Does it work? No. And so this is what you'll find? Um, a lot of the time you might try to import something? Yep. It might be called two lower. Yep. So what about two? Lower? Yeah. Th th This is where we're gonna get to. Yep. So too lower. So there is a two lower. Thank you, Anna. Good point. But too lower doesn't convert strings to strings. It converts chars to chars. OK, Is that a problem? Some of double map. Thank you. Yes, exactly. So that's exactly what we're gonna do. So yeah. So our our attempt to sort of, like, use use a weird library didn't work. Um, we check, Right? Too lower is not defined. So where where is it? Where does it sit? Well, it sits in data dot so it says it sits in base. We didn't We didn't find it base. It sits in data dot char. So let's try importing data dot Char um and I want to import to lower. Great. And now I can see that it takes ta ta ta ta! So chart below chart to char. And so we want to do double map cos if I map it across the S to To To to get to the string I'm gonna map map. Well, ok, hopefully this will be very clear. So if I map so hang on. Um yeah, as I say, map map to lower. That would just be enough, right? I can say convert to lowercase. I can try something ABC a PP and double check. Yes, and that will work. So I notice I didn't have to take. Didn't have to take the lists in and my arguments. And so that worry about that because this map to lower is going to map the map to lower is gonna convert, um, a string to a lowercase string. And then if I map that across the the, um, the list of strings, then that's gonna turn all of those into a list of strings. OK, so a little bit more complicated. We had to do an import, Yana. Yes. So take my list of strings that's called SS for the sake of that, um and so what I'm gonna do so map. So, first of all, map to lower map to lower, right, that's going to map it. It takes a char to char function, so it's gonna it's needs to be applied to lists of chars which are strings. So this will This will work on a string right and convert a string to a to a lower case, right? So map to lower that this particular part of things converts a single string to the lower case version string. And then I wanna map that function across my list of strings like so And so this is why I could drop that SS is because it appears on the right hand side. Both times. Um, I should point out if it doesn't appear on the right hand side, you can't drop it. Like if it was, like, in the middle or somewhere. So, like, for instance, here we see right, we've got this S here. It looks like it's on the right hand side and it's on the right hand side here. But this S isn't quite on the right hand side because we've got a lot of brackets there. It's actually it sort of, like gets fed into there. So I can't drop this S. Um, here what I could do. Um, I should say I could, um, compose things so I could say this is generate report compose with take longest N composed with sort by length, composed with, um group ge composed with, um sort words composed with convert to lowercase composed with break into words. Right? And then S, Right? So now I'm composing. I'm building up all of those functions first and then, um, doing all the composition and then plugging S in. And now my S is on the right hand side of both sides. And so I can, in theory, just drop it like that and a lot of functional programmers, um, like to do this because again, it's more abstract. We're dealing at a higher abstract level. Um, I don't necessarily agree with that. Um, right, we've come to the end of the the time. So what I might do is I'll just, um I'll I'll complete. I'll complete this this thing in a recording offline and post it, um, so you guys can see or you can have a go at at, uh,
