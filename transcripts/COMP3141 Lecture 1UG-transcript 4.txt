SPEAKER 0
um, she was the person who made this voice. Yeah, actually, yes.

SPEAKER 1
Some of the exercise.

SPEAKER 0
Thanks. Oh, I'll just be showing up.

SPEAKER 2
You can correct me in my asthma. I actually, I actually managed to write a case statement in work.

SPEAKER 1
Yeah.

SPEAKER 2
I don't know if I've got a step. That's where I ended last time.

SPEAKER 0
She run it in a, like, a web based or just like I'm It's a bit crowded. That's too much. Yeah, I know about, um, So that's that's that's like,

SPEAKER 2
you know, um, you can ask people what they want

SPEAKER 0
to see.

SPEAKER 2
Um, since I only posted yesterday, I don't expect anybody to receive anything, but I'm hoping that, like, I'll post a little bit more sweet. Yeah. No, I don't need I barely know.

SPEAKER 1
Cigarette. You just gotta pick one time.

SPEAKER 2
Um, but also organising tutorials for this would help sessions for this. All of these. Oh, my God. Right. All work spaces. We make every dinner. Sure. Right. Apologies still, um, come to grips with terms starting. Um, let's give you some lights. Lighting board off. Off off. Nope. That's on. Is that those ones? There we go. Right now. You can see better. Um, you can have more lights if you wish. Um, right. Um, just a quick, uh, question Are all Ed, uh, workspaces. We make an ed. Um, private, um, you can share. I'm I'm happy for people to share and and discuss these things. But remember, when you're doing assignments and so on, it's supposed to be your own work. Um, I'm I'm but, um I'm open to collaboration during assignments. When it comes to the exam. Of course, it has has to be your own work. Um, I will be making, um, last year's lecture notes slash Code available. Um, you Johannes, this is my first lecture course where I've actually been coding live. Um, and I'm terrible at it. Um, So, um, so Johannes's material has, um, is is generally better annotated. We are covering more or less the same thing. Um, I will point out that if there's any conflict, if there's anything that Johannes says that I say differently, you go with what I say because that's cos I'm the one assessing this course. Um, but hopefully there wasn't There won't be too much different now. Um, as I posted an announcement last night. Um, or early this morning, the, um I there was just a a bit more I wanted to cover from last last Wednesday's lecture. Um, and since I've since I was a bit slow releasing the exercises, that rough is gonna go through today. Um, I thought it would be better to just sort of lean in a little bit on this Friday lecture. This will not be normal. I will try and get all the content done on the Wednesday. Um, and things will be available. The exercises for the upcoming week will be available much earlier. Anyway, um, so last time we were talking about types. Um, we're introducing the idea of of data types. Um, the first, the first, um, exposure to this is the idea of an enumerated data type. Um, where we have, uh, Let's go down here. We talk about a data type and we're talking about, uh, in this particular case, we're talking about documents for, uh, for immigration or for for identity. Uh, sorry. Identity, identity identification, iden, identity proof, proof of identity. Um, and so in normal code, like C or Java, you would probably, um, establish these things with an enum. I then sort of say OK, I only want to consider, like, five possible outcomes. I don't want to sort of, like, worry about, um, trying to consider document number 27. I just want the five, the five basic document items and we in high school. The way we implement this, um, is with a data keyword. And so, um, so we've got So, as as we said before, we can have type synonyms, so I could say I could say a document is just a a synonym for a string. Uh, again, uh, it's important on on style matters. Why you would do why, Why? You would call it a document as opposed to a string. It's like, Well, it makes makes the, you know, the the code easier to understand, right? So then I define this function, it takes a S a list of documents to integers. Um, sorry. That's that's why that was probably complaining. Um, it takes a list of documents to integers um and, um and that that makes a little bit more sense from a from a maintainability, uh, point, rather than saying it takes a list of strings, right? So it makes it a little bit clearer what the purpose of points of the points function is. Um, but, uh, as we highlighted last time, the problem. One of the issues with calling a document a string is that now this sort of lets in in theory, any kind of string be a document. And so you might have to worry about how many points do I sign to say hello? Um and so on. Right. So it's gonna go on if I try and do something like this. And so introducing an enum type or enumerated type and saying, OK, whose fault is that? Um, yeah, introducing a an enumerated type, um, is is what you would do in in most other code. Um, you just say right, these are my options for my for my document, and I'm going to deal with each one on a case by case basis. Um, and the way we do this in high school is, um, by introducing, um, just literally writing it out like this. Now, data types or so data types are more than just enumeration enumerations things in, um, in high school, a data type. I mean, the the understanding of what a data type is. Data type is structure together with data, right? And so these these all highlight, um, different kinds of structures, as it were. It's like I've got the passport structure, the birth certificate structure, but I've got no data associated with these things. So So an in, um, type, um, is is a data type with no data associated with it. Um, when it comes to high school, we don't make a distinction, Um, between, you know, data types without data and data types with data. The only way we, uh the way we do that is, um, we we can add, um, additional things. So these are all I should point out. These are all constructors, but you can construct data objects, um, with with, um with data associated with them. So one example might be say, um a coordinate. Right. So you would say a coordinate you You might want to say a coordinate. Um, it's just a pair of INTs, right? Or to two dimensional coordinate might be just a pair of ints, so this would be AAA one way to a to approach, um, like talking about coordinates. Um, so define define a data type like this. Um, but another way to do it would be to say OK, rather than define, um, define a type synonym for coordinates. Because then I can't make a distinction between, say, a coordinate. Um, and, well, another example might be, um, a a, um What do I want to say? A date? A a, uh, month and day. Right. So month and day, You might also say right, you know, today is the seventh of the sixth. Is it the sixth of the sixth? No, it's the seventh of the sixth today. And so a month and a day might also be I could say I could represent as a pair of events like this. Now, how do I make the distinction between a Whether I've got a coordinate or whether I've got a a month and a day pair? Um, you know, I don't want to have like, for instance, some invalid month and day pairs might be the 13th of the 13th. The pair 13th 13. That's not That's not gonna be a valid, um, month and day. So, um, this is one way to to go about defining sort of types, uh, of the these particular these particular data. And I do apologise. I do realise I'm supposed to be coding a little bit higher on the page. Um, but what we could also do is define our own our own data types. Um, associated with these these, um, types. So in this particular case, and I might say, um, a month day, um, is a data type, right? And so what would I How would I construct it? I might construct it with, um say, oh, what was the same man? I'll just go Monday, Uh, or M day. Um, so there's my constructor, and then the data I would pass into this would be a pair of INTs. So in in, like, so and so this is a a data type with associated data. And so I could say, um so M equals, um, M Day 445. Or actually, let's say today let's be a little bit sensible today is construct it with the date and the month like so and, um and so when I run this do, do, do, do, do, do, let's go here and do that I don't know why it can't let me do that in one. Go. Um, I can say I can ask about you know what? Tell me. Tell me about today. Um, and now it's gonna complain because I haven't I haven't, uh, said that, um I haven't told, uh described how to how to print a mo a mon a month day. So let's say that, uh, let's reload. Right. And this tells me what today is today is AM day, um, seven and six. And what's the type of today? Um, today's is a month day, right? And so this is kind of this is, um this is slightly better, in some sense than defining a a month day as a pair of events. Why? Because actually, I could be a little bit more, um, a little bit more precise than, say, a month. Um is either January or February or March and so on. Let's put June in here. Um and then instead of saying a month, day is a pair of ins because it's like, Oh, do I mean the day, first of the month or the month? First of the day? I can actually say it's an inch and a month like so Alright. And then that That lets me sort of say, OK, today is the seventh of June, and it's gonna complain because, um, I haven't defined what? How to show a month or drive a show? No. Oh, yeah. No, that works. So, what's today? Today is the seventh of June. It's an M day, seventh of June. So that's how we associate data with our, um, with our data types and again. So our data. So this is sort of like in java. This would be the class Y max, uh, in, uh, limit the the range of in, um, so good question. Great question. Kit Kat question. Um, and, um, speaking of types, um, my type of Kit kat has changed. Now. Snickers. Um, so it's a chocolate bar. Um uh, here we go. Oh, they throw better as well, Which is good. It's good in a big theatre. Um, yes. Can you can we limit the range of INTs? They say instead of saying ok, instead of saying it's an inch. It's an ink from 1 to 12. Um, I don't think we can, can we? My My understanding is no, um, do you know No. Do you know R? We can. Can we limit? We can't. We can't restrict the domain of a type. Uh, not easily. Let's just say not easily. Um, it's better to to redefine its own type. Um, yeah. So this is this is stretching my knowledge of what we can and can't do. So let's say the good question. Excellent question. Yes. So we could, um just fine that that, like, instead

SPEAKER 1
of constructing it with the name, define the function that

SPEAKER 2
construct. Yeah. So it's a it's a bit. Yeah, it's a bit messy. And that actually leads to it is a good point. So So, um Vin Victor Vincent. Vincent, I can't remember which way round is it? I always Oh, I should know by now. It, uh, Victor? Yes. As Victor says, you could define, um, you could limit your constructor to sort of say I can't construct an a MA month. Uh, end day. Uh, sorry. A month day, Unless my you know, in happens to be in a certain range. And But that brings me to, um, a point that we're going to talk about in here. Um, no, not that one. alright. Um, yeah. So a point here, raised by Alexis King, which is sort of like reading is worthwhile having a look at this particular thing. Um, she states that the best way to, um, it's it's worthwhile reading about this blog blog post. Um, it's a better process to pause rather than validate. And so, what do we mean by that? I think that there's, uh, there's content in the slides a bit further up. Sure where? Where it was, actually. So anyway, Oh, yeah. So Pa pause rather than validate, right? So the idea is that basically, rather than sort of say, Let's have a constructor that that doesn't let you know, Sort of like says if I try to construct it with month 13, Um, it throws an error. Let's just limit myself to only having 13 months. And so I can never construct something with the month 13. Um, So rather than validate your your input, actually, limit your limit. The the domain in the first place. Um, but we'll get, um, we'll come back to that in a little bit. Let's keep talking about, uh, data types. Um, so you can con Yeah. Oh, sorry. Yeah, um, that's a good question. Um, it's I mean, it is kind of, uh, it would be stored. Um, Y, You know it all, associate. Uh, well, I I actually don't know, but I, I assume it just sorts it like a T of one. Just sort of like, um, so with these ones, the

SPEAKER 0
MD constructor. And it has two pointers, one to an end and one to a month That Yep.

SPEAKER 2
OK, thank you. Yep. So yeah, the the inner working, I mean, yeah, as yeah, I guess. I mean, intuitively, it's like you would imagine it. It's a It's an object that points to to two objects. Um, so it's reserving some space for for M day in that way. Yeah, that's that's how I would intuitively understand it, but yeah. Thank you for that. Clarifying that Raphael. Um right. Um, so yeah, so? So we can do this. And and so you can see here. We've got, um, what we've got is we've we we've got what we call a sum type we can sort of, like, take, um it can be this, or it can be this, or it can be this. Um and we've got like, um, sort of like compound types. We build up type with with extra data. We can, of course, combine these things. Um, and I can say, like, for instance, a coordinate, Um, could be a two D. Uh, let's call it two DA a capital T a two D coordinate with a pair of events, um, or a 3D coordinate with a triple events. A scape driving show? Actually, that's, you know, driving show and EQ. Um, we'll we'll talk about, um type classes in a minute. So, um and so I could also say something like this. And so you can have, like, a combination of some types and and data types. And it's it's, um it's like a union construct a union in, um, a union type in C. Um, so it just says a coordinate is either a two D thing with a pair of events or a 3D thing with a pair of events and which constructor you use indicates, Um, which one to go by? Um, but you can do a little bit more so in Java. So So what? Hang on. Let's let's be a bit clear. Data types types can be a union of, uh, constructors with data. That's all fine. Um, but you can actually. So in Java, we have generics, right? And so what do we mean by that? So you have, like, a list. You can say you can talk about a list of, um, integers, right? Or a list of, um, strings and so on and so forth. They have these these type annotations that you you can throw in to say that my particular list, any object you pull from my list is going to be an integer or any object I pull from my list is going to be a string. And we have the same idea, of course, going on in high school right in that we know that, um, so 123 is going to be a list of integers. And, um uh, ABC. Oops. DEF is going to be a list of strings. Um, what about if we wanted to find our own types, our own polymorphic types? Um, how do we do that? So we can do that quite easily. Um, so let's go with my list. Right. Um, so my list, um, also, I want to talk about my list. I want to talk about lists of certain things we can throw in a type parameter. Um, in there, we can throw multiple type parameters if you like, but I'm gonna say my list a S. So this is gonna be a list of A's. And so how? What? What does it mean? It means the objects are an A, um and so what? What are my options? What are my constructs? So, what are what is a list? A list is either the empty list, um, or it's an object consed with a smaller list. So, actually, why am I jumping to my list? Let's talk about, uh, no, no, I'll talk. Um, yeah. No, no, no, no. I'll do this. It's like so I can do a cons. So there's my constructor here. Um, and then I want an object, um, together with a list. Right. So we've got a pair of things. The first thing is going to be an object of type A. So if it's a list of NS, it's gonna be an N. If it's a list of strings, it's gonna be a string. And the second object is going to be a pointer back to another list. Right? So you have this. So this is also recursive, you know, type variables, um, and recursive definitions. These are all fine when defining a data. A data structure. Now, I should point out that actually, one of the more useful ones, So lists are very useful again. Should be coding at the top of the, uh, of the page. A very useful data type floating around, um, is, uh, what we call, um, so I think the ma in front of it, um, it's a maybe right. And and maybe and maybe of type A And what is a maybe and maybe is either, um, nothing. Mm. Put my nothing in there because I think nothing or it's it's a something. But just one thing. So just just an A, um, and what this represents this represents basically an object that can take a null value. Right. So this is like, basically in intuitively bye intuitively a my maybe say, um, represents a null object. So the null the null case would correspond to a nothing. And then the the non null case would correspond to a just, um, a just a So in um, so keep in mind here, so may maybe is actually defined in here. So I could say, um, X equals, uh, just three or just four. So type of type of X. Um, X is a maybe here. So maybe, maybe is is a well defined function. And, um, it's constructors. You either have just or nothing and say, why is nothing? Um, And so again, I can ask, What's the type of type of Y and type of Y is A is a maybe. Right, So maybe a is a is one of these, um, parameterized types that represents sort of, like the ability to be nulled. So this is kind of delving a little bit on on, um, the question we had a bit earlier. Can we sort of L restrict our things? Well, actually, what I'm doing is is expanding my universe, so not just, uh, uh, more than just INTs. But now I have, um, the possibility of, uh, of having a nable in, right. And so this is sort of like we're we're explicitly introducing, um, the null object, Uh, by having by having a maybe, uh, having the maybe data type. Um, which is kind of good because of, you know, the idea behind, uh, high school programming or functional programming. Sorry. Particular high school programming is that we don't have any side effects. We know exactly what's going into the into the mix. So if I plug if I say my function takes an in I know for a fact that my input cannot be null so you don't run into null Pointer exceptions if I But if I want to have the possibility of having a null thing, then I say my function I have to define my function. Um, not so my funk. Um not as I say, a function from Ince to ins. Um say I might say OK, actually, it's not ins to INS. It's, um because I might have a a null input. My I provided a a null input. So what happens now? Well, in order to define my function, I have to deal with the two cases I have to deal with if I'm given a a just an X. Um so say my funk. Um, so just just X right. And I would say, OK, if you give me a non null value, then I'm gonna say return to, say X plus one, right? And then if you give me the null value, I've gotta tell you, I gotta tell you exactly what to do with it. Um, I might say, um, return zero, for example. Right. And so that's that's not talking about input. But I could also flip it around and and provide nable output. And a good example for that might be, say, taking the head of a list. So take ahead of a list. They're given a list of of objects, right? What if I give you the empty list? What am I going to return, right? I can't return anything. So, um so rather than say, this returns an A I actually don't want to. I don't want that possibility. May I? Perhaps what I want to do is return. Um, possibly nothing. And so I say, right, my my head takes a list, and it might return nothing. Right? And so this is sort of like my head of of the empty list is equal to nothing. Um, or was it my? No. I gonna say nothing. I'm just gonna say nothing, and I can say my head of X comes, Xs is equal to X, right? So not X just sticks, right? It can't be X because X is of type A. It needs to be of type, maybe a so it needs to be adjust something. So just here. So it says, um, it's a case of X where X is not null, right? And so this is this is a somewhat a a safer version of head if I tried to do head on the empty list over here. Alright, so head is a is a well defined function. If I try to do the head of the empty list, it throws an exception. Right? Whereas here, um, slightly safer code Um here I'm instead of throwing it an exception, I'm actually returning something and then letting the whatever called the function in the first place have to deal with that response. So it's like going Oh, you return to nothing. OK, now I can throw an exception, right? And so, by saying OK, it might return to nothing. It might return just X. And this is this is, um, kind of like error, error, handling or exception handling in in various other programming languages right. So basically, you're absorbing the the error and passing it up the chain. Yeah. What is that, like that same thing you just said.

SPEAKER 0
Why ahead?

SPEAKER 2
Um, yeah, it's a good question. I give you a chocolate for the last question. So you have a second question? Yeah. Now, what is just just as a constructor, right? So a maybe object is either. So let's have a look at, um let's have a look at maybe, uh right. Yep. So here it's defined here as this right. So we've got two constructors. It's either a nothing or it's a just a right. So it's literally just as a wrapper to sort of say, Yeah, I can confirm that this exists like it's a not a nothing. So think of just as like, a wrapper if you like, um, to to sort of wrap a into be becoming a maybe type right? So that's that's so it's It's the Const. It's the constructor to turn X into a maybe X turn into maybe a turn in into a Maybe in. If that makes sense, so does that make it clear? So it's like so saying just is like promising that It's not null effectively. Um, yeah. So good question. Right? Um, yeah. So here to talk about going through some of these things. So we have, um as I said, types, uh, types gonna have type parameters. So here's our Maybe it's either just a or nothing. They can be recursive so in in the pre prelude. This is how a list is defined. A list is defined as either the empty list or it's a cons of an object together with a smaller list. Oh, did I not? I think I must have probably forgotten that. Oh, yes, it's a mother's day. Yep. So you gotta You gotta keep the type. You gotta keep passing the type parameters around. Um, just to clarify. Um, but then you can also define the natural numbers. So no natural numbers, remember, a natural number is either zero or one more than a smaller natural number, right? And so how do we define that in high school? Uh, we literally it says, um, the natural numbers are either zero or a suck of a natural. Alright. And so the number one. So I think I think it's defined. No, in no, no. Um good. Uh, le let's define it. So data natural. I'm I'm pretty sure it's defined somewhere, but right. And so we can define this. And then, um you can say, like, you know, one or one is really just suck of zero. All right, so this call like call say one is cycle zero and two is suck of one, right? And then Oh, let's hang on. Let's be able to print this driving show. One is a suck of 02 is suck of one. And so what is two? It won't say Suck of one. It will say suck or suck of zero. Yeah. Yes.

SPEAKER 1
I I used to sing. I know it was, uh so it's a list of

SPEAKER 2
of A's. So the a parameterizes the the data type it's given. So it's like saying, OK, my data type uh, this is gonna be Is that Morgan? Yeah. Thank you. Um good. Um, no, it was more a case. I'm checking if I remember your name. Right. Um, yes. OK, so, um, when we say, say list of a here, they're saying right? Basically, I'm saying there are lots and lots of different kinds of lists and Um, in fact, there are infinitely many of them, and you can have a list of ins and you can have a list of strings and you can have a list of lists and you can have a list of We can have a list of lists of strings and things like this. And so it's like basically, it's saying, um, it's instead of like, thinking of of a list in sort of like one dimension. It's like, sort of adding another dimension to the to the whole thing. So, like, basically, um, I fundamentally, everything's the same. But here the the A here is the same as this I hear. And this I hear. And so this is saying that a list of ins can be constructed or 11 object in a list of INTs is built up from a cons of an ink, together with a smaller list of INTs. Right? And so the a here. So the first a here just sort of says, um, well, so I mean, if if you're doing it in Java, So So it was interesting when I learned Java, they didn't have generics. Um, and then I learned high school And then I learned about Java generics, and I went OK, right? So they're just trying to do what they do in high school. Um, in high school, you might do something like, um, so you might say list of, um, of type E and you might have a constructor says, like, um uh, like, uh da da da da da. Uh, so sorry a list. And you might have E object or something like this. And so this is like taking an E as an input to create your new um, your new thing. Right. Um, so here. Sorry. This is an interface, and I've forgotten. So in Java you would do you would have something like this. Do, do, do, do, do, do do Let's let's do some indentation. Um and you might have a a, um, function like public, uh, public E head. Right. And so the E here is this This this parameterized type is just saying I'm gonna have a list of if I have a list of strings Then I know that when I construct it, I need to provide it a string. Right. Um and but if I call head, it's gonna return a string, right. And this E here is playing the same role as the A um, here. Right, So saying, OK, I've got a list of strings. Um, in that case, in order to construct it, I need to provide it with a string and a list of strings. Right? Um and nil just happens to be something that's a list, a list of anything you like. So it's gonna be a list of ins or a list of strings or a list of, um and so on and so forth. Right? So a is just like it would be just like a job. A is a represents any type, so it could be integers. It could be strings. It could be, um, it could be bullions. It could be, uh, anything. So it's a type variable. So it could be maybe bullions and things like this, so you can have lists of maybe bullions and lists of bullions and and so on and so forth lists of lists of of things. And so when we see things like map, the type of map right here again, the A and the BS are playing those roles. Right? Map will take any ti. Any function that takes A's to BS a list of A's and turn it into a list of BS, right? And so it's the same. It's the same idea, right? So basically, you can have maps of that maps, ins to strings, um, and take a list of ins and turn it into a list of strings. Right? You can take a map that takes, uh, have a function that turns insta bulls, take a list of ins and turn it into a list of bulls. No. Good question. Good question. Um, and I love questions. Um, not at least, cos I. I much, much prefer Prefer to, um, Discover what? I don't know, right? So a good principle Good principle programming is to make, uh, illegal states unrepentable as much as much as you can. So when we're talking about, for instance, our month day type Yeah, right. By turning it into a, um, an inch in a month rather than to a pair of ins that starts to eliminate some cases that I that I don't want to have to worry about, like the 13th or the 13th, for example. Alright. So here, By introducing a month type I've started to eliminate, um, some of the cases that I don't have to worry about. Of course, there are still other cases. Um, for instance, I don't you know, the 30th of February would be a valid month day According to this, um, this definition and it's a little bit tricky to sort of, like limit limit my ins here because the 30th of January is fine, whereas the 30th of February is is bad, but so you can't always do it, but to to the best ability you want to do. So you want to choose types that constrain your implementation as much as possible, and then your failure, your failure scenarios are going to be eliminated by construction. So, as an example, um, consider here. So I could say a contact, um, is built up from a contact. So the contact constructor C, um, with a name, and then maybe they've got an address, and maybe they've got an email number, right? So that's that's a That's a possibility. So address could be null or an email could be null. Um, instead, it is better to define this instead of having one constructor with, um a possible address and a possible email. It's better to have three constructors, right? Oh, sorry. Better. Better to find. Sorry. Better to find a type called contact Details. Sorry. With three constructors. Um, and then define a contact to be a name with contact details. So here we eliminate a failure. State What failure State. Do we eliminate what I can? Yes. So exactly if we don't have, um right. If if address and email were nothing, right. So in other words, there's no way to contact this contact, right? We don't We don't want to have contacts that we can't contact. Um, so yeah, so we eliminated that particular possibility So we can have you know, the case, whether they've got any email or only address or both address and email. Um, if we don't eliminate all cases, we're gonna end up with partial functions. So partial functions are functions that are not well defined. Right? So we saw, um I was I was working through here. My my document type. Oh, I never finished that. I'll get back, I'll I'll finish that offline. Um oh, no, I did finish it. Yeah. Sorry. I did finish it. Um No. So, uh, du Du Du du, which one was I going to talk about? Um, yeah, OK, so de dealing with, say, a month day And, like, I'd maybe I define a function and whatever, and, um, you know, 30th of February is a valid month day, but my function is not defined to work for the 30th of February, right? So what happens then, is I have what's a partial function, right? The function that doesn't return a value and it is not defined for all possible values. We kind of saw that. Uh, do I have seen I have seen this before? I can't remember where. Um Well, for instance, if I take the is primary function, if I had didn't have this last line here is primary wouldn't be defined for, um, anything other than a passport and a birth certificate. And so what? What happens if that if that's the case? All right. Um, so Oops. Right. I can still compile. Uh, I can still load the file. That's all fine. And even is. Primary is defined for cer certain values, right? But if I try to do, um if I try to ask the question. What if a credit card is is a primary right? It will complain because it's not defined. It will throw a an exception. Um, function, not defined error? Um, yeah. So the pattern, the pattern didn't match. I didn't find a value value for that particular function. So it's OK to it's OK to have partially defined functions. It's just not a good prints, Not a good, uh, principal programming. Um, and I should point out here, So some examples head. Right. So we tried to tried to call the head of the empty list. Um, it's gonna throw an exception. Tail. Um, it's also tail of the empty list is not well defined. Um, here's a function that I forgot to mention at the time. Bang, bang. Um bang bang lets you extract, um, a particular element from the list. Right? So I can extract the zeroth element of the list. I can extract the the, um, th, uh, second element of the list, which is three. But what happens if I try to extract the third element of the list? Right? It throws an exception. Right? So it's not. It's not defined for this particular particular set up here. Right? So So it throws an exception. Um, in the in our in the the default behaviour with with partial functions. If you try to call function as C call the function on an object outside of its defined domain, it will throw an exception. Um, but this raises the question of how can we actually eliminate or, you know, if we have a bit more control over things, How do we eliminate this? Uh, this partiality. So there are two ways we can do this. Um, we can make our codomain larger so we can sort of add null values. For example, um, which we saw when we D We defined our head. We say, take a list instead of returning an object A I return it maybe a And then in that case, I If I call head on the empty list, I can just return null or nothing, right? And then if I call head on on something else, then it tells X, and so this tells me that, um, my head is It's not and won't necessarily throw an exception. Um, so it won't throw an exception. It will just return something that um, may or may not exist. Um, so that's one way to do it. So make your make your domain larger and sort of, like, you know, catch those exceptions and sort of return something that we can handle further up the chain. Um, the other alternative is we can constrain the domain. We can make our inputs our set of valid inputs. Um, limited. And so, in this particular case, what we would do instead of saying, um, head takes a list, we can say it takes a non empty list. So a non empty list of A's, um, and then it will return an a right. But then this raises the question. How do we define? Say what we mean by a non empty list while we go back to look at, um uh, so non empty list. Right. So remember what a list was. So, um, a data list? Um, it's either nil or, um K or a list of type A there. Cons of A and list A Right. So that's that That allows empty lists. What about a non empty list? Right. Well, we want a non empty list of of a things. Alright, Um we still have this constructor, except we're gonna make it non empty. Uh, I can add an item to a non empty list. Um, easy enough. But now, instead of my empty list being my base case, my base case is going to be, um, a single object. So I can't start with an empty list. I have to start with a A list containing one thing. So I'm gonna have one. And I think What is it? Call, um, what do they call it? No, it's still cottons. Yeah, right. And so if I define non empty like this, then this sort of allows for non empty list, and then I can define um a My safe, safe head function takes non empty lists. I've typed a and returns an A. So now I don't have to worry about whether a is null or not, because no, I've constrained my input to be restricted to non empty lists. ABC. No, no, no, no. Alright. And then how would I define that? Well, now I have to sort of, like, consider the two cases. So either I have, uh, one of an X. So I have a single X right in which case the head is just gonna be X or I'm gonna have, um, in the second case where I've got a cons. I've got, um, an X together with a non empty list. Here's my ex's. And again, I'm just gonna return X. In this particular case, I don't actually care about Xs, so I can just do something like this, right? Um and then that, uh, that should that should hopefully work. No, no, of course. Didn't, um, Probably doesn't like cons there. So, um, any cons? Let's go. Yeah. So that's, uh that's how we can sort of, like, build those things, right? Uh, right. So, um, we, uh, as I do suggest reading the blog, it's relatively easy to digest. Talking about paths don't validate runs through, um, pretty much the same Same examples. Um, And so this is something that we were talking about before, right? Ok, um, quickly before the break, I'm gonna talk about type classes. We've kind of seen these. These in actions, right? We've seen that. I talk about show and EQ when I say these things are deriving show or deriving show and EQ. What exactly that means, right So what is what is what is deriving show means. It means that well, if we look at if we ask the compiler about show, who knows what it's gonna say? Um, so there's all sorts of things, right? But basically, show is what we call a type class. So, like a collection of types, Um, and it's it's a bit like a Java interface or a or a or a header file or C header file. It's basically saying, OK, if our type belongs to this type class, then there are There are certain promises that we know that, uh, belong to this in this particular case with show, um, if a type belongs to show, then there's going to be Where is it? Um, yeah, there's gonna be three functions, um, which will apply to that PP type apply to that particular thing. Um, the main I the most important one of these is show. You don't need to worry so much about the others. The others can, uh, actually derive, um, from show directly. Um, but what show does is it converts your object into a string, right? And so if once once you know that there's a show function. You can pretty print the the output and And when we say deriving show basically it just does the default behaviour. So if if, for instance, our month day, um, thing it takes an so so month drive show, it's just gonna print out the constructor. But month day takes an inch and a month, right? What it does is it It applies the show function for the in, and it applies the show function for the month in order to generate the show function for the for the month day. Right. So when we say deriving shows, the driving shows sort of takes the default behaviour Um, EQ, uh is another another type class? Ah, right. And EQ lets us define equality and inequality and why we just jumped over there. I don't know. No, it's not. It's not. Uh, yeah. So anyway, so the the double equals sign? Um, OK, so that but you might want to define your own equality right in the same same way. Um, you can override the dot equals method in Java. Um, or you can overload the the double equals sign in C. Right? So how do we how do we sort of, like, take our our user defined functions instead of deriving deriving the the default, um, show behaviour or the de default equality behaviour? Um, how do we How do we implement that? So instead, what we do is we say, um um, we say our data type is an instance of show. So our data type belongs to this type class, Um, by and then do you say right, I'm gonna define the show function for my data type, right? So this particular case So ball, I say show of true is gonna be true. Show of false is going to be false. Like the string True. The show, The string false. Um, so I could say, um, instance, um, show month day. So instead of saying it Derives show, Let's go. Da da da Let's delete that part. Um, right. And so now I need to say, Well, if I give it a month day, um, of the day and the month right, How is how is this actually going to behave? Let's put that in brackets so it passes it correctly. Um, what I could say is, I could say something like, um, the I could show the day, show the show, the integer show, the date. Um, I can then put the th on the front, um, and then say show the month. And why is it complaining? Yeah, that's probably better. All right. And of course, I don't need parentheses here, right? And so hopefully no, they didn't like that. Oh, I say, put the right type in there, right? And now I can say, um, show toda today was equal to the seventh of June. Ah, compile it first, um, And then if I say what's today, it'll say seventh of June like so. So you can override the show where you can override the default behaviour, and you can do the same thing with the equalities function for EQ, um, or the, um um, all of these things. Now, when I ask about so we talk about what's the type of say equals we see here that equals the I? I talked a little bit about this type, this type definition here. This says that if a belongs to the type class EQ then equals, equals, takes two A's and returns a boolean. So here we've got this double implication sign this double double arrow here. Read it as implication. Now, if a is of type equality, then this will be a a function of type A to A to ball and then the same thing we can say the same thing about, um, show right show says that if a is a type show, then show itself will take an A and return a string. Now, if we looked at when we looked at the, um when we had info information about the show, uh, type class we saw here, there was some some other functions, like show list. Right show list is sort of automatically derived from show in the sense that I can take a list of things. So I define the show function for month day. But now that from that, I can derive a, um so I can take, like, today and today and a list of a list of month days. Let's take a pair of them and it will call the call the show function automatically for us. So, like so um implementing show for month day, we'll give you show for the list of month days and list of lists of month days and so on and so forth. I said a list of list of month days, and so it's it it propagates down through, uh, through in a very smart way, which is kind of nice. Um, right. And And you can, uh, yeah, so you can build build things on that, um, and Haskell supports automatically deriving, um, things like shows. So you don't have to always do it If if it's like going to be fairly de, uh, default. Um, right, if you're maths out, if you If you've had enough maths, feel free to switch off for the next couple of minutes. Um, I'm gonna be a little bit more mathsy for for a little bit. It's not important. It's not terribly important. Um, but it's just sort of again highlighting, um, some things I will come back. I will talk about, um, new type. This is sort of the the best. The best motivation for this. But you don't need to worry so much about this maths. We'll talk a little bit about abstract algebra for a for a minute. So a semi group is an an abstract. Uh, sorry. An an algebraic concept where you've got a notion of basically multiplication. Um, so ba the idea is you've got an operation that takes two objects of of your of your set S and combines them somehow, um, to give you a new object. So I think it'll look like multiplication. And then the important thing is that this dot This this operation dot is associative. So that means that it doesn't matter what order you multiply things. A times B times C is the same as a times B times C, right? And so this is what we call a semi group. Um, can anyone think of any any, um, examples of a semi group your thoughts if you take the integers and multiplication. That's a semi group, right? Multiplication is associative. It doesn't matter if you do five times. Three times two or five times. Three times two. It doesn't matter whether you do five times three first or three times two first, um, integers with addition. There is also a semi group. Um, An example of a not semi group is like integers with subtraction. Right? Five minus. We do it in on here for the sake of right. If I do five minus three minus two. Right where I put the brackets matters right? This is different from this. Yep. Um uh, Exponentiation is is also not associative five to the power of three to the power two. Right? This is different from this. And so there are lots of things which are not associative. It's really interesting. Um, people think Oh, I think, um, subtraction and division are strange because they're not commutative and they're not. Associative division is another example. Five divided by three, divided by two is different from five divided by three, divided by two people think Oh, you know, because you used to, like, subtract. Uh, sorry addition. You can swap the things around. You can do them in any order multiplication. You can do the same thing, but subtraction. You've got to get it around the right way and division. You've gotta get it around the right way. Actually, so many more things are not associative and not commutative. Um, there's like, plus and times are actually sort of special cases rather than like the default. Anyway, that's that's another philosophical rant. Um, ok, what about some examples we've seen, um, strings with concatenation. Right, So if I do. ABC plus, um DEF plus, um, ABC again like this. It doesn't matter if I do this concatenation first or that concatenation first. Right? So, uh, we saw that I already wrote it down without without the concatenation. Um, one really nice one. If I've got functions from say, if I take the functions from the integers to the integers So GHG and F are all functions from, say, the integers to the integers or in fact, any set to itself. Um, then H dot G dot F is going to be the same as H dot G dot F. Right? So if I do F If I If I combine H and G first and then do, um and then do F Um sorry. Um then I mean, we're going from right to left. If I do F combine H and G and then go F and H of G. And that's the same as if I just combined G and F and then did that first and then, um then applied H and the way the best way to think about this is in terms of pictures. Alright. F will take me from here to here. G will take me from here to here. And H will take me from here to here. Right? And it doesn't matter if I, like, think of. So H combined with G is basically, um I don't have another coloured pen, but it's like basically sort of like, um sort of black boxing that the middle part there and sort of like saying this is H combined with G. And so it's like if I do F and then H combined with GH of G, um, that takes me there, whereas combining G and F is like making that a black box and basically the the the whole picture because everything is the same, it's all it's all the same. So this is another example of a semi group, Uh, because the the sorry, uh, functions with the with the function composition. This is the composition function. Um, is also associative um so a semi group is just something with with an asso associative multiplication. Um and in fact, there's a class in high school dedicated to semi groups. It's called semi group, and we denote multiplication by, um, a diamond right. Although we don't not many keyboards have diamonds. I just do less than greater than sorry. Yeah, less than greater than, um and this takes set to set to set. And then, um, in the Haskell code, it says there's a law that that diamond must be associative, and that's something we can't enforce. So in theory, I could define anything to be a member of semi group. As long as I define this this diamond operation, um, it doesn't have to meet the associative um, law, Um, in order to be to be classed as a semi group. However, um, this is sort of like something we, uh we impose at a meta level. We sort of say OK, uh, by saying that this is a This is a member of semi Group. I'm implicitly saying that this this function must be associative, and that's cos it'll it'll apply later on. Alright, So here's an example of a, um of a a say colour mixing R GB colour mixing. Um, I can define a colour to be, um, a construct, so no, you can use the same. You can use the same keyword for for the data type and the constructor. It's generally not a great idea. Unless you've only got one constructor. You can Yeah, yeah, yeah, yeah. I was like, Yeah, I was like, hang on, just sort. But it's like thinking about new type. They don't do it with a new type, but the slides don't do it in U type. Yeah, anyway, yeah. So it's a four couple of integers. Um, with the colour construction, the four top is red, green, blue and alpha. Um, and then we can define a mix a mix of these things, Um, as the multiplication operator. And what we do is we just, um, add the two colours, Uh, add the two components together and then just, um, max it out at 255 right? And so it's not hard to ch. Well, it's not. It's not. It's no nontrivial result, but you can check that this this operation, this mixing operation, um will, uh, is associative. And so then So then therefore, um, you know, colour is is a member of the semi group class. Um, and the reason why I wanted to talk about this is because monos are special kinds of semi groups. Um, and monos. Maybe a word that might be familiar to anybody that's been meing in this class. Um, we'll come back to monos. Um, well, we may maybe we'll come back to moods. Um, but what is a Monod? Right? There's the first thing you know, question. What is a monad? Well, don't worry about, you know, it's like you say monad, and you could say a list of words like, here's one of those words in that definition of a monad is a Monod. And so what is a mono? A mono is just a semi group where you've got a one where you've got something that doesn't do anything when you multiply it right. So do you take the integers with multiplication? Literally. One is the one. If you take integers with addition, your zero is the one the identity element, right? If you add zero to anything, you get the same thing back, Um, sets with union is another example of of a, um a A semi group. You can take the union of two sets. You get a another set, and union is is, um, uh, associative. What would be the what would be the the identity element of union? Yep. Empty set. Yes. Thank you. I haven't given out chocolate enough chocolate. What about, um OK, Intersection is also, um, sets with Intersection is also a semi group. It's actually a Monod. What's the What's the identity with intersection? Everything. Thank you. Yes. And then somebody said universal as well. Who said Universal? OK. Yeah. OK, that's good. Um, thank you. Oh, sorry. That's just way too low. It's good. Good that I'm coming up the stairs so I can pick that up. And a great catch. Um, yes, the universal set or or the set of everything. I mean, this is This is that's another philosophical thing that I'm not going to talk about. Um, yeah. So monos are set, uh, is a semi group equipped with identity, and so again, um, we have a Monod class. Um, and then we have this this class definition, right? I'm gonna say Monod, um is a class social site. Um, yeah. So de defining a type class, we use the type of the keyword class, and we specify what functions have to be implemented in order for an object for for a data type to be part of that, um and that class here is a parameterized class here. And then I can say, um, Monod is also a class. In fact, Monod is a subclass of the semi group class. Right? And so basically so here we've got our talking about inheritance. So if we've got a class, uh, so mono a is a cla sub subclass of semi group A. So we didn't. So if you've got Monod, you need to have a multiplication. You need to have this diamond operation. Um, and you also need to have an identity which we call MMT, which has to be a specific object in your in your set, your set. S. Um, other than that in the yes, that's the Z in the in the slides. It's the one. It's the empty set. It's the zero. In addition, um, what about strings and concatenation? Remember, strings and concatenation. Uh, what would be the what would be the identity for S for concatenation with strings? Yep. The empty string. Yep. Exactly. Um, what about lists and concatenation? Empty list. OK, good. Right. You're all on board. That's what a mono did. That's all a mono is. It's something with multiplication and a one What about functions and composition? Thanks. X FX equals X. Yes. Yeah, it's what we call the identity function. It's a function that does, Does nothing, right? And so basically, if you compose it, of course, it's not gonna do anything. Um, it's a all these things, like seem really strange. It's like going 00 is the most important number. That means literally nothing. It's like it's all the same. Like Empty set is the most important set, and it literally means that it's talking about the set that contains nothing. The empty string is the most important string cos it's the string that can it is the string that contains no values. Um, anyway, so that's what a mono is. Um, And when we come talking about mono, uh, monad right, Think back to what a mono is. Um, and see if you can see, um, at least half of that definition anyway, So, um, our colour semi group is also a Monod, right? What's the I mean, I kind of gave it away on the next slide. What's the identity colour? Black? Yep. Exactly if I mix or say 000. I haven't really defined that But it's like, yes, if I mix 0000 with everything, it's just gonna get my, my and the same colour back. Um And so we we've talked about all the all the other ones discussed previously. Alright, Now, now, the reason why I want to talk about this is because I talk about the integers. The integers with addition is a Monod. Right where you've got your addition is your operation and zero is your your identity. The integers with multiplication is also a mono where you've got your, um, different operation and a different identity element. Right? So I might want to say OK, Yeah. The integers are a mono where, um the multiplication is addition. And the the identity is is zero. And I also want to say that the integers are a mono with this because, you know, whatever and all these other things that might depend on, um, my data being my data type being a mono, um, I want to say yes that it'll apply to integers as well. But the problem is, I can't do this in high school. I can't say, um integers are of of type. Um, Monod wear this and then integers of type Monod wear that. And if I tried to do that, you can see Wow, that's let's go with my in, Let's say my Nat and I hope did I find defined naturals. I think I can do it. Yeah, OK, right. So I might say, uh, no, no, no, I won't. I won't do it here. Um, yeah. So I might want to I might want to say that na naturals are a a, um, a mono, um, in two different ways. Right. Um, but I can't do that because they basically, um if I try to do it in one way, it'll say right? Um, yeah. You, You, You you You've already said it. You've already defined what? Multiplication. You know why integers are are mono? Um And and so you only have one instance per type per class. Um, in the entire programme is this is why names spaces is somewhat important, right? And so this is this is this is this is critical. So only one instance per type per class in the entire programme. So the way you get around that in high school is you use the new type keywords. So this is the third way of defining a data type. So we had type with type synonyms. We had data sort of creating, constructing brand new ones and then new type. So new type is the is the third way. And the way a new type does. Um, so a new type decoration is a bit like it's a bit sort of like an in between between the type synonym and a um, and a data one. sorry. A A complete, completely brand new one. deal is you can only have one constructor. Um, and it can only have, uh, sorry it It must have exactly one argument. So it's like a wrapper around an existing type. Um, so that's why I say sort of in between the the the two instances and so I can say right, OK, score is is basically for all intents and purposes and integer right. But it's like a different different version of integers. Um and so I can say semi groups score is a semi group with under addition, and it's a Monod, um, using zero. But then I could say like, um, something else is, uh is also effectively an integer but it's a type. Monod, where my, um multiplication is, uh, sorry. My semi group operation is multiplication. And my mono, um, identity is one. So a new type is sort of like, Yeah, as I say, a a nice, um, a good way to present prevent mistakes. So it's like a sort of, as I say, it's a good way to sort of sit in between, um, creating your own completely brand new data type and, um and, uh, mirroring with type definitions. Sorry. Top synonyms. Um, I would touch I last on the last couple of type classes, Ord. Um, it's for ordered type types. Uh, or ord is for ordered, um, data types. So it's a bit like, um, comparable in Java. Um, and so ords has a as an ordering function right, which takes two A's and returns to bullion. What law should this satisfy? If it's like, you know, it's supposed to be an ordering your thoughts? Yep. The first argument is not equal to the second argument, actually, So this is less than or equal to, so I mean, so it sort of like represents less than or equal to so what we actually want. Um I don't know if you if those of you might remember this. Um but we talk about the the definition of AC a partial order. So partial order, right? Less than or equal to Has to be reflexive. Um anti sorry. Anti symmetric and transitive. Alright. So reflexive means that anything is less than itself, right? Anti symmetric means that if a is less than equal to B and B is less than equal to a, then A is equal to B. So the only thing that can be both less than equal to itself And so the only the only pair of things that can be um related in both directions are are is the the object which is itself and transitive is that if a is less than equal to B and B is less than equal to C, then a is less than equal to C. So things like subset relation, um is a good example of a partial order, right? Any set is a subset of itself. Um, if a is a subset of B and B is a subset of C, then a is a subset of C Um and if a is a subset of B and B is a subset of a, then A and B are equal. Alright. So partial order has to satisfy these rules. But with ordering we want to do, um, comparison. So we also need 1/4. So we actually need our order to be total. And so we need linearity. Um, so the linearity condition is that a is less than equal to B or B is less than equal to a whereas you don't have incomparable things. So the subset relation is an example of an incomparable thing. A is not a subset of the set containing B, and the set containing B is not a subset of the set containing a so a The set containing a and the second containing B are incomparable. So we don't want that. Um, and what about it? Compare everything. And so we in we we insist in the in the documentation that if, um if we're going to define the less than are equal to relation, then that less than are equal to R relation needs to be reflexive, transitive, anti metric and total or linear, uh, satisfy the linearity condition. Right? Um But again, there's no way of of enforcing that. And if you look at the actually, I did this a while back. The Java, um, compares to specification like the compares to operations This basically mirrors compares to it says in the specification compares to relation should be reflexive, transitive, anti metric and and total as well. And so but that's that's part of the specification. There's nothing preventing you from not doing that. Just that things behave. You, you sort of like have expected behaviour. And so here we it's it's like the compares to. But it's also like operator overloading, um, in C. So we sort of have that same behaviour. So we define this for our various data types. Um, FX equals Y. So, uh, so this is for all X and all Y? Why? Um Oh, yes, yes, it is inclusive. Yes. Yes. So, um, either X is equal to Y or Y is equal to X. Sorry. Either X is less than equal to Y or Y is less than equal to X or both. Yep, thanks. Morgan. Uh, both of you know OK, have more friends and then you can share. Um, yeah. What about. OK, so what about equality? Um right. So what? O? What law Should equality satisfy symmetry Y, reflexivity and transitivity. Yep. So should be, um, satisfy reflexivity transitivity and symmetry. So symmetry is the only new one out of those things. Symmetry is that if X is related to Y and Y, then Y is related to X. So if X is equal to Y, then Y is equal to X. That kind of makes sense. Um and, um, relations which satisfy these things are known as equivalence relations. And now we're hiking back to math 1081. again, You don't need to worry so much about about these things. Um, some people, though, say that equality should be literally like includes the substitution. So basically, if if X is equal to Y, then F of X is equal to F of Y for all functions. So this is what we call substitution or alpha alpha equivalents. Um, this is a more more restrictive requirement. Um, so generally we don't like it as a as a as a specification, and we want to keep things as flexible as possible. Um, but this is something you know, something worthwhile, you know? Think about it. If you want to go off and design the next version of high school. Um, right. Anyway, that's gonna conclude. I'm gonna Oh, God. I've gone way over. Sorry. Go. She must be starving. I'm starving. Um uh uh, No. Um, come and grab some food. Um, Ralph's gonna set up for the last half an hour. Um, he's gonna go through. I don't know what he's gonna go through. It's gonna be all exciting. Um, uh, he's gonna do a nice speed lecture. I think. Hopefully, it'll all be recorded, so it's all good. Um, I think are you gonna work in the ed? Um, space or you go? Whatever he does will be uploaded into the ed space at some point. Um uh, grab some food. Have a five minute break. Let let wraps that up. Um, reminder. Quiz is due on Tuesday. Quiz One is due on Tuesday. I will release Quiz two as soon as I can. And the exercise, the first exercise will be released. Um, hopefully today so that you can work on it on the weekend. Um, A A minimum. And then So you have at least one weekend to work on it. Um, and I'll decide on the exact due date when it when it's actually been let out. So you've got and you have adequate time. I believe in adequate time allocation. Hi. I was just kind of wondering what happens if you

SPEAKER 3
decide an instance of a wrong Or is it MMMT that is not, like zero or like so again, it's

SPEAKER 2
It's all part of the rules. So it's like there's nothing that says that MMT has to behave like an identity.

SPEAKER 1
What? The behaviour.

SPEAKER 2
That's right. Um, well, until you sort of like that Good question.

SPEAKER 3
Hi. Um, in the lecture code, I think it said, um, when you defined non empty, um, I was just wondering because So the first case is just it has one. And then the second case it has it says it's attached to another non empty. Does that Does that mean that we can't have it doesn't end on, like, an empty list the recursive case.

SPEAKER 2
So we have we have a single. So that 10, yes, yes, yes. And then this to an pointing to a thank you. Um, I don't know that I use that I put I put that batter pack in the pocket and right log on and see what's showing. We know what's been and normally you Yeah, yeah, yeah.

SPEAKER 0
Um, hopefully that's good enough. OK? Yeah. Um the smashing Oh, hello.

SPEAKER 1
They are come about in the summer.

SPEAKER 2
Sorry. Do you know when we're gonna get it? One hopes not, um, need a little bit of setting up, Um, and, um and because it's a new course, and basically and because, like, last week, it was completely right off. It's like I I'm on a week. Um, I need to chase up the LP. Um, And I imagine, um, What's the first lecture? You? Um, because this is weekly.

SPEAKER 1
I wanted to like, uh, this is like a whole boundary. So let's talk about mundane, like, two months time.

SPEAKER 0
Uh, do you know how to get this to work? It's, like not the touchscreens. I Oh, ok. You need you need to bash it really high, so

SPEAKER 2
that that's good.

SPEAKER 1
Um, hello.

SPEAKER 2
And I can't quite work out exactly what happened. There were Yeah.

SPEAKER 0
Interesting. Very, very interesting.

SPEAKER 2
Oh, the yeah, the assignments.

SPEAKER 1
Um, it might be a person. I I also don't want to stress and had everything

SPEAKER 2
to do with it. Like what happens in all its, uh do you? I don't know. You're happy to just use all code, Do you? Don't want to use the document camera or anything.

SPEAKER 0
Yeah, yeah, yeah. I'm happy to do that, I. I just can't get it to connect, though. Usually there's an HDM I laptop. Um, feature for that's annoying.

SPEAKER 1
We wait for hours.

SPEAKER 0
Yeah, If you haven't, it's It's pluck in here. Yeah, uh, maybe there's a different I could use this USB C maybe.

SPEAKER 2
Yeah. May I know I'm pretty sure the USB C works better than the HDM. I, um my understanding is they they've gone around and fiddled all USB CS, R, H.

SPEAKER 0
Um, OK, whatever. Oh, that's not good. I now it's just screwed up my screen. Excellent. That that's really good, But will it connect? See that? OK, connect, right. Uh, very interesting. Um, that's something, but it's not even like it's not connected to, Like, I have to click here to click here. Oh, I wonder if that's gonna, um can you do

SPEAKER 2
something with your screen? Just Can you research your screen.

SPEAKER 0
Maybe a three or something like this, because I think

SPEAKER 2
at the moment, the cursor is there.

SPEAKER 0
Yeah, so it's just It's just your cursor being.

SPEAKER 2
So what if you just change your change? Your, um Wait a second.

SPEAKER 0
Uh, yes.

SPEAKER 2
It's a bit of a debate.

SPEAKER 0
Yeah. Would it be in, like, settings? Do you think I wonder? Ok, um, what do you What sort of thing do you think it would be?

SPEAKER 2
Um, I. I won't find out a case you need to jump into this. But, um I, I would say it's like something to do with your computer and, um, the resolution of your computer.

SPEAKER 0
Right. Ok, uh, here's a dumb, dumb fix. Um, but I have So did that work flow back?

SPEAKER 1
Yeah.

SPEAKER 2
So absolutely curse around.

SPEAKER 0
Ah, that's so annoying. Um, optimise for MacBook pro.

SPEAKER 2
Yeah. Go with it.

SPEAKER 0
Hey. Yeah, Yeah, it sounds good. It sounds good.

SPEAKER 2
She'll be working on Fine.

SPEAKER 0
Alright. Super good.

SPEAKER 1
Hm?

SPEAKER 0
Yeah. No. All good. Um, yes, sir. Oh, OK. Yeah. Let me know if it ever cuts out, um, online or something. Uh, OK, Welcome back, Amber.

SPEAKER 1
All right, I know we're coming late.

SPEAKER 0
Oh, God. Cuts in and out, doesn't it, Excellency? Very nice. Hm. OK, I'm gonna hope this is stable. It's nice. Um, so we've got these. Is everyone ready? Yeah. OK, so we've got these sets of, um, practise problems. Now, um, you can see we've got this this week. One ones, which kind of go through folding and such, Um, we've got the week two ones, which are kind of going over stuff we've just learned, like in the previous, uh, little bit. Um, I wanted to bring up, um, cos I saw some people asking about, like, problems you can do on the forums. Um, I just wanted to bring up these, like, 99 H school problems. This is just like, if you want to do, like, drill style problems like just do problem after problem of, like, trying to solve, like, little recursion problems. These are, like, easy to do. Like if you want to do like the, you know, find the last element of a list or something like this or just, you know, little functions that you can write to, like, build up your skills that these are, like, quite useful. They have solutions on here? Um, so yeah, like that's, like a something you can do. Um, anyway, let's get into some of these problems. I. I imagine people haven't had, like, much of an opportunity to look at these threat. OK, for those of you have any any preferences for? Alright. Um so I, I think I'm gonna just kind of go through, um uh, like, semi chronologically, maybe skipping things here or there. Um So let's let's try this. This first one. So it says, um, use recursion to write a has full function. My sum that sums up all the elements in a list of integers. Uh, and it says feel free to use the following template. So we've got this function here. Um, it takes in a list of INTs and produces an in, and we want it to sum up all the elements in a list. Um, OK, so what's the what should be the sum of the all the elements in the empty list? Yeah. Alright. And how are we gonna do the recessive case and the yeah N plus my sum of NS right. And I hopefully have this one loaded. Yep. Uh, and we can try this out. We can go. My sum of, like 123. That's six. so pretty good. That's what we expect. And we'll put another three in there. Get nine. That's good. OK, so it says brand A has to function my product, which should I mean, you can imagine what it does. It takes a product of everything in a list. Um, so what should the type of this thing be? Yeah, um, good ants. We're gonna get an ant. And OK, what should the product of the things in the empty list be? Yeah. So it should be one. And why? Yeah, Cos it's the identity, right? If you you know, we're gonna be implementing it in a very similar way to how we did this before. Um And so if you take the product of all the things and then you put a zero at the end, it would just screw everything up, right? You would just multiply everything by zero. My product of NNS. OK, you can probably imagine how this is defined, right? It's gonna be very similar to before, but it's gonna be N times. My product of ns. OK, so th this exercise is basically to to point out that we shouldn't really have to define two functions. Yeah, uh, so what do you mean genuinely empty? Love me, sir? Yeah. So this is kind of an interesting question. I mean, the the convention is that it's that it's one in the empty case. But if you wanted to do that, then you could, um we could do something. Like we could add another case for a singleton list, Um, and have that, you know, just be produced that one element in the list, and then we could have the product of the empty list. Be zero. but, you know, this one this way is very conventional, and it draws attention to the fact that these, um definitions are very similar. Right? Um OK, so, um, we should be able to do better than this than write like, basically the same code twice. And one way we can do better is with higher order functions. Um, so let's define a slightly more general thing called my bin op. So Bin is for binary operation, and what we're gonna do is we're gonna take in a function, so either you know, plus or times or whatever we're gonna wanna do. Um, I'm gonna take in an integer and a list of integers, and we're gonna produce an integer so it should be able to just plug in times here and plug in. Plus here, um, and recover the my sun and mice product functions. Um, OK, so note here that we have an extra input Z here. What's that doing? Yeah, it's that base case. So, um, with that in mind, what might we put as our empty list? Um, yes, yes, that that it's gonna be Z. All right. And what about our recessive case? Yeah. FZ my bop seven ZNS. All right, let's mhm. What's what's happened here? Yes. Sorry. Oh, I see. All right, what's happened here? She put a double sign on with that. She put a dollar sign after the Z here. Is that what you wanna do? Uh huh. All right, So, um, let's see if this works. So let's Let's try my sum sum prime. So this is just, uh, my sum, but we've plugged in a plus here. Let's put in. I don't know. +543. We get zero. Mm. OK, And what about my products? We get one. OK, we've done something wrong. So what's Yes, Uh wait. Sorry. It's the what? Yes, why? I that uh bye. So I think it's Let me just say there's there's, like, one problem with this. There's there's one mistake here. Sorry. And then doing Yeah, well, yes, but what should we change this recursive case to do? I claim it's maybe not so hot. Yeah, yeah, and right, Not not FFZ. Right. Um so let's do this. My product of this, OK? And it's five plus four plus three. Is that 12? Yes. Sorry. And let's try my product. So what's five times? Four times 3. 60? Um seems good to me. Alright, so that's good. We've we've, you know, we got there in the end. We've got our my bop here. Um OK, so this is, like, better, better code, right? I? I think we can all agree that this is, like better than writing my sum and my product individually, but, um, we can do even better because Haskell has its kind of its own. Built in my bop called the Fold Functions are are people familiar with the fold functions, maybe from other languages or things like this. Um, yeah. So in has school. We have these things. They're called fold L, actually, maybe let's do a clear. Actually, this is something if you wanted, um if you wanna use like, um uh, like, shell functions inside the hasel terminal Just put a colon and an exclamation mark. And then there you go. You can you can clear and such. Um OK, so let's look at what fold R does, so fold R. It takes in this, um, function of two variables it takes in an initial base case. Um, I it's talking about foldable. Just read foldable here as list. Um, that's that's fine. You can define it on more general container things, but it doesn't really matter. Um, so we take a list of a S and we produce a B, and this folds from the right. So you imagine. Um, you're applying this, um, from the right, and we'll see how that works in just a second. And we also have fold R fold L. Sorry. Fold L. And it does the the same thing from the left. Ok, so let's see how this works with little example. So I'm gonna go fold, uh, fell and I'm gonna go, Maybe plus, and we'll have a base case of zero and we'll go. 1254. Alright. And that's gonna give 12. Um, if I do fold R here well, it should do the same thing because everything is very symmetric with with plus, um, so that's all the same. So let's let's just try to re reim implement these functions with the F fold R or fold L and then let's see some more. OK, so let's let's define another my sum. Maybe we'll call it my sum Prime prime. We got our in, goes into ant. And how should we define this guy? Yeah, ends again. OK, how should we define this? Well, if we want to do it with fold R I, I maybe I kind of gave it away here. You just kind of go. I'm gonna fold R of the operation I wanna use with the base case, uh, on the list. I want to apply it to Right. And what if I do it with a product again? It's going to be the same thing. Uh, we're gonna go My product, and I should make sure names don't conflict should be fold are of multiplication with my base case with ends. Right? And hopefully that should all work. And so we should have that. My product, Prime Prime, is doing the same thing as well three times Two times 16. And there we go. Ok, so, um, this is quite nice. We we have my band up kind of built in already, and it's it's, you know, very idiomatic here. Um, OK, can you think of any examples of where fold L and fold R might like Differ mhm when you have an infinite list. So it's an interesting point. I wonder how you would fold L on a on an infinite list? Um, so, yeah, this is a good point. Um, yeah, yeah. If the operation doesn't commute, Um, yeah, that that could Well, let's look at the types of these things again. So, um fold fold R, it takes in, um, it's going from the right. It takes in its base case. It takes, um, the the los Elements. And it's no sorry. Um, the more relevant point might might be a sensitivity. Here. It is gonna be the real problem. So let's let's have a look here. Let's just do a fold L of. And if we do, like exponentiation our favourite, uh, non associative operation. And maybe our base case is one. We go. 123. What's gonna happen here if we do a fold L? Well, we're starting from the left, right? And if our best case is one, we're gonna go one to the power of one to the power of two to the power of three. Right? So we should get one. Alright, Makes sense. And what about R? Well, here we should put the one at the end, right? We're gonna go. We're gonna end up doing three to the one, and then we're gonna go two to the power of three to the one, and then we're gonna go. Well, I actually have a one here, actually, as well. So maybe let's put a two here and we'll get 256 and I'll show you that. Had I done this, it would also be one right, so reasonably makes some sense. OK, so people are happy with this. I mean, it's it's stuff you may have seen before with fold, but it's it's kind of, um, how you write Nice house call. Um, yeah.

SPEAKER 2
Um the kind that it's associative, not commutiv. Could be something like, um straight.

SPEAKER 0
Yes, Yes, yes, yes. Yeah, that's that's true. So let's let's do that. So let's try. OK? So if we're gonna be if we're gonna be folding strings with concatenation, um, remember that our base case should be the empty list, right? And OK, if we wanna fold over some our strings, let's just go and and or and blah and OK, we're gonna concatenate from the left doing this, OK? And it goes and or F, DJ, blah, blah, blah, blah, blah. And if I go fold R, it gives me the same thing. So it's it's, um it really is the association that matters here. It's it's doing it. It's how the bracketing works rather than, um, swapping the order of the operation. Um, OK, cool. Do do do, um All right, so so here we've We've got this funny little fact. Um it says that these fold functions have this sort of funny property where if you you can define any function that works like stepping through lists, um, with a fold. So it says, Can we define like, map with a fold R? And can we define fold L with a fold R? This is a kind of a strange thing. Can anyone think of how you might do this? And it takes a second to to think about, but like, But let what sort of thing would you wanna do, can? Well, maybe let's start with a folder that the and let's just get the type of fold R up here because it's always nice to have the types there, so fold R. It's gonna take in some function here that's gonna involve applying F. Um, we wanna take in some base case, um, and we want to apply it to our list, so our list should probably be X's, right? Um, so that's something we can apply it to. What, our what? Our base case be here. Well, maybe the function is is will tell us our base case later on. So what should our our function do? Well, let's look at the type here. It takes in an A to a function from a to B. Sorry, It it's, um, is a two argument function, taking an A and a B and producing a B. And we've got a function F, which takes a to B. Um, we really just want to apply this F at every point. 20 ideas. Now, usually when you're folding, you're kind of squishing the entire list into something smaller rather than, you know, maintaining it as a list. So we want some function that's going to, you know, keep it as a list. Mhm. OK, do the best case first. Yeah, I. I would assume it would be two, but I'm just wondering whether it's, you know, I like to think of

SPEAKER 2
like the full function takes an element of it takes an object and that B in the definition of FR is your accumulation accumulator.

SPEAKER 1
Yeah, and the the the accumulation starts at the base

SPEAKER 2
case, and then you accumulate up. And so basically, the the the function is take the next object in the least what you've accumulated so far and create a new accumulation.

SPEAKER 0
Yeah. So what are we accumulating when we map? I mean, if you're what are you doing when you do a map? Yeah. Yeah, right. So we we probably wanna, um we want to be somehow applying F to each element here. So maybe we take in some function. Let's just take in two inputs because we need to take in two inputs, right? What can we do here? Well, we probably want to apply F to one of these, right? Cos we wanna be applying F to something. So maybe we go F of X. And how do we make sure that what we're accumulating is is a list? How do we add this onto a list? Yeah, we're gonna con right, so we can con it to the next thing we're applying it to. So maybe I'll do the Y here. Um, and if we run here, this should give something that works so we can go 145. We get 246 so that's pretty good. Does it break if we put in the empty list? No, that's nice. Um, I'm I'm a little unimaginative, unimaginative when it comes to my, uh, examples of function. So if you can think of other ones to break me out of my habits, then do four and 17. That's pretty good. Um, yeah. So? So this one. It's kind of funny. We're building up this this funny little list here. How might we do fold L? So this one's a little weird. So, yeah, you're about the list fast. So we have a we have a function in Haskell is robes. Um, what are we gonna do with that? Are Yeah. OK, so we fold our of and you just want to do the same arguments here, So maybe F and I and reverse X's. OK, so let's see how this works. So hm, Very interesting. What's happening here? So it says couldn't match Type A with B Expected. B to B to B actual B To A To B. What's going on here?
