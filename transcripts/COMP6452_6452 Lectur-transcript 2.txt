SPEAKER 0
think that Tim wanted to remind is still about one third of the students are not on the forum. There are already a couple of posts from both the staff and the students. I, I think I saw one duplicate one, but other than that, everything is good. Um, so please, please sign up and just keep an eye on, at least, like once a day, like what's going on? That will help, because you may have a question, but someone may have already an asked as well as the answer may be, there are, rather than you paste post something and just wait for one of us to answer. Um, OK, so let's let's get started. And there was a question. I think I'm going to touch that slide today as well. So if I if I summarise everything that we discussed on Monday, probably that can be summarised in two slides. So one is the goal of the Blockchain is to replace this centralised trusted third party with a network of computers that he is trying to play that role. But in this process, we don't trust any single individual node, but we trust the collective by double checking each other's work. So in order to be able to double check each other's work, we tend to replicate the ledger so everyone keeps the same data and just double check, like whatever. Whatever data that I'm recording, is it same as whatever my or some other note says that they are holding. So when you replicate the ledger, there are a bunch of problems, but probably this one helps the most. So there are actually three things can go wrong. The Bitcoin was primarily designed to deal with this problem of Alice trying to double spin her whatever currency. So Alice says something to Bob but didn't say something else to Charlie so that she ended up spending more than what she owns. So that's one problem. The other problem that we discuss is like in a large network like this, messages are gonna get dropped. Network packet is gonna get dropped, so you will have an inconsistent ledger, and the third issue is messages are also gonna get reordered. So we briefly talk about few ways of addressing this. Either you have some sort of a serialisation like one thing after another, or you assume something about time. But what ultimately matters in this particular slide, at least, is agreeing whether the transaction coming from Alice or let's say whether the transaction coming from Bob is the first one. If everyone agrees, let's say, transferring $300 as the first transaction transferring so dollars or let's say, whatever coins as the first transaction and transferring the 1002 100 coins as a second transaction. Both transactions are valid, and everyone agrees, and everyone will have a consistent ledger. But, uh, if you have a situation like one C 300 then 200,200 whereas the other one C, is 1200 then C 300. We have an inconsistent ledger, because on this side one of the transaction is gonna get rejected, whereas on the Bob's note, both transactions will be accepted. So the real problem we are trying to solve here is to make sure every node in the network agrees on a particular order of transactions. It doesn't really matter whether the transaction to transfer 300 is the first one or the transaction to transfer this 200 is the first one. Of course, a user may be unhappy But at the end of the day, network will remain consistent as far as all three nodes have the same order of transaction. So this is essentially what Bitcoin was proposed to address. So the process of getting into such agreement is called consensus jumping a bit. So consensus is the agreement among more than two parties. So generally we use the word agreement. If it is two parties beyond two, we usually call consensus, but we need to achieve consensus under unreliable communication, failed nodes and more importantly, misbehaving notes, the ones that are trying to defeat the system or game the system so we can achieve consensus algorithmically. So Bitcoin is perhaps the best protocol that was proposed at that time. So there are the Blockchain protocols now that has much better properties, much faster. But Bitcoin was the first one to give a reasonable solution. So what we are going to do here is like quickly talk about a few things like what are transactions, blocks and things like that. So at the very simplest form, a transaction would look like this. There is a sender and a receiver. So to and from who is sending and who is receiving. And there's usually some sort of a time stamp say this is sent on this day at this time and then there is like the sender's signature. So if you think of this something like a check or or if you go to a bank and you you you write a slip to get some money from the bank. So you you would say who you are. Your account number put a date and you sign at the end. So you prove to the bank who you are, so you authenticate the bank who you are through your signature. So in this space, we use digital signatures, uh, than the conventional ones. But at at the lower level in the sense bit level, things are a little bit more complicated. So it's a series of bits, so these are essential hexadecimal numbers indicating a set of bits. So I'm not going to talk about these, but the rest of later part of the latter part of the lecture, this will be a little bit clear, like so a transaction has some sort of an input and a signature. So this is how Ali or Bob proves that who they are. And here's the value of the transaction. And then who is going to receive that? So this is like the receiver. Here's an indication of the sender. This is how much and in this example, we don't see the time stamp. Yeah, keep it going. Send us to the 58. This is not a private key. Signature is generated using the private key. I'll talk about private keys, maybe like second half of the lecture. Sorry. So if you don't have previous transaction, of course you don't have a Bitcoin or anything to trans transfer. So either you become a miner and mine and get get some Cryptocurrency or you buy it from someone who already owns them. So, like you can go to a Cryptocurrency exchange, give you Australian dollars and buy either Bitcoin or anything else. So when when the network actually started, like in in When Ethereum was started, some number of ether was given at the very beginning, so that's also a possibility. So at the very onset, you can actually give Cryptocurrency to any any address or anyone that you like. It's just part of the protocol rule. So what is really happening in a Blockchain is there is an ordered set of transactions. Let's say transaction one. Transaction two So summary of those transactions and the hash of the previous blocks forms the header. So this is the block payload. What you have at the top is the header. So So here's the header. Here's the payload. So payload has a sequence or set of transactions because transaction sequence ultimately decide what is valid. What is not Remember we talk about, like bank giving you interest and then you taking money out of the ATM. How much money in your account ultimately will change on the order of those two transactions? So there's a order set of transactions and they are summarised and you also point to the previous block. So that way you always link to the block before so the very first block that was generated is called the Genesis block. So that is why I say like I said, like, if you want to freely give away Cryptocurrency at the beginning, you can define that here. So so and so owns 500 Bitcoin or so and so on. Let's say 500 E like that. So So here's the first block. After that. Here's the second block. Here's a third block and this being the latest. So anyone, any new block appearing after this will have a bunch of transactions, and it will always point to this block. So a Blockchain is a collection of blocks, a series of blocks. So the word actually came from that is a chain of blocks, um so each each of these blocks may be built by different nodes. But the more important thing is nodes agree on the content of a block. So that means, like everyone agrees, there are only two transactions. And in this order, then in this one, everyone agrees there are three or more transactions that I put a couple of dots. But what those transactions and which order are they in the block? And then So here's the latest. He is the one before. Here's the one before. So what are the transactions? What is the order of blocks and who has the right to build blocks? So I talk about what I call public permissionless Blockchains. Like ethereum and Bitcoin. Anyone can build a block, so you just download the code you deploy your node and and you can try to build the block. It's not as straightforward as that, but either you need computing power. If you are talking about Bitcoin or if you are talking about Ethereum, you will be randomly selected at some point. So then you can build a block. So ultimately, this leads to a consistent chain of blocks. Yeah, that the gesture of the transaction.

SPEAKER 1
It says all the structure of this transaction is the bio biological.

SPEAKER 0
Could you please say that again?

SPEAKER 1
The the structure of the transaction of the structure of the transaction is the micro.

SPEAKER 0
Yeah, Yeah, I'll come to that. Yeah, so we'll talk about the me. So all the stretch is the mercury is a way of summarising the transactions.

SPEAKER 1
Yeah.

SPEAKER 0
Yeah. So data structure wise, this is essentially a link list. So, uh, what happens is this sphere to be a network where each node is pretty much equal in terms of whatever their rights, but not necessarily in terms of that, there's a computing power. So everyone has the same right. If it is a public permissionless Blockchain, if it is a public permission Blockchain only a set of notes that are designated has the right to build block, but everyone else can transact. Maybe I'll move this a little bit. So everyone typically host a replica of the ledger because that is a very highly available network. So you will have, like, thousands and thousands of notes. And because of that, you can go and read from any nodes so you can read things pretty fast. But as we will learn, you will realise getting a transaction written into this ledger or this link list that we just discussed is not that straightforward. It takes some time. Oh, there's some auto animation. Ah, so how do these nodes know? Like, what are the transactions in the system? It's just you go to one of these nodes and say, Here's my transaction. Could you please include this in a block so that node will propagate that transaction to other nodes in the network using a gossip protocol? So what's the gossip protocol? Do you gossip? Gossip protocol works exactly the same way that you gossip. Someone tells you something, and then you go and tell someone else. Only thing is in these kind of networks in real world, what you said at the beginning is not what what was heard by the last person, but in these networks, the same same message that keep going from one to another. So this is a way of not broadcasting to the entire network. But the downside of gossiping is not necessarily Every node will hear the message, but that's OK as far as majority of the nodes will hear, a transaction or a block. So if you do a broadcast, it's too expensive to do that yet doesn't mean that it's basically the same

SPEAKER 1
as broadcasting. Uh, if one. If a single node can communicate this message to one, does it mean that it would share the same message to all of the neighbouring notes to you to a

SPEAKER 0
subset. So let's say if it is a gossip, you're not gonna tell everyone that you know so same idea here. So, in a broadcast, you would tell everyone that you know of, does it involve some sort of or something? Not in these networks, but generally in gossip protocols. You can do that. So the general idea is, if you try to broadcast everyone broadcasting, it's going to be costly. So these are more passive way of doing it down the good side. It is more less bandwidth consuming. The downside is it takes time to propagate as well as not necessarily everyone will get it. But that's OK, because at least we know that these networks work because you tend to gossip to few nodes. So, for example, the node that we are running at any given time we only try to connect to only 25 nodes in the network, though there are 10,000 plus. So you don't need to. OK, so what about this Skip A slide? Don't think so. Yeah. So what do you think? Which of these statements are statement or statements are true about Blockchain? Do we trust each node in the network? No, we don't trust any single note. We trust the collective. What about the second one? The process of building a block is called mining. Sorry. Yeah, actually had a We gave this as part of the quiz, I think not last year, Year before and so don't actually argue because when Ethereum changed to Ethereum version two so they ran what is called proof of work in proof of work work proof of work world. We call them mining, but Ethereum two specifically want to distinguish themselves saying we are no longer doing that, so they call it validation. So whether you call it mining validation general idea is like if someone is building a block, they are either called mining or validation. So don't worry about so much about the terminology. But generally the process of building a block is called validation. No mining or or something similar. It's just people invent different words to say we are different from others. Um, third part so permissions cannot be used with public Blockchains false because you can have public permission or permission less last plot. Um, a transaction can be altered by modifying only the block that contains the transaction. So if you look at this diagram, what do you think? False? Because if I change something here, that means my hash is gonna change. And then this one is already point to my original hash. This link is gonna be broken, so I need to fix that to appear that I'm also part of the network. Yeah, you can explain why he is not God. Why? Ok, so that's because that we don't trust individual nodes because in Bitcoin or Ethereum or any other network public network, I don't know who is running the nodes even and I don't have any trust on those new individuals, and they may be motivated for various reasons. So we don't trust any single node. So this is so I think I briefly talk about this. This is the cost of lack of trust in finance. People try to establish trust If you can't establish trust, you always use third parties, and there's a cost of using third parties. So in in in Blockchain world, we try to get rid of that third party and somehow established a trust. But that, of course, lead to a more inefficient solution. Like if you if you can solve a problem like some sort of a transaction between two people, solve that if you if you if you trust them, you can definitely solve that using a simple database solution. But here the thing is, we don't know who is Alice. We don't know who is Bob, and there are some bit strings, so that's that's why so we don't trust individual nodes. We trust the protocol that that everyone check it because again, why should everyone do the correct thing? That's that's pretty much game theory because let's say if if I own, let's say 10 eat. If I'm running a node, I don't want the network to misbehave because the value of my 10 metre will go down when the network misbehaves. So this is this is about, like so this this in Italian, we call it proof of steak. So you want to make sure networks behave correctly because you have an interest or you have incentives to make sure that your assets are valued at a higher price. Not that the value goes down, so in a way, like Bitcoin or BLOCKCHAINS are not just technical systems. There's quite a lot of finance game theory behind this, and that's probably why this became this system, like 10 years ago, 15 years ago. If someone came up with the technology behind these incentives without these intensive incentives, probably that technology is dead by now. You to answer the question? Yep. OK, so very briefly when when you, of course, you can do everything on a Blockchain like if you have only digital things like nfts that are amount to a digital, Let's say somehow linked to a digital photograph. You can do everything on the digital world. But there are quite a lot of things that are not not digital. So this is where Blockchain becomes part of a larger software system. Maybe, let's say, to trace things in a supply chain. So let's say if you go to woollies or call and if you if you see, let's say some sort of a container that says 85% recycled plastic, how do you know that it could just be a claim? What do you call greenwashing? Just someone trying to put that label to sell their product? Or it could actually be a valid claim as well. So in those kind of scenarios, Blockchains are very useful in sharing such information. Um, the thing is, is. But if you do this when you build such applications, you may want to reveal certain things but also hide certain things. So you may be happy to say so and so and so sold like 10 units of whatever Alice sold 10. Let's say 10 baskets of no basket is probably not good. Let's say Alice sold 10 tonnes of corn to Bob. But Ali does, or Bob does not want to know want to share the price of that transaction. So they are. They are generally OK to share the volume, but not the price. But some some industries. They would even say volume is too much to be exposed as well, because it can be business sensitive. On the other hand, like some some of these announcements like this example of, let's say, 85% recycled plastic, that's that's pretty much a bragging right for a business. So you may be happy to put those claims on a public network, but not necessarily who gave you plastic or at what price. So those are the private information. So we need to deal with many of these challenges when designing Blockchain based systems. And like part of this class, we will ended up discussing some of these things, like when to use a Blockchain. If you can solve a problem without using a Blockchain, please do that because Blockchain comes with own set of challenges. But there are certain problems. Blockchains are pretty good at solving. Like if Alice and Bob never knows each other if they want to transact and be sure that whatever Alice give to Bob and whatever Bob gives to Alice is gonna be is gonna happen without a problem. Like one party does not run with both the things then Blockchains are good. Good at doing that, then the other question is OK, which Blockchain platforms to you. So there is, like, Bitcoin and ethereum and algorithm and things like that that are well known. But there are so many other like there are thousands of Blockchains. If you talk about public ones, even in the enterprise world like there's hyperedge fabric, there's Ethereum. Quorum. Um, there's R three coda. Uh, what else is there? There is, um, there's another one from VM Ware, and Microsoft has their own version of it. So there are so many Blockchains. So it's not straightforward to figure out which one to use. But in this class, we will primarily work on Ethereum because if you know Ethereum, that means you know quite a lot of other things. Because ethereum what are called things like er 20 ethereum improvement protocol 20 like that's a token standard. So there are quite a lot of things that are happening in the ethereum, or solidity space that everyone consider as the standards. There are quite a lot of tools, then the other thing is, how are you going to resolve some of these trade offs, like when you have high transparency, you don't have privacy, so but some some businesses needs that. So how do you find that balance? So those are some of the difficult questions to answer. Other thing is like immutability versus propriety information, or even like upgrading like because smart contracts are immutable. If you if you have a bug or if you have an issue in them, it's very difficult to upgrade them. It's not that it's impossible to upgrade, but you need to plan for upgrades in advance. If you don't plan for upgrading, then you can't upgrade unless, like, let's say, you somehow reconstruct all your data and things like that. So then again, there are other things, like in terms of flexibility, sim, simplicity and all of those. Another interesting challenge that you will probably see feel in the Project two is like What do you want to keep on chain versus off chain? So when I say on chain block chain on the Blockchain is what we call on chain or on ledger off. The Blockchain is what we call off chain or off ledger outside the Blockchain. So usually you should not put a lot of data on a Blockchain. They're not designed for that. So you need to take a decision on which piece of information which piece of data goes into the Blockchain get recorded. Whereas which piece says somewhere outside, maybe on a distributed file system or on some conventional database. So other thing is like how you integrate them with so many other components. So there are a bunch of properties. So these are what I call software qualities or nonfunctional properties of software systems. And here we are looking at, like few properties and how Blockchains stack against those properties. So Blockchains have what is called high integrity. That means like it's extremely difficult for someone to modify data written onto a Blockchain, whereas if it is a database, if you if you somehow pass through the access control, you can go and update that and nobody else would know. So there is high integrity and high non repudiation, so repudiation in the sense someone is able to deny that they didn't that they didn't do something, whereas because you sign your transactions using a digital signature, whatever you do is recorded to say, at least to say, this particular digital signature signed and send this transaction. Of course, your digital signature may be stolen by someone that's that's a different problem. But at least there is a recording of what has taken place. So if anyone updates account balance on a database, if as far as you log into the database, there may not be even a log entry. Someone log into the database and updated some sort of an entry, whereas on a Blockchain every transaction is recorded. Because of that, there is a recording of like whatever took place. It's pretty good in terms of reading, but pretty slow. When it comes to writing. You can go to any of the let's say, 10,000 nodes and read what is on the Blockchain. But you can only get your transaction through one of these blocks, so it's extremely inefficient. When it comes to writing the latency, that means a delay to read something read is pretty fast writing could be seconds to minutes, two hours, two days, depending on how much transaction fees you are willing to pay. We'll talk about them as we go on. Blockchains are mostly about transparency, so they are not good at when it comes to confidentiality are of all privacy because of that. So in in security like some, sometimes you may hear that people say Blockchains are secure. But at least in information security, security means three things. CIA, confidentiality, integrity and availability. So if you look at confidentiality, low negative integrity is high. Availability is generally high, at least for res, right? Sometimes people differentiate. Sometimes people don't. So in that sense block, it's not technically correct to say Blockchains are secure because they are. They only have high integrity and high availability, but not confidentiality. Uh, they are hard to modify because it comes of high integrity. If something is having high integrity, it becomes difficult to modify. They have throughput, so throughput is essentially like number of transactions per second. They have pretty low throughput, so Bitcoin throughput is about seven transactions per second, whereas Visa MasterCard during the Christmas season runs almost like 100,000 transactions per second. So there are other Blockchains like red belly, which is an Australian Blockchain, which could do very close to like 100,000 transactions per second. But there are certain under certain conditions only. But generally their throughput is lower compared to conventional databases, and they are not good at handling large amount volumes of data. So when you put this plus and minuses, these are against like conventional information systems compared to databases, throughput of a Blockchain is low compared to a database. Availability of a Blockchain is high because database may have only 23 replicas maximum. Whereas here we are talking about 10,000 plus replicas. Yeah, so you're saying a Blockchain is not secure because it's not not in the information security context. We don't consider it to be secure. So, like, let's say if one of my students write it in a paper like saying Blockchain is secure, I will always go and correct to say Blockchain has higher integrity and availability, but low, confidential or sometimes we just drop the sentence. So in in information security, in the sense like computer security, there is a very clear definition of what we mean by security at least well accepted definition, which is essentially what is called the CIA Triad, Essentially saying whether a system has high confidentiality, high integrity and high availability. So Blockchain only has two of those three. That's why it is not wrong to say, but security people won't like it. So the the challenge is when you build systems, how you combine these with other systems, somehow you still deal with some of those negative ones. So, for example, I said, like you can keep data off the Blockchain. So if you don't try to write a lot of data to a Blockchain but still write that off chain, you may still be able to come up with a good solution that you can handle data large volume of data. So finding that balance is essentially what we wanna be able to do. So smart contracts. Uh, if you have already done at least out of the lab, you have written the offer a smart contract, at least part of it. So there are essentially programmes that are written and deployed and executed on a Blockchain. Only thing is, it doesn't run on a single computer. It will run everywhere. Pretty much so. It's a user defined code deployed and executed on the whole network, not necessarily exactly at the same time, but within a certain time frame. When your transaction get included at the very simplest level, it can be seen as some sort of a bunch of if and then else kind of conditions that achieve something. So, for example, let's say in as in like trading, you can code your smart contract to hold and manage assets. Anyone heard of something called Automated Market Makers, or AMs can you give, like a simple definition of what is an AM? Requires the Yeah, yeah, but go a little bit more simple. What is? I don't think everyone knows what is liquidity. Basically a lot of people. Yeah, so so like, let's say if you if you if you have some other currency, you can give that currency and get you can get Australian dollars. So automated market maker is essential. So that's a That's what is called a, uh, foreign currency exchange. So whereas automated market maker is something like that, where you can give one type of Cryptocurrency or a token and get something else but there's no human behind that it is just a piece of code that will decide the price. So So if you go and ask OK, I have, like, let's say, five Singapore dollars. How many Australian dollars can I get that piece of code? Decide how much you're gonna get? Um, whereas in insurance, it could be like, uh, various decisions like, Let's say you can couple this with some sort of an IU device and you can have, let's say, insurance for farmers. If the national weather services, let's say report, hail event in a certain region. Let's say all the farmers in that area automatically get some, um, can make an insurance claim on it so you can automate certain things. So this is why sometimes people also say smart contracts execute automatically, automatically executing smart contracts. That's not quite true in the sense they need to be still triggered by something else. But of course, they can automate that payout, the transactions and things like. So that's why people say smart contracts automate things again. People who talk about the specifics say that's not a correct statement. Smart contracts can help automate things, but execution of the smart contract has to be always triggered by some sort of a transaction. So let's say if the if the IO sensor or the National Weather Services send a transaction to the Ethereum and say on this this area this time of the day there was a hail event. That's the trigger. So you need that to be able to compensate the farmers. Ah, so we can put various forms of obligations on in the code written. So that's why people talk about whether smart contracts are contracts. But we will talk about that, uh, on next Monday. The key thing to understand is because Blockchain is immutable. Once a piece of code is deployed, it is immutable, Uh, and and it remains so so you had always trigger the execution using a transaction. So there are three primary roles, but in this diagram, we have 1/4 1. We can also look at the way that a Blockchain a what I call modern Blockchain. So let's say second generation Blockchains, at least in a software architecture context, Blockchain can work as a storage element so essentially like a database, it can store data. The second one is it can work as a computational element or a computational platform. So this is where you you run. This ls conditions on a smart contract, so it allows you to execute a programme on a Blockchain. It can also be a communication mechanism in the sense, let's say Alice can pay Bob. But Alice does not necessarily need to go and tell Bob explicitly that I paid Alice send a transaction. Once that transaction is included in a block block, Bob May can get a notification of that. So even on a supply chain, you can write the data. A supplier can write the data so that that is visible to everyone else in the supply chain, so you don't necessarily need explicit communication simply because whatever you write is visible to others. So that's why we call Blockchain can also be as a communication mechanism and the last one asset management and control mechanism. It's actually come because of the first two. But some platforms, I think even algorithm is like this. They have explicit features to support tokenization of assets like you can what are called native tokens. So there are inbuilt features to create tokens in the sense like you can create your own Cryptocurrency, give it a name and start transacting. But it actually comes because the Blockchain is going to keep track of the ownership of, Like, Who Alice owns. How much Bob Bones, How much like that as well as then the logic. The smart contract that will decide under what conditions? Alice. Let's say five tokens would go to Bob. So when you design a software system around the Blockchain, you can think of it as a story way of storing way of computing way of communicating or or even this one. So I'm not very particular whether you look at it as three things or four things, but that's possible. But the thing is, somehow Blockchain need to be part of this whole ecosystem in the sense it will need to connect to databases that are outside. It will need to connect to various sensors and things like that, or or some old systems. So part of this class is actually about like how you design these applications so that Blockchain can interact with them. Now, if you talk about things like this decentralised finance or non fungible tokens, it's mostly in that Blockchain space. But there are a lot of applications like supply chains or or let's say, if you want to do conventional finance and things like that that really require you to somehow connect Blockchains with some existing platforms. So the part of this class is actually about designing applications where you not only have a Blockchain, but that Blockchain is also going to be, let's say, connected to some database or some sort of a user input and things like that. Now the thing is, uh, there can still be some challenges in the sense, like when you send the transactions, there can be a different behaviours than you predict. It's not because it cannot be predicted. It's just because you are competing with other actors. So we talk about an automated market maker. So the price that the automated market maker decide always depends on what the transactions are doing. So if some other transaction get included before your transaction, price is gonna change. So if I go and ask the automated market maker, tell me how much I'm gonna get. If I give let's say, $5 it will tell you a price, but if you actually do when, By the time you actually do the transaction, you may get a slightly different value simply because someone else has already transacted. And that has changed the state. There can be a situation where it's difficult to detect transaction failures or predict transaction failures. And, of course, sometimes there are things like people double click, and that becomes two transactions. There are ways to do it or prevent them, but can happen. Um, so other thing is at least early days. A lot of there were quite a lot of security issues. People are getting to know those issues and fixing them. So it's quite easy to like execute someone else's transaction or smart contract or terminate those smart contracts. So, like at least early days like here's just some statistics. 7% of the smart contracts can be terminated without any problem. So it's not your smart contract, but you just go and terminate someone else as well. So, for for a long time, Ethereum allows trans smart contracts to be deleted or deactivated, but they no longer allow that simply because it's it's too risky. Other thing is like because it's an immutable platform. Failures tend to be permanent. Now, if you if you send your money to a wrong bank account, at least you can go behind the bank. As far as the other party has not run away with money, you miss your bank may still be able to talk to the other bank and get that money recovered. But there's nothing like that here unless if it is a very significant event like, let's say, I think this was in 2017. Fairly early days for Ethereum We are $60 million worth of ether was stolen from a smart contract called Dow Decentralised Autonomous Organisations. So they were essentially collecting money to run a business in the sense invest in other smart contracts and somehow found a way to get this money out. So early days $60 million of US dollars is very significant, so they decide to change the protocol rules. So this is what it is called a hard fork. So while the network was supposed to be immutable, uh, there was general consensus that we should update the protocol rules and whatever the I think it's about 45,000. I don't remember exactly how many either they decide to essentially cancel out that transaction. Actually, there were multiple transactions. They decide to cancel out those transaction. So what essentially happened was the software was updated, certainly at a certain time that that is actually decided by block numbers, not clock time. Let's say block 1,000,001. Everyone in the network decides. So let's say whoever the attacker account was, let's say Alice was the attacker. Let's say Alice has 10,000 eaters simply because of this attack. They just decide to change Alice, balance to zero and give that let's say ether to whoever Lo who lost that. So they managed to recover most of it through this. But there was some seal. Still, some ether was lost. So this is essentially by rewriting the protocol rules. Only thing is, if today's scenario like if somebody loses $60 million on a several billion dollar platform, nobody really care. It's actually not probably billions now, almost Australian, so don't expect, like if you lose 60 million to recover today. But at least that happens in 2017. So so So what you need to understand is like there can be issues and and if you mess up, that's your problem, not the network problem. So this is where you need to be very careful when you write smart contracts to make sure you have a way of recovering if something goes wrong. But mainly because every random person thinks they can run a new decentralised application by writing a smart contract, and they don't necessarily understand the implications of that. So there are a few things to understand what are called myths. Blockchain cannot solve every problem. It's it's it's a database. Essentially, it is a massive database with some attached logic. So logic comes from the smart contracts, so that allows you to do very interesting things, then trust less well, we need to trust something, and what we are trusting is the code. So remember, I said, we don't trust a single node. We trust we we we trust the collective behaviour. But that collective behaviour comes from the code. So that is why, like when the Daw attack happens, they decide to change the code because that was the correct thing to do, morally correct thing to do. But there were people who didn't like this idea because Blockchains was supposed to be immutable, and they decide not to run that updated code and that forms what is called Ethereum Classic. So somewhere around 2017, Ethereum was split into two separate networks. One is the Ethereum that we know. The other one is still there. It's called Ethereum Classic, so that's just Ethereum classic post form by people who decide. No, we're not going to run this new piece of code because that is against the whole idea of being immutable. But if you if you see the reality Ethereum classic, I think still under $50 whereas Ethereum is $5000. So a lot of people went with the correct thing to do. Not necessarily. The code is correct all the time, secure in the sense that is actually what I talk about. It's not. There's no confidentiality. It has the other two aspects. Smart contracts are legal contracts. Probably no lawyer will agree. But of course, smart contracts can help you execute part of a legal contract. So certain parts of the legal contract let's say you are supposed to pay people under various conditions. Of course, you can codify them and put them in a smart contract, but smart contract itself Probably not a legal contract. At least not for the moment. No, I don't think any country recognises that. Um well, immutable. It usually offers what is called probabilistic immutability. We'll talk about that. But at least we saw that with the DAO attack, the whole idea of immutability was lost. But that is still through community consensus. With a lot of people deciding that they are happy to upgrade their software to fix that attack. They are inherently unsalable. Most Blockchains are. But I said like Red belly can do about 100,000 transactions. There are a few others that claims they can go close to that. So they are getting there. Uh, another thing is they used to waste so much electricity. Bitcoin is still the case, but not Ethereum anymore. So things are improving and and I think maybe I'll go another one. Some Blockchains would even claim they are carbon negative. It simply because they offset their carbon by paying someone the last one is beneficial will be adopted. So Blockchain a lot of people would say here is a technology looking for a problem. True to a certain extent, But, uh, it's always tricky to adopt new technologies and particularly ones that change a lot of things because Blockchain is a mix of technology, finance, law and all of that. So it's very difficult to change just technology because it will have implications on finance side of it as well as legal side of it. Um, so it depends on who you talk to, so some people will think like Blockchain is gonna change everything. Some people will say Blockchain is not gonna change anything but I. I think the sweet spot is somewhere in between is just you need to figure out which application that you want to apply. Then there are three interesting paradox. At least three. I would say These are not the only ones now. So particularly in my work, we have seen this like more transparency. I want more transparency, but not about me. I want to know what everyone else is doing, but I don't want to tell what I'm doing. So this is the general problem in a supply chain like to be able to let's say this bottle has 85% recycled plastic. I need to expose certain data, but in that process, I'm not willing to expose, like who is providing me plastic at what price and things like that. So it's a challenge. On the other hand, things like like like most of these public Blockchains use what are called pseudonymous addresses. These are not bound to anyone's name or address or anything like that is just a big string 160 bits, ones and zeros. So that gives you a certain level of anonymity. But of course, someone can try to link that address to an IP address and somehow trace it. It's possible, um so Well, while they try to be anonymous, regulators won't like KYZ because they won't KYZ. What is KYZ? Yeah, no, your customer. So have you proved KYC in Australia? Anyone heard of these 100 points? Identifiers, you need your passport and a bank card or something like that. So in Australia, there is like if you if you have something like an Australian passport, you get a certain number of points. If you have a foreign passport, you get a little bit less so. So like that you can give multiple identification documents to, like, prove who you are so Usually you need two to get that 100. So that's why sometimes when you go to a bank or service New South Wales or something like that, they would not just ask for your ID. They may ask for your debit card or credit card or something like that. So they want to know who you are because there are tax implications. Then there are like counterterrorism financing, so that's so with pseudonymous addresses that becomes a problem. So this is one place that the convenience, the privacy, does not go well against the know your customer requirements or regulatory requirements. Um, so a lot of commercial applications won't run on public Blockchain simply because they are through transparent. The other thing is, consensus does not give you agreement. In the sense. There are a lot of other questions you need to answer, like who is going to pay for this system? Who is going to maintain notes? Who is gonna update code? So your agreement on data on the Blockchain does not necessarily directly translate into business agreements. So there still need to be other things happening in the sense legal things happening or business agreements happening to kind of supplement these. Another interesting thing is future of Blockchain Adoption is off chain. Yes, Blockchain can do quite a lot of things only on chain, but it becomes a lot more useful when you connect things with the real world. But the problem is, there are called this parity problems what is called digital, physical or physical, digital and legal parity. So, for example, you may have 10,000 tonnes of aluminium sitting in a warehouse, so you can very easily tokenize that you can create a digital token to represent your 10,000 aluminium that sits in a warehouse. But transferring that digital token from Alice to Bob does not mean Bob got hold of that 10,000 aluminium sitting in that warehouse. On the other hand, Charlie may have run with it, and both Bob and Alice doesn't know. So there is a problem, always this linking this physical world to the virtual Blockchain world and particularly there is what is happening in what I call Layer two. So there are limitations on, particularly on public Blockchains that you cannot make them faster or reduce their latency. So there's another layer that is acting on behalf of on top of that, what is called Layer two So like layer one, is like the public Blockchain like, Let's say thee layer two is another Blockchain that is somehow linked to the public Blockchain. It doesn't have the same level of security, but it is pretty good in terms of transaction fees in the sense low transaction fees and high performance. So so you compromise the security to get better convenience and low fees, and even that is what Ethereum is really pushing. So Ethereum has kind of given up, saying, Of course we are going to improve performance. But our focus is more on improving layer two because layer two can scale much better compared to the native Blockchain platform. So because of that, we are no longer talking only on things that are happening entirely on Blockchain. I think this is my I cannot make answers. So what do you think about these? Blockchain can store large volumes of data. They are not designed for these and they will be pretty bad if you try to do that and with seven transactions per second, you cannot store a lot. And on Bitcoin even a single transaction at the maximum can be about one. K data can be read faster by writing is slow true, but we will see why this is the case. As we go on, data on a Blockchain is secure. False. No confidentiality. So So in this class, let's go with the statement. But in a general conversation, it's OK to accept this statement, but not not. Technically, it's impossible to correct errors in data yes or no? Oh, no.

SPEAKER 1
Hm.

SPEAKER 0
It's possible, but very hard to I don't even know what I said there. It depends on how you argue so sometimes. Like, don't worry in the quiz. Sometimes we may ask. So like, give me a reason. This is something you can actually argue in two ways. Let's say, of course, you gonna wipe off things on a Blockchain to correct things. So this is not like the ledger. You take an eraser and wipe it off, but you can always have a reverse transaction, like what the banks does. If they do a mistake, they will. They will always have another transaction to correct it. Not that they are gonna go and wipe off, so it's it's possible to correct. But It's not just it's not by wiping off it's just sending another transaction, but not necessarily always, uh, the both the data and the rules that government manipulation of data can be specified in a smart contract. Yes, yeah. Um, let's see, what's the time? It's almost two. So let's take a five minute break and then we can continue, you know?

SPEAKER 1
OK, go. So OK, um, so get there. OK? Yeah. Same. So Yeah, so I was just looking at my reason

SPEAKER 0
for this in this one. I've been actually thinking of something like the DAO attack and how it was corrected. But don't worry. Like we won't give a question like this or if you give a question that you can either way, argue there's usually, like a text box to say, justify your argument So you can you can talk about it one way or another. OK, so we'll we'll start on this second topic Blockchain platforms. I'm a little bit behind compared to what I was hoping I will cover. But what do you feel like the face? Me are moving on Too slow. Too fast. OK, Too fast, Too slow. Ok, ok, OK. Uh so What I'm gonna do now is to talk about these three Blockchain platforms. Probably not hyperedge fabric today, maybe next Monday. But before that, I need to kind of make sure you understand a few terms like digital signatures, that there was a question around Merkel trees and things like that. Oh, just give me a second. It's my son. I don't have any idea.

SPEAKER 1
Yeah, we got him.

SPEAKER 0
So we already see the use of hash functions here. That's that's how we summarise all of those transactions. And then we use this hash. No, this hash is linked. Oh, wait. Yeah, The previous hash is used here, so the question is, what's what's the hash or hash function? At the simplest level, a hash function takes some sort of an input and run through an algorithm like there are a bunch of algorithms like this and generates an output that is of a certain fixed size. So fairly small. Let's say you can take a five megabyte document and generate a 64 bit hash, so this is a way of summarising or, let's say, taking a fingerprint of large volume of data. So, for example, let's say if your input happen to be Fox. Once you run through the cry, whatever hash function, let's say you get a certain bit straight. And then if you extend that string the red fox, whatever, then it changes. But then, if you if you just see here, there's a typo, just one character different. But if you notice here, there's a considerable difference in the corresponding hash value. So essentially a hash function maps an arbitrary size data input to a fixed size output, so the return value is called the hash value or the hash code. The Dodger simply just hash or we just call hash and and there are a bunch of algorithms to use. So in the Blockchain space, you will probably find, like such or such three being the most common. But if you go to a security class, you will probably first talk about something like MD five hash function so most Blockchains uses, or three with either 100 and 60 or 256 bits hash, depending on what they are doing. So what they essentially try to do is with the hash function. Oh, you can summarise all of those transactions into a single value. No, somehow the keyboard is not responding, but there are a few properties that are important when you choose a hash function. Hash function must be deterministic in the sense. If you always give the same input, it must always give you the same output. And ideally, a small change in the input like this one. The red fox over versus OE should ideally produce a noticeable change in the output. So these kind of hash functions are called consistent hashing. There are other forms of hash functions with different properties. There is what is called locality preserving. Hashing. Um, there's another one came chameleon hashing like that. There are a bunch of others, but the generally ones that we use here, they need to have this property called consistent hashing. Ideally, it should be quick to compute the hash value of a given input because if you spend five minutes calculating the hash function hash value, that's not good. And these functions are one way in the sense. Given an input, we can find output on my back. But given this, we should not be able to figure out what is this. So the input space is quite larger compared to the output space. So let's say if you have 160 bit output, there are 22 to the above 160 possibilities. That's big, but you may be summarising a five megabyte document, which is what? Two to the power? Uh, no, not Yeah. Two to the power 30. About 30. 32. No, no, wait. I got it wrong. Yeah, to about 32 verses. Wait, What am I talking about? I got it wrong. Yeah. So the hash space is 102 to about 100 and 60 but five megabytes is essentially your input space. So eight bits a bite. 1,000,000, 24 of them a kilo. Byte like that. Um, what else is OK? So this one way property is extremely important. Otherwise, what will happen is someone can try to generate a new transaction with the same hash. So whole idea is like when you have this chain of blocks, when you have this chain of blocks, you should not be able to chain a transaction. But given a smart given a hash value, if you can figure out what the original data was, you have a problem because they can try to generate another one with the same hash value. So that's why that one way mapping is very important. And the other thing is, ideally, it should be impossible to find two different inputs having the same hash value, like two separate documents or two separate inputs, resulting in the same hash value. If that happens, we call it a hash coalition, and that's probably the end of the use of that particular hash function. So, for example, let's say, if you had only 64 bits, you have to about 64 possible combinations. So there is a much higher chance of a hash collision here, compared to let's say, something like two to about 160 something like 256 is even rare. So this is a probabilistic game, pretty much where you are hoping even though you may hash billions and billions of transactions, true, transactions will not ended up with the same hash function. So far. That has not happened. That doesn't mean it cannot happen. It's just the solution. Space is so large that it's extremely rare, so probably stick terms like 0.00. I don't know. Maybe, let's say 100 zeros, then one. Maybe something like that. You can calculate the actual value so they they rely on this fact, but not that it is impossible to have a hash coalition. But there was this question about her meal tree. Now the thing is, you can just lump all the transactions together and generate a hash value. So let's say you take all the transactions in a block concatenate them, which is just a bit string and generate a hash value. But most Blockchains use this idea of what is called a Merkle tree. So you take each transaction and it's hash. So essentially the transaction hash hash of the transaction is its transaction identifier or ID. Then you take a pair of them pair out those hashes and hash hash again. So hash coming from this side hash coming from this side combined concatenated together, then hashed. Then again, hash coming from this side and this side hash like that. So you have this tree of hashes. So what happens is now you can summarise all of those eight transactions using a single value, even if one of the bits here changes that route has is gonna change. That's the whole idea of consistent hashing. If something in the input changes, the output should change. So here's a nice way of summarising. Quite a lot of data using a single hash. That's that's one thing. The other thing is, if you want to verify whether your transaction let's say Transaction six was included in a block, you don't need to worry about everything else. You only need to worry about this branch. So as far as you have access to this hash, you can verify this hash is correct. As far as you have access to that hash, you can verify that that part is correct. As far as you have this side, this hash you can verify. So, in order to verify what you need is 123 things you don't need the whole three to even verify. Yeah, go ahead. It is hashing again and again. So you go up the tree, the binary tree by hashing like, uh, it has It's the other way around. So we now concatenate and hash again, con and hash again. Please. You're going there. You are going down here we are going up. So? So here's the idea. Here is you just represent large volume of data using a single value. If any of that data changes, your root has root of the Merkel tree would change so a little bit about public key cryptography. How many of you have used a digital signature, or at least a private public key, to log into a machine or something like that one, 23. So, like if if you create the key file and if you assist into a node or even, let's say if you have a GT account, you can upload your key to G tub and then come like using a command line you can just authenticate rather than using your password. So the idea is you have a cryptographic system that uses 22 keys. One of these keys are essentially a random number that you generate under certain assumptions, and then he used that key to generate the other one. Usually it doesn't matter which one you consider as the public or the private, but the idea is one of those keys you will protect in the sense you don't tell anyone else. The other one you publicly disseminate. Um so the one that you typically tell other people is called the public key. The one that you keep with you is the private key. So this is what is called a symmetric crypt, not Cryptocurrency cryptographic system. Whereas you have symmetric crypto cryptography, the same key that is used to encrypt as LSD crypt. But here the difference is, if you encrypt something with one key, you need the other key to decrypt. Yeah, so you need to protect your key and where there are various algorithms in this space. But the first one to do this or the most popular first one to do this was RSA. RSA has sort of lost its interest now because of ECC elliptical curve cryptography, because EC gives you a much stronger crypto system for a shorter key. So, for example, like 384 bit ECC key is security device is effect same as almost like 4096 bit RS a key. It's just the algorithmic properties are different, but RS is still being used. So you have different algorithms and different key lanes. General idea is if your key is longer it's It's a more secure system because anyone trying to break in, like let's say, if someone wants to try all possible combinations of keys so here, only two to the power 128 is still big, but much smaller compared, let's say two to about 4096 combinations to try. So these are heavily used in Blockchains, and this is how you actually authenticate your transaction onto the Blockchain. You sign your transaction using your private key and the Blockchain. Keep track of your account balances, like how much either you have based on your public key. It's a little bit more complicated than that. Like, let's say, for example, in Ethereum, they don't directly use your public key, which is 256 bits. They take part of the public key by running through an algorithm only take 160 bits out of it, so your actual private and public keys in Ethereum are 256 bits long, but your account number is only 160 bits, but it is still tied up to your public key. OK, now, if you're talking about, uh and sending an encrypted message. So Bob wants to send a secret message to Alice Bob. Find the message with Alice Public. So Alice Public Key should be known by others who wants to securely communicate with Alice. So Bob encrypt the message with Alice Public Key so that only Alice can open that with her private key. Whereas if you if you shop the two keys, what will happen is Bob can encrypt still, but everyone else can read the message because they are supposed to know, like generally, people would know your public. So the order of the two keys are very important. So if you are trying to securely communicate with someone, you should be like encrypting that message with their public key so that they can use their private key to open it because they are the only ones that should be able to open it. But if you are talking about digital signatures, the order is the other way around. Let's say Alice, sign something with her private key because you should be the only one to sign as you, but everyone else should be able to verify that it was signed by Alice so Alice signed with the private key. Everyone else in the network verifies that signature using Alice publicly. So when you create an account like when you create an account on meta mas meta mass actually does not upload your public key onto the Blockchain. What happens is when you send a transaction, the transaction will only include your public key. And the Ethereum nodes can just use that public key to verify whether the transaction is signed by using a corresponding private key. You don't need to know about the private key. What you just need to do is when you try. So essentially, this is again, like decrypting. If you decrypt with the public key, you should be able to figure out what data was signed or what data was encrypted so you can use the same algorithm to sign sign, sign. O encrypt. It's just the order of the keys are different. So just just remember that if you, um if you sign with the pub public key, you are demonstrating that No, if you sign with the public key, that's usually for encryption, because whoever with the private key can open it. But if you are trying to demonstrate who you are, authenticate yourself, then you need to sign with your private key. So what happens in this example is, let's say you have five Bitcoin that you, Alice is transferring to Bob. So Alice need to sign with her private key to prove to the Bitcoin Network. He doesn't need to say, I'm so and so and I'm malice. You just need to say, Here's a transaction signed with a certain private key. And here's a corresponding publicly so network try to use that public key to decrypt. If the network can properly decrypt that message. Networks knows that someone that had access to the correct private key was able to digitally sign this transaction. So that is what the rest of the network would do. They would. They would use Alice Public Key to verify that transaction. If so, that transaction is valid. This is where I say, like a little bit more complicated details, like each account is known by its public key. So in Bitcoin it's the same, whereas in Ethereum they just decide to take the public key, which is 256 bits longer and just take 160 bits out of it using another algorithm. Um, generally, these these public keys and private keys are some bids. Rings 100 and 60 bits or 256 depending on the platform. And and usually you don't know who they are, but you simply know them simply because they decide to advertise. Saying usually some well known organisation would say we are so and so that's that's the only reason. Yeah. Yeah. So actually, I'll let me show this. Maybe on the scan. Let's take a reason Block. Uh, one of the transactions. Mm. Maybe maybe this doesn't matter. Uh, no. No, I didn't click on the transaction. I click on the address. Sorry. Should I clicked on this. So here's a transaction hash, which is a hash of the all the transaction data. And what I mean by data is it should be somewhere here. Yeah. So all of this data when you hash, you should get this. So this is 256 bits long. Um, so from this is the sender. This is 100 and 60 bits. So this is what I mean by the address. So whoever owns a corresponding public key. And that public key, which is 256 bits long, has been somehow shrunk to get this 160 bit address. So that is the form address. And and this is the recipient address. This is in this case, it's a smart contract, but still, that smart contract has 100 and 60 bit address. So addresses in Ethereum are 160 bits, whereas the block hash and the transaction hash they are 256 bits. Now, how do you know this? This is UNICEF. It's simply because they they usually go here and register and say, this address belongs to us. There's other than that there's no authority, authority or a record to say this is actually unisoft address. So if you want to be anonymized, you can stay like that. Um, so in this hand they used, they used to have a comment section, Um, where can I find that? Oh, yeah. So mm. Maybe they remote. I'm not sure. Contract. So here's the contract. So then usually when they upload the contract, they would put such information, or sometimes, like you would see for some bad smart contracts in the sense sponsor schemes and people talk about it. Uh, that's where they had the comment section. I don't know whether they no longer have it, so let's see, maybe an address. They used to have an option here where people like can, uh, people tend to discuss. OK, I think this is this address and all of that. But other than that, there's no record like who really owns that address? Did I answer the question then? Yeah, Any other questions? So cryptocurrencies are essentially digital currencies baked into the Blockchain platform, But I mean by baked in the Blockchain platform in the sense the code determines how new Cryptocurrency get generated and how much and who owns that there are, Whereas there are tokens that pretty much anyone can write a smart contract and create tokens. So I think maybe lab three, you will be creating an ER C 20 token lab two or three, you'll be creating an ER C 20 token, so that essentially means like you decide to create a token. So the key difference between like tokens can be cryptocurrencies, but not necessarily. Every token is a Cryptocurrency like non fungible tokens are no cryptocurrencies. Uh, so you hardcore the accounting and whatever validation rules into the code so that the platform will decide how new Cryptocurrency get generated. Who has access to what like that? So usually most of the public Blockchain platforms has only one base currency, like ether or Bitcoin like that. And sometimes we also call this native currencies. So this is how you differentiate tokens from crypto like native currency. So Bitcoin and Ethereum are native currencies, whereas let's say some stable coins like us DT that we saw on Monday. That's that's a token. Yes, that's a Cryptocurrency as well. But that is not native. It's just issued through a smart contract, so there's no central issuing in the sense no one party decides, whereas in the US DT. So whoever controls us DT contracts can mint and burn or create those token so you can be there. So there was a question at the very beginning. How do you get hold of Cryptocurrency? So you are the mind Oh, you need to buy it from someone that already somehow got it from some other place, so these are usually used on public Blockchains like private Blockchains usually don't have cryptocurrencies, and they don't really represent other rights in the sense, like Cryptocurrencies are their own thing. Whereas, let's say, if you have $10 note legally in Australia, nobody can deny if you try to pay with that $10. So that's what you call a legal currency, Of course. On the other hand, let's say if you are supposed to pay someone $1000 you cannot take 10,010 cent coins. They can deny that. Whereas, like Cryptocurrency, whether someone gets Cryptocurrency or not, it's up to them whether they are going to accept it or not. So it's They're kind of their own own thing, and they don't necessarily have any other rights other than the value that you think it is. It is worth, or Bitcoin is worth like that. So what happens here is, let's say there is a transaction to send to Bitcoin. BTC stands for Bitcoin. E stands for ether from let's Say, Alice's account to Bob. So Alice sent this transaction sign that transaction by using her private key. That's how Alice proved. This is Alice and announce that to one of the nodes in the network. Of course, if you want, you can announce that to multiple nodes, and those notes are receive the trans one or more of those who receive the transaction. And if they decide to include the transaction in a block, they will put that in a block like that. And then they will try to upend this block into the chain of blocks in the sense they will try to somehow be in this longest chain of blocks. So if that if this block, let's say somehow get included in the chain of blocks, we consider the block as well as the transactions in the block to be included in the the Blockchain or that chain of blocks or that data structure and exchanges are a different part of this ecosystem. That is how you ended up either buying or selling your Cryptocurrency. So Bitcoin was the first Cryptocurrency that was proposed in 2008 in a white paper using a pseudonym called Satos. Shin Nakamoto there are, like, who knows? Like you don't really know who this person is, but there are some assumptions, like this is, this person is anyway. So there was a white paper and then an implementation appear the next year. And Bitcoin wasn't very reliable, like up to about 2012. But then it started kind of getting very mature and and became a stable platform. So what it essentially does is it keeps track of the ownership of Bitcoin or whatever this Cryptocurrency that it proposed saying. Alice owns this much bobs on that much. But But that statement is slightly wrong. I'll, I'll show you why. And so then the miners, the nose that are on this piece of software approximately every 10 minutes, try to create a new block and advertise that to the rest of the network. Only thing is, whenever, let's say, if I'm building block N plus one, I will always put the block ends hash. So that's how I established that link to the block before. If the rest of the network thinks my block is valid, they will accept, and they will start working on building the next plot. N plus two, uh so minus, compared to build new blocks and the time typical. Average time between two of these blocks is 10 minutes. Sometimes you will see a block appearing even a couple of seconds later. Sometimes you may not see a block, even for 20 minutes, so at least 10 minutes is an average long term average. There is a possibility that two blocks may be close to each other in terms of time or more, far apart from the usual 10 minutes. So this is called the interlock time, and and the standard deviation of the variation is quite high. So this is a screenshot that I got this morning. Uh, when I look at the Bitcoin network, at least there were 19,000 nodes this morning. So if you go to this website, you can get a live view from that one. You will see some numbers come and go for various reasons. Node crash, network failure. Someone decides to restart the nodes. Who knows what. But the interesting thing is, we don't even know exactly where those nodes are. 61% of the nodes. We don't have any idea where they are. China used to have a lot. I'm pretty sure there's more still, but there was quite a lot of crackdown. And so this also depends on like whereas electricity is cheap and a lot of other factors, and North America has a lot Europe, and interestingly, Australia has a few as well. So interestingly, Australia is one of those countries where the Cryptocurrency ownership per capita is quite high. As a country, Australia is small in terms of people. But if you look at how much an individual in average tend to hold, Australia holds a lot more than the rest of the world. Um, so So the takeaway is this. It's a global network, and there are tens of thousands of nodes in this network, and we don't trust any of them. And everyone is there in this network, for whatever reason, mostly wants to. Most wants to make money by building the next block. So it's a It's a race among all of these notes. But before we go into that one, so there's this idea of accounts and the state. So how much Alice owns. So how much Bob's own? That's that's like Alice account. So you use your public key, which is your address, essentially, like when I show the transaction on the scan, there was a from address and a two address. Those are the addresses, So that is how you keep track of someone's ownership and you use a private key to sign the transaction to prove who you are so that you can spend that Cryptocurrency. So the state of the Blockchain is essentially account balances of everyone. How much Ali zones, how much Bob zone, how much you own, how much I own like that. So generally every node records every transactions from the genesis. So this is why it's not very efficient thing to do. Currently, most Blockchains operate like this. They jump everything, um, so transactions are grouped into block, and whenever you create a new block, it's like system move from one discrete state to the next one. So what happens is like this. Let's say, before this block, there were certain account balances like Alice owns something Bob owns something everyone owns something. When this round block get included, some of those balances will change. Some will get debited. Some will get credit like that, so it's like system moves from one discrete state to another at a certain time step. So here's how a transaction in Bitcoin look like. So let's say you have 100 so these are called Satoshi Satoshi is, I think, 10th of over 18. So Bitcoin has fractions, and the lowest is Satoshi. That comes from Satoshi Nakamoto, the person who proposed that. So that 100 K is a very small value if you convert that to dollars. Not insignificant, but not very big, either, because one Bitcoin today is more than $100,000. At least a couple of days ago. That is what it was. So let's say you have this 100 coming in as a transaction and you have, let's say in this example, two outputs. So this is like, let's say you have $10 note. You go to the cafeteria and buy something. Let's say buy a coffee and they keep something and they give you change back, Let's say $5.50 for the coffee, so you get $4.50 back. So those are the two different outputs, so a transaction can have one or more inputs. So let's say you pay that 5 $10 because it's 550 you had only 22 $5 notes, so $1 note was not enough. So you combine two of them so like that you can have more than one input into a transaction, and similarly, you can have more than one output in in a transaction. But if you look at the input was 100 K output was 90 K 40 plus 50. There's another 10-K, so this becomes the transaction fee that the miner can keep. You can be greedy in the sense you can try to put hold that 100 as the output where the miner doesn't get anything. But at that point, it is minors decision whether to include your transaction or not. So this is like giving a tip in the sense. If you give a higher tip, the service will be better in the sense your transaction is likely to be included in the Blockchain much faster. So this is important. So this transaction has one input, two outputs and something for the minor. Now, after this transaction get included in a block, it's like that input is now consumed, so you cannot use that input zero in some other transaction. That is what how you prevent double spending but the two outputs. So let's say the merchant or the whoever runs the cafeteria, they got that 550 they can do whatever with that 550. You got that 450 back. You can do whatever with that 450 so that you can spend in another transaction. So to summarise, a transaction contains one or more inputs and one or more outputs. And the fee is the incentive to the miner to keep contributing to the network. And each of those inputs need to be supported with a digital signature. So that is how you prove that these $10 are mine. In this case, this 100 K sash is our mine, and I can use them. Otherwise, anyone else can use your Bitcoins. That's how you prevent them. Then, on the other hand, outputs are bound to a specific public key. So, like that, let's say in this example, 40 K was the fee for the coffee. So you you bound that output to, let's say, whoever runs the cafeteria, that person's public key. So then only they can use that in the future because that is bound to their private public key. They must use their private key to spend that money. And let's say in this example, 50 K is your return back. That will be bound to your public key so that you can spend that 50 K in a future transaction. So there is both the public and the private key use here. You use your private key to prove that this is your Bitcoin, that you're going to spend it and whoever receiving the output that each of those outputs are bound to their public keys. So in future, they can use those using by signing a transaction with their private keys. So this is not just like saying, OK, you get $5 you get $5 you get $5 and that $5 is bound to that particular address. Uh, yeah, any questions so you can have a chain of transactions like this. So here's this is what we saw. And let's say that for Transaction one is now, spend in another transaction Transaction three and then this Transaction two is spent in two other transactions. Uh, now each of these examples we only have a single input. But as I said earlier, like, you can put multiple inputs in in your transaction as well because, let's say whatever. If if you are trying to pay someone like Let's say Fif 50. This one only gives you 30 so you need to find another 20 or more from a different transaction. So this this, to a certain extent, reflect how we play with real money, how we interact with real money. You give it to someone, you get change back. Or if you, if you don't have like 11 single coin or one single note is not enough, you combine multiple of them, so it kind of reflects that that real world behaviour. But Ethereum works in a very different way. It's more like bank accounts. Bitcoin is more like money like like what they call Fiat currency, whereas Ethereum is more like bank like where you are. If you are like, let's say, if you are typing your credit card or debit card to pay for the coffee, you just pay exactly that one. And of course, if there may be a payment fee card fee, that's that's it. Um, OK, so now if you look at this transaction, three is still not spinned, whereas four is spent and six is also not spent, So these are called the S, which stands for unspent transaction output So in In Bitcoin we keep track of the Bitcoin ownership using what are called UTXO. So general term is in Bitcoin. We use UXO in Ethereum and a lot of other Blockchains. We use the account balance model account balance model is essentially the bank. What bank? You have an account and a balance. But there are a few other Blockchains that still use UTXO. I think R three K, which is an enterprise Blockchain. They use the UTX approach. Uh, there are certain advantages of doing things the UTXO like. It gives you better parallelism but difficult to implement. Whereas the bank account approach is what you are familiar, typically with the database, because every account is a role in a database. Uh, let's see what it is, you know? Yeah. So if you are looking at, like how much Alice owns, you need to see all the UTXO. Not the one spent all the UTXO where the public key is Alice Public key. So, like, let's say if you want to know how much money that you have in your wallet, you have to go and count individual notes and the coins that you have, so this is more like that. So there's no single record saying you have $25.27 in your wallet. You have to count it, whereas the account balance model that's very straightforward, it will say exactly. In your bank account, you have $25.27. So that's that's another difference here. On the other hand, if you look at the state of the entire Blockchain, that's all the S, the Alex, the Bob, you and I and everyone else on in the network. So that's how you kind of calculate. So it's a little bit difficult to get a holistic view in a utx system, but it has other advantages. Now. This is a very simplified view of a block, a Bitcoin block at the very top. We have the block hash, so this is a fingerprint of everything that is below this. So there is a version number like any protocol. Usually there is a version number, and this is a previous hash. So this was a block before, and this is a block after. So here the previous hash timestamp. This is unique, unique timestamp. Anyone that is not familiar with the UNIX Timestamp. This is the first time you are hearing this. This is essentially the number of seconds from 1970 January 1st 00 UNIX Timestamp is an integer that essentially counts the number of seconds from 1970 January 1st. So rather than having a fancy data, they shrink. It's just an integer to work with. Um, So there's the number of bits that's the size of the block. There's something called the nuns. I'll come to that very soon. And then here's a Merkel root that summarises all the transactions, uh, that are in the block. So rather than all of these, you summarise everything with the root of the Merkel tree. Of course, you still have the transactions as the payload of your block. So here's the set of transactions. Now, the thing is any single thing that is changing here, any of these transactions will change the Mert route. If mercury route changes, still, the the block hash will change. Or even if you change the time stamp or even if you change the the bits or the nouns, anything this will change. So this block hash act as the unique identifier of that block. Um, typically the maximum block size is 44 megabytes and a single transaction, I said, I think 1 kg byte, actually. Sorry. It's 100 ks. So each one of these can be 100 max, and the whole block can be maximum of 4 kg bytes. But in practise, you will mostly see, like one megabyte blocks, so most blocks won't get filled to the maximum. That's simply because minors are greedy getting the block reward rather than the transaction fees. More transactions that you usually include. You get more transaction fees, but the incentives are such that the fee that you get out of building a block is generally higher than the transaction fees. So you want to put a few transactions and quickly or what? So this is what really happens in mining when you receive a block from someone for, let's say, block number in, there's no point trying to build on the same block again. You just move on in the sense you take you look at what are the pending transactions? Maybe I don't even remember what was it doctor like, So what happens is these are pending transactions that the miner would see when you get a new block from there, whatever the transaction that was in your pending list are no longer important because they are already in a block and then from one of the remaining ones. Then from what are the remaining ones? We you pick a few? Few like some sort of a subject. It's entirely up to the minor to decide what they want to pick. There's nothing covering like you must pick these transactions or anything like that. So you remove anything that is already in a block, you take a subset from the remaining transactions, and then you add a special transaction called the coin base transaction. This is a transaction that gives you a claim for new Cryptocurrency once the block is built. Let's see, uh, maybe this doesn't show. No, no, it's not here. But if you see, uh, who is the mine? OK, so who is the fee recipient? So this one, this one got this much reward, Uh, so that that transaction is what we essentially call that coin based transaction. So you put out a special transaction essentially claiming that because I'm the miner who is building this, I deserve this much it up. And then you construct the Merkel tree to summarise all of those transactions. And you include the hash of the previous block. So that's that's what the previous part is. The payload. Pretty much. Now you are constructing the head up and then you solve a puzzle. But why this puzzle? Probably We don't have time to talk about it today to prove that you have the right to build this block because any miner can build a block. So miners are in a race to build blocks. So who who who gets to build the block depends on some sort of a consensus technique that you have. So in this case, you saw a cryptographic puzzle. I think we can talk about it before we stop. And as soon as you solve the puzzle, you advertise that to the rest of the network. Actually, we can talk about this slide and stop. So the puzzle is like this. Your challenge is to find, uh, a block where these are the content coming from the block. So this is essentially everything that we saw here other than the top line. So you have some MB data. When you concreate that with some in bit number like 123456 up to the power in you count those two bits strings and then you hash it the same hash functions we have been talking about. If your hash value has a particular pattern like this one, so here's a challenge. You have to find a hash value that has four leading zeros. If so, you have solved the puzzle. If your hash value does not satisfy this requirement, you go back and you put a different non value and retry, and you keep doing this until you find a hash value that satisfies that sort of very common. So, based on what we learn about hashing, is it easy to given that?
