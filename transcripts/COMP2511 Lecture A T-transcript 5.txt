SPEAKER 0
a line. Can you hear me? If you're online, can you hear me? Can you hear me? Yeah. Good. We do mic testing every time we start. OK, it's five past nine. So we can start. I think Carl may, uh, come, uh, today, Uh, but maybe there a RE some disruptions IN the public transport. So maybe he's late. So I think Let's, uh, um, start, um, So I hope that you a RE following all the notices which has been published by Amanda every, uh, or I every end of the week and also during the week when required. So And I hope that you have already kind of started looking into, uh, your first assignment as I introduced in the last lecture. OK, so, I, I think you don't leave it to the last minute. Um, please get going now. And if you have any questions, you can always ask, uh, to your tutor during these three hours, you have for any clarifications. And I think I may have already done it, or, uh, they will do very soon. Yeah, All lots of lots of health sessions are available. OK, so please make use of all the resources available to you and, uh, get going because you see learning what is object programming at your level is not difficult. OK, this is how Java works. But then how to use it in problem solving. And so the first assignment is very nicely crafted, which will require you to start thinking in the terms of object oriented framework. OK, And that's the most crucial part of the first assignment, where which which will force you. You know, you will go back to your procedural programming, Uh or you start with that and you have to sit back and say, Well, am I using object audited framework? I'm identifying entities, properties and methods and relationship between them and all those things constantly think about it because, uh, later this week and, uh, from next week, we'll see how we can start making sure that our software has got certain properties which will allow us to to design Softwares which a RE flexible, reusable, extendable, readable and so on and so forth. Ok, so all this property we can achieve, given you understand this basic framework and then add more and more features on top of it. So all these things are very, very important. So please, please try to do it And don't take help from anybody. Ask questions and learn from that. OK? And I tell you, even with all these latest facilities available to us, uh, if you seek help, you're not going to learn. It's like, you know when you need to learn to swim. Nobody can learn for you. You want to learn how to ride a bike. Nobody can learn for you. You know you need to do exercise. Nobody can do for you. Similarly, if you want to learn problem solving, nobody can do for you. You have to go through that process few times and then you learn how to ride a bike. You know how to swim and then how to do problem solving. You only learn by doing it certain things. OK, um, even understanding it is one thing, but doing is something different. I can tell you how to ride a bike or how to swim. It's a description you can read in the book, but then you have to do it. So all we have done so far and all we can do as as as an external uh, individuals or the teachers is just tell you the things you should be doing and avoiding, but eventually you have to do it. It's very, very important. OK, so, um, let's go through the schedule where we are right now. Uh, So currently, uh, now we are putting some links to the teams recording in case the eco 360 is on and off. But still, our main source is eco 360 in case I forget to record it. Uh, those recordings are always available. OK, now, So we have kind of covered all everything up to domain modelling. Now, the next topic was designed by contract and then exceptions. Generics and collections J in the testing. We understand that you have gone through the testing framework already in 1531. But we are going to touch upon that with respect to java testing and then design principles that up to this, we want to cover this week. So what I'm going to do today, Um, And until, uh, carl appears, or in case he doesn't, then of course, you'll we'll do it next time next week. Sometime. I've already introduced assignment one to you, so you can get going. OK, now, today I'm thinking of this is a simple topic. You can even read the slide. But don't worry, I'll cover that. But I think more important is to understand how the exception works. What are the generic types and how they are extremely useful in dealing with collection. So these are the two features which were not available in C before They are interesting. You will come across them a lot. So I'll cover them through the first and, uh, next lecture. We'll cover J unit testing briefly touch upon design by contract and then start design principles of you go from there refactoring and then different, uh, patterns and so on and so forth. So many different topics. We're going to go here. So let me start with the exceptions. And before that, if you have any questions, please ask me. So what are the exceptions? OK, so, uh, uh to exceptions, basically, uh, are nothing. But an exception is an event which occurs during execution programme that disrupts normal flow of the programme. So, basically, in C, if you have error message, what do you do? We use a cert so the third does basically check the bullion condition and if it is not true, the programme will crash there. So when they design Java and all the new languages, there is some mechanism for dealing with exceptions means something has gone wrong. So errors, you know, all the same as you will say. So the idea is that, well, OK, if something has gone wrong now I can just write a cert. And technically, you can also do that in Java, as you will see at the end of this slide. But that's not preferred generally because that's kind of harsh action. Something goes wrong. I'm going to crash it now. It's good that you're not continuing, so that's good news. But can I do it in a better way? Or I can say, Can I basically deal with that error, print the corresponding message, inform the user what happened and then gracefully exit gracefully means that if I'm connecting to a few databases, then I release close them so and so or file or whatever so gracefully I come out of it. So there is something has gone wrong, and how do I deal with that? So the whole exception handling is that now? How do you do that in Java? Well, that's what we're going to discuss today. Now, similarly, in every language like in python. Also, there is exception handling. Uh, most of the languages will have some way or other. You can handle exceptions now the way they do it may be slightly different depending on the the framework you're dealing with. But there is always this mechanism, OK? And generally they will also allow a cer. But that's preferred not to use that. So what happens is that whenever something goes wrong now remember, Java is an object oriented framework. OK, so everything is an object. OK, so what happens is that if something goes wrong, what it does, it will create an object. It will put all the error messages inside and this is what conceptually it will do. It will throw an object. So has something gone wrong? It will collect all the information at that time. You know, uh and you will see when I run it, it will crash and see what it prints it. It tells you even which number which line number what happened and so on and so forth and then it puts in the object and it throws that now this is conceptually throws that object. Now somebody needs to collect that object. OK, catch it and do something with that. So how does it work? We go through that mechanism right now. That's a conceptual thing. OK, so it basically it throws it up. So what happens? And somebody need to catch it. And if nobody catches it, then the programme will crash just like I said. So that's the overall mechanism. We'll go through examples to to clarify exactly what happened. So now look at the first example here. OK, so this is the main programme which is basically calling method First Method M one which is then calling another method M two and M two is calling Method M three, for example. So that's a calling stack. OK, now what happens is the following OK, if something goes wrong, OK? If something goes wrong, say in there are different scenarios which can happen here. So if something goes wrong in this method, then it will throw an exception Object. Now what happens is that your first option is a particular statement throws an exception and you're going to catch it inside that method so it doesn't go anywhere and you do whatever you need to do for that. And we had the example coming. So So a line has thrown an exception, and I deal with that, Then I don't need to do anything. Nothing goes outside that matter. The second option is that hey, a particular So what is the exception? I want to open a file. A file doesn't exist, so error appear so it will create a so called Io exception object. It will throw it now say I'm not catching it in that method. So then that method will throw the exception and it will come to the calling method here. Now, that exception object has to be catched here. Somebody needs to catch that object there and deal with that. Then it will settle there. If not, then that will propagate. And that object is now, uh needs to be handled in the original M one method and if it is not handled there, then it will come to the main method. And if you don't handle the main method, the programme will crash and message. However, you have a chance of handling it inside this method or the calling method or calling, calling method whatever. So, in that track you can handle that object, catch that object and do what you want to do gracefully. Like close all the files, close connections, print that message and then you can even leave your programme. But that's up to you. What? You put your logic there. So that's the overall mechanism. OK, so the question now is that what kind of exception objects are generated and how we can catch them and handle them that mechanism we just need to know. OK, so, uh, do you understand? So far, If you have any questions, please ask me. So there are mainly three kinds of exceptions here, but generally we kind of divide them into two. By checked exception and unchecked exception, I'll tell you what they are OK, so checked Exceptions are the one which are basically this one and these two basically I think, but unchecked exception. OK, so the checked exceptions are the one which we must check. Check Miss, we must catch them. We must handle them otherwise programme will not compile, not even compile. OK, so this kind of, uh so the advantage of this kind of mechanism, even when you're writing a programme, you're opening a file. As you will see, it's a hang on. Tell me what? What do you want to do If if if something goes wrong, you need to put that logic there. If not, it will not compile. So it becomes like, much so generally when you write a programme in Java. It's more chances that it will compile and run than say in C, because in C we can't see lots of things behind the scene. OK, uh, it won't even complain. It will return some value and it can continue processing. This one would force you to think about certain things before it compiles. That's the advantage of languages like this. OK, there is also slight disadvantage of that and that is that as you can see, the the the exception handling Java, particularly and also other languages, is very verbose. So it means that you have to write lots of code to to to to throw and handle these exceptions. So sometimes as you will see in my example, the logic is four lines, But the mechanism to handle and the exception is more than four lines. OK, but once you understand so you can skip those, then quickly understand what they are doing. OK, so it could be That's kind of from my point of view anyway, a bit of a limitation, you know, not limitation, but something you know you don't like particularly. But it's useful because, uh, you will handle all the issues beforehand. OK, so now so the checked exceptions. The checks have determined whether it is checked or not. And I'll tell you how to find other particular exception. Checked or not, so are you. Exception SQL like you know, your ex query connecting the database so on and so forth you must handle. However, if you if you are forced to handle every error then the programme will be very cryptic. So, for example, you are running out of memory, you know, virtual machine error. All these can happen if your operating system is malfunctioning or there are so many programmes now we can't go and see. Tell what to do in those situations So those are unchecked. Ok, so you don't need to check them. In that case, yes, it will crash OK? Because otherwise there's too many things to say. If if if the other one is that if you are executing a programme and say you have an array with the 10 elements now sometimes the user enters certain values. As a result, index becomes 21 so in that case it will crash. But again, you don't need to catch those exceptions. If you want to, you can. If you think this may happen in a programme, I may catch and gracefully exit the programme but otherwise I'm not required to. So there are certain exceptions which are the checkpoint which we have to check unchecked. We don't need to However, if you want to, we can OK and we have example for all of them. So there are some more introductions on these websites, OK, but what you need to know is everything covered in these slides and in the examples we discussed. So this is a huge hierarchy, you know, it's a big jungle out there, as you say, you know, Big tree here and again. Not necessarily that I think they could have done slightly better job in designing this, but that's how java is designed. So the way it works is that there is a class called Throw, which is all part of Java. Um implementation. OK, go Java. So basically, throw is a class. It represents any object you can throw, you know, Now there are two subclasses. One is exception. One is error. So you see here anything under error is unchecked. So So this error is basically because of the virtual machine error thread which we'll talk about, you know, sub processes. You start, you know, something happened there, a WT error. So all these are the errors and that's we say Look, you know, that's because of all the other things and we don't need to go and handle. If I want to check, I can check. Otherwise, I don't need to check under exception. Every, uh that there is a if it is subclass of exception under IU exception. Sorry, this is very bit tricky and this is how java is. OK, So it says that there's a run time exception which is subclass of exception. Now, everything under run time is again unchecked because that's a run time. During runtime arithmetic exception, you want to divide something by zero. Now you can't. I mean, if you want to check it, you can check it, catch it, But you don't have to Basically OK, array, out of index So on and so forth. All of these are under runtime exceptions and they are unchecked. However, everything else under exception must be checked. So basically exception and everything under exception except run time is checks but complicated. But so visually, it's much easier to understand. From our point of view. Basically all we are going to do is that we are going to use Are you exception or lot or we are going to create our own exception. And those exceptions will be also subclass of exception. So I can create my own exception here and they are the one we are going to deal with. OK, any question, Please ask me now I think the best thing is to get to the example and understand how it works. And then once you understand this, we'll go through the code base which is again available to you. There are three different examples which will cover lots of different situations. And please ask me if you have any questions there. OK, So again, this simple method we are writing is kind of not doing anything meaningful. But the purpose of this simple exercise is to explain to you how the exception handling works in Java. OK, so let's say, uh, I have a a variable of type out, which is of type print writer. Now, if I were you, I would go and type in Google. Java API print writer, print writer is a class or a type already defined in Java. And as you can see, it is basically a class which represents a file in which I can a string. Technically, a file is a stream. But other streams also exist in which I can write some, print something or write something. What does it do? I don't know. I would go to the API and read This is how you learn. We'll go through that. But I mean, I know it, but if you don't know that's fine. You go and see what that class does. OK? Yeah.

SPEAKER 1
Out of curiosity, is it that, uh, works by And if an error happens instead of just immediate Yeah, something

SPEAKER 0
like that. And that's what I would explain just now. Yeah, so? OK, earlier I mentioned that in C we use assert so as if something goes wrong, it crashes. It doesn't give you any option. The whole mechanism of extra handling is that you can handle the errors or exceptions gracefully. So you basically if something goes wrong, it will throw an object of type exception. Uh, you know, and then somewhere I can catch it and do whatever I want to do and then terminate or continue. That's my logic. I can apply that. OK, Yeah, right.

SPEAKER 1
An exception. If I've gotten some data, Um, do I just Can

SPEAKER 0
I also Yeah, If you just wait, I'll just go, for example. But yes, you can. It's up to you and you can create your own exception. You can use that exception in a way, but that's a good question. I'll come back to that shortly. So what happens now? Is that so? That's a variable. So it's kind of kind of, uh, pointed to the stream or to the file. Now, if you see here, the whole logic of the programme is only that many lines here. Everything else is the exception handling, and that's what I was talking to you about very verbose Now, as we discussed already in reply to the previous question, What happens? All we are saying is that can you please execute this set of lines? So anything in the try I want to execute. So there's a try segment. So you define it like this. You have try open bracket close curly bracket in between. This is what I want to execute. The question is that when I'm executing this, if anything goes wrong, then accordingly it will throw an object of type exception. OK, now, if it throws exception, then I want to catch it here only. I don't want to send it to the other calling method. So then if I want to catch it, they can. I can write my logic and say OK, I want to catch any object E, which is of type index out of bind exception. Now remember, this type is unchecked means I don't need to check it, but I want to check it and they do something with that. But that is not checked. Exception, however, so it will also like if the L statement OK, so it will go top down so if it matches this. So if this object is of this type, I'll execute that OK. However, if this object is of the type, are you exception? Then I'll execute that part and I can write multiple cast statements. Got it? Yeah, is the object so it will throw an object. Let's assume that object is E. So I'm catching that object in the variable E. So when I catch that object, it will be assigned to variable E and you can take you can write any variable name. There doesn't have to be so it's a variable name. So whatever object is thrown will be assigned to that. Now you see, here I go to that object and say, Can you get a message which was which is attached to that object? OK, and it will go and print. Yes. OK, so this is so this is what it does. So this is the variable which will be assigned that object and then I can do whatever I want to do with that object and I can write multiple catch statements there. Interestingly, also go back here is that if you go back to this, so one object is of this type, OK? Another is, uh whatever other index this type. OK, so and so forth. I can catch particular exception by different catch statement. I said No, no, hang on. If anything goes wrong, I just want to follow these three lines. Doesn't matter what the cause is. So a lot of time. If that is OK with you, you only have catch and the variable is of type exception. Because remember, everything is under that so graphic circle can be treated as a circle. Remember that and as a shape. So if I have one catch statement with an exception and a variable E that will catch, are you exception as well as any other exception? But then, of course, you can differentiate where it is coming from. But if that is OK with you, you can also do that, Sir, is it clear now? That's the basic logic here. Now it basically said what is finally here. So it says that Look, sometimes when you are executing these statements, add it up occurs and it throws an exception. So maybe you open a file somewhere, you open a file, you're doing something. Something went wrong. It throws an exception. You catch it, you terminate the programme so you have not closed that file. Do you understand that? So I want to release that resource. So they say. Well, OK, what you do is that even if you throw an exception and you catch it before you finish this whole block, you execute everything under the final so final will be executed irrespective whether the exception was thrown and caught or otherwise. So I'll come to you. So what? The final does is that it is basically where you put your logic which you required to carry out certain tasks irrespective whether there was an exception or not. I need to do this in this case, for example, I want to close that now. If it is not null, that means it is still open. I want to close it. Otherwise I don't want to do anything. Yeah, uh, does catch also do. What is it or is that so? Whatever you're catching, you have to provide type. So if you provide type error E, it will catch error. OK, so what is thrown is of type throw. So this is of type throw. If it is that error I need to catch as an error. So I can be very specific or general, depending on what I want. OK? Depending on what you want. Yeah. Any other questions, guys? Now? So this is the main mechanism here. Now, one thing before I go to the next one. Is that what you need to remember here is that you see here this try is in this curly bracket. Bracket starts here. Bracket ends here, so if you declare a variable here, the scope of that variable is only here. You got it? Yes or no? Just like a scoping mechanism. So if I would have declared this out here, I could have also written print writer here. But then this out variable is not available in the final. So therefore, you see, I declared the variable outside the bracket. So then it is available in all the curly brackets Just a little bit, because sometimes people do that and say, Well, hang on. You know, generally you think Well, why don't you just declare that variable here, you know? But then it is only scope is there? So therefore we declare outside and then use it so then this is available in all three of them because it is outside that scope, but still within that method scope. So so on and so forth. You got it. So now this is theoretical description. So let's go through examples and it will clarify lots of things. OK, so OK, so let's go. There are three different examples we have here. So as you can see, this is the first example which is based on the lecture slide there. So I'm importing. So basically, package exception. And then I'm importing those classes, you know? Are you file Writer, are you exception? All these classes are already there as a part of the IO package which is already available in Java. So I'm just importing. I'm also importing a list because what we're doing here is basically I'm just writing a class list, uh, classes here. Okay, OK. And, uh, I say, Look, I just create an array list of type integer. Now, if if you don't understand this, that's our next lecture on generic types. All it does, and you may know it by now. Anyway, it creates an array list of type integer. I can put integer values there, then all I do is that I go in this example from zero to say size size is defined as a 10 again. We are just trying to do something to show you how it works. OK, then I randomly generate a number and I add that So I'm just randomly generating 10 numbers and adding it to our list. That's all I'm doing. So this method is simply generating the A list. Now the right list. Basically, it says that it declares a variable null of type. Uh uh. Decla declares variable out assigns null to it. What is out? Out is of that print writer. Now you must be thinking all this print writer file writer how they are OK now in C it was easy F open and F close So close, you know, in Java even from my point of view, dealing with IO is a bit more verbose again. OK, so the best way to do is just go through some examples, OK? And the way it works is that there are many ways I can open a file. So it's like so basically, in this example, I want to open a file in which I can write something So it says Well, OK, the one way to do it is there's a class called file writer. OK, you see here That's an API file writer, which you can find out on the also. So it says that. But OK, it constructs a file writer given a file name using the platform's default characters and so on and so forth. OK, so it says, Give me file name and it basically in our language, simple language opens that file and it it just gives you the pointer to that file. Are you with me? OK, now you can go through that API. But the most important thing is right at the bottom. Can you see it throws? You can read that here. Truth in the API here throws, and it says it throws. I exception if the name file exists, but is already a director rather than a regular file does. So if you go through that, it will tell you that whenever you open that file. So generally what I do is I say they all are same now. So it's a class as file writer, which is in the package of Java IU it gives you This is how it is structured. It is basically a subclass of output stream writer, which is a subclass of writer, as you see. So I would simply go and look at a few examples how to open a file closer file and use it because it can be in all at times. Now, in our point of view, it basically says it extends a writer so and so forth. You have to read through that. There are different constructors. Yes. So file writer takes a file here. Uh, it constructs a file writer object, given a file to write, OK. And eventually you can also basically give the file name. So So this is the file name here. That's what we are using. So again, there are many different constructors available. So that's the file name. OK, construct file. Are given a file name using platforms, default data. OK, now, if I go here and click it, that's this thing. So I said, Well, that's my construct. You see, it already tells me it throws exception, so the method signature will have a throw statement. It says if you execute this method, it will throw this if something goes wrong. So the calling programme knows I need to handle that or else I need to throw it to my calling programme. Is it right? So now basically, we know this through this we know which exceptions I need to handle if I call that matter. So that's the mechanism I'm showing you to here. OK, so if I go back to my programme so now I know this can throw that particular exception. Now you see here in the first example, all I'm saying is that I'm not going to do anything with that. I'm just going to pass on to the calling programme. So I say my method rightly also throws an exception. So if this call is going to throw exception, I'm just going to forward that to the calling method. Are you with me? So I'm not doing anything here now. Now if I don't write this, it will not even compile you. Write that He says sorry. You you You basically are opening creating an object for that. And so therefore you need to basically go and do something with this unhanded exception. So either I handle it there by by writing the catch statement or I say, Well, I'm just going to throw to the calling programme. Either way, I need to know what I'm doing. I do put logic for that. OK, so this is the first example. So control. Sorry, sir. Yeah, so now I'm not doing anything. So basically, this may throw an exception. Now, I'm just going to print this now What I'm doing deliberately, this is 10 and deliberately is increasing by five so that my index will go beyond nine. OK, my I have got only 10 elements, so this will basically be more than 10. OK, so I deliberately want to cause unchecked exception which is the area out of bound exception. So this is causing, uh, two kind of problems. OK, one can be because of this, but that's difficult to execute. OK, because I mean OK, I can even write a file name, which is not not there, but when I'm writing it, it just create a new file with the file name. So? So this one will basically give me error message out of bound exception, ok? And that that will be thrown the calling programme. Now, how do I catch in the calling programme. So test programme. What is this test programme? What it does, It's a main programme that's on the file here. What I do I just create object of the list number, which is the class we just define. And then I say before try. So when I create this object, it would have created a list with 10 numbers. Random numbers then, um this is for our reference. Only then I am executing this statement here. Now I know that right list throws Are you exception? Can you see that in signature? Because in that class, if I go to the right list, if I click it here, it says throw exceptions. So in the main programme, I need to catch it. So now I'm going to catch it in here. So I execute that now. If that exception, of course, do whatever you want to do here I catch the exception, print that message here and then print stack. So all this information is already captured in that object and we can get the message or we can print the entire, uh, stack trace and so on and so forth. OK, and then I end the programme. So what's happening now? If I run this programme now, as you can see again, remember that I put five there. So here this is the trace. It says that look So when I so if you look at here so everything is OK before try. Nothing happens now catching in Test one This is all our our messages Now this is the trace. It says, uh, index out of bound, blah, blah, blah. And from this class, this class is give the whole stack here and then end the programme. You got it? And if I don't put five, nothing will happen. OK, so if I had to get rid of that, it won't do anything. It will. It would have created that file already and it's fine. OK, Does it make sense or not? So far, so good. Yep. Now the question Is that OK in here? So in the first example, I'm not catching it inside the method, but I'm catching it in the calling programme now. What is the second example? Please ask me if you have any questions online. Also, the second example basically says, Well, ok, it's the same thing here the same thing. OK, so, uh uh OK, I'm creating an object. The constructor will just randomly put 10 numbers in the list. Same thing here. Now the right list. Now I want to handle it in that method. So you see here I'm not throwing anything yet. I'm saying I'm going to handle it here. So now this is similar to what I had in the slide there. So I say I, I open that file for writing. Then I'm writing something on that, OK? And again, this will also give me R a out of index thing. OK, But you see, I don't need to. Then I say, if there's a O exception, print this error message and if it is not, I exception. But generally exception of any type print here now I could have put here out of index bound class also, but just as a demonstration I'm saying is that if it is Io, I will execute this statement. This will catch any exception. OK, Ok, so this is kind of general thing. I say anything goes wrong, just catch it and and do something here. Ok? Now the calling programme doesn't need to do and finally you see, I want to close that file down in case it was open. I would close that So finally closes that file. So now if I go to the test programme here you see now in the test programme, I simply create an object And I call that method. I don't need to catch anything there in the calling programme because in the signature there is no throw there, OK? And so if I just run this programme, uh, again, its mechanism is slightly different. But it's kind of the same thing. OK, here, rent a closing the file. So it is now in a right line exception. It closes the file and then end the programme. Ok, Any questions, guys? Got it. No, again play with these examples. OK, now, so far, I'm using the existing exception class. Now can I create my own exceptions? So this is how we create your own exception One possible way. All I do is that by exception, and you can name whatever you want to name here, exchange that exception class. Now, the exception class gives you all the basic mechanism of generating an exception object and all of them. We don't want to know. We just see inheritance in action now. So the general exception of class, I use it and I said I just want to create my But I inherit everything which is already defined in Java. Now all we are doing and we can do much more here. But all we are doing here is that when you create an object of my exception type of the class, you give me a message and I'm simply going to call the constructor of the superclass, which is exception and pass that message. And I know that the exception class will save that message and I can use get message to get that message. So just one extra layer here, you might think. But what's the advantage of this? The advantage of this is that if somebody throws the exception of this type, I know where it is coming from. So I give this example is that you may have a tutorial class say capacity is 25 students. Then I say, Well, ok, if it is full, I want to get an exception tutorial full, and then I have same mechanism here and then in my catch if the exception to full I know it is because somebody wanted to add student where it is already full so I can do it. So I know it's not coming from any rest. It's coming from that particular action so I can carry out the corresponding so by by defining new types, you can catch those types and carry out specific tasks if you want to. Alternatively, you can read the message and decide where it is coming from and carry out the action that's up to you. OK, so So now how do I use that? Look at this. Same example. We are extended now. Same. This is all the same, you know, creating the array with a random number. So and so forth now, right class. Now I'm again catching the exception inside the method, so I'm not throwing it to the calling method. Now again, I'm deliberately want to go outside the index to show that error message. Now, I say, if id X is greater than size, it will be a ray out of index bound. So I want to create a new object of the class. My exception. Remember, it has got only one constructor which give me a string. So my string I'm giving is that idx whatever string I want to give you and then I finish it here. So I'm now throwing my exception, OK, My own exception here. OK, and now I'm catching it here. If there's a problem in opening a file, I'll catch it here. If it is because of this, I'll catch my exception and go and get the message. So this message will be same as what I entered here. And if there's anything else goes wrong, I have last catch cross like this. So often people just write these is that if anything I missed, the last one will catch any exception. And if I want to handle it here, OK, and then, of course, find that I will close and so on and so forth. And the corresponding test method doesn't need to catch anything because everything is handled in that file. So if I If I run that it basically will basically say, um, index out of range because, you know, I was adding five there, so one time index will be more than size, so it gives you a message now this can be a bit more involved. You can create different types. All I have done through these three examples which are available to you you should run it, modify them hands on experience. So this is how the exceptions are handled. We're not going to go much deeper than this, but when you see all these structures, you need to know what what we are trying trying to do. OK, any questions here? So, uh so what does No, my data dot text is just a file I'm creating and putting 10 numbers there, that's all. And the purpose here is to show you that how to handle exceptions. So apart from that, that file is not doing anything. We're just creating a file and put 10 rand tender numbers there. What is the difference between checked in and checked exceptions? OK, so I said that checked exception you have to catch somewhere in the programme. Uncheck exceptions. You don't need to catch now. One thing last thing I want to show you. OK, let's go to the first one. So first one is throwing exception and the test programme OK, you see here I'm only catching one exception I'm not catching the IO exception. You realise that? Got it. I am actually then saying if there is a exception, my main programme will throw exception so programme will crash You got it. So my main programme can also throw exception and then it is like er it will crash If I want to give you another example for that Let's say like this comma this Ok? And now what I'm going to do is comment and I'm just gonna call this now I can do that. You see, I'm simply calling this. Now I know this can throw two kinds of exceptions checked and unchecked, particularly checked. But I don't provide the catch mechanism. But all I say if this is going to throw exception, I'm just going to pass on to the calling programme. Now, remember, this is the main, so there's nothing calling it so it will crash, which is not a pleasant way of running the programme. But you can do that So this will run. In this case, it was simply print the stack straight away and, uh, it is mechanism or did you see it does the same thing? Accession, blah, blah, blah something like that earlier. By doing this, the advantage is that you can carry out some task beforehand if you want to carry out now, this print stack is same as what is going to print by default, so the output is the same, but this mechanism will will let you handle it in whatever way you want to handle. Got it. Any questions, guys online. So let me undo all of them. OK, so now let's go back. If there is no question, let's go back to, um, the slides here. So we have done. We have defined our exceptions as I can say already, and that's an example, which we already went through, OK, and uh, that also we went through through the example code. OK, so I'm throwing the exception, catching it here and so on. And so it's easy. It's not difficult. Just one Understand now, what are the exception in inheritance? OK, so if my class throws an exception, then it says your subclass can throw all the remember. He can throw more than one exception, and you have to separate them by comma so the subclass can throw those exceptions or subset of them subclass cannot throw more exceptions or different kind of exceptions. OK, that side. Yeah, it's not more or even different exceptions. Then it doesn't work. Demo, which we just finished. OK, now assert OK for completeness. Java does allow assert which is similar to C. Now generally speaking, asserts are not enabled. So when you compile generally they are disabled. You need to put this flag at the compilation to enable them again. That's not a good practise to use Assert. Generally we use, uh, exceptions. OK, but in case you want to, you have to, uh, enable them by when you compile that, OK, and a third basically behaves like this. Ok, this is a classic similar very similar to C A OK, a third. So this is a bullion condition. So if this bullion condition is true, nothing will happen. So this is either true or this is going to be false. If true, nothing happens. If if it is false, then it will go and print out the value of this variable or whatever message I put there so it will still crash. But at the time of crash, it will print the value of that variable of message I put or whatever like that again. Not people use it generally. Now I think there was a question here. And if I remember correctly, can you use this? Try and catch to check whether the value is correct or wrong. Something like that. OK, now, generally we only use try and catch for errors. Otherwise, if you want to check whether the value is between the range or not, just use your normal if condition or whatever condition and handle it in a logical way. Don't use, try and catch for that. So try and catch and assert primarily should be for errors, not for your precondition checks. Got it. That's the practise. Now, technically, you can. But that's not I mean, that will also be very verbose. Lots of line here to write anyway. Got it. Any questions? Guys, that's pretty much the end of this lecture slide. OK, so there are some summary points. OK, any questions? Please ask me online, Ok? No. OK. Um if not, I go to the next one and that one is more interesting. Something different. Generics and collections. OK, so, um, what are the generics now? There are two parts. This is the first introductory part and then later on in the term we'll recover the second part. So generics were not available in C. So why Generics are important. So generics enable types And when we refer to type in Java, it can be either a class or it can be an interface Both a type A variable which is of a particular type and type is a class or a variable. So it tells me what behaviour what method do you offer me? So the idea is that we can parameterized a class, an interface or a method. So when I declare a class, I say I am declaring this class for this type I am writing this method for these types and you must be wondering what the heck that means. So the example for that before I go through this line by line is in C You can write AD T inset. So it is a set for the type integer You got it? I mentioned to you earlier maybe the first lecture that if I want to write string set in C I have to write another implement implement another way where I can have link list or whatever array of strings, then set of double. I need to have another implementation for double. Then what about set of the student records? One more implementation. The logic is the same because all of them are set. So there will be a function to check membership function to insert something so there are not duplicates. Remove all that logic remains the same. Only thing changing is the type from integer to double to string to student records. Generic type says you can declare define a class set and then you can say create an object of type set, but the type is integer or double order stream interestingly or object of type student or a customer or a patient you tell me at run time. So my logic to create set and manipulate set is only written once and that I can use for integer set, double set string set or the student record set. So on and so forth. Are you with me? Yes or no? That's parameterizing my class. Now, I briefly give you an intuition of where we are going and what we are doing. Why we are doing OK. So you immediately wonder about how can you do that? Because you see in integer set, I need to compare if the new element you want to insert is already in the set or not. So I compare to integers. Is it right? The reason why I need to write differently for string because the way I compare string is different to the way I compare in teachers. Are you with me or not? Then if you tell me the set of student records, then how are you going to compare to students or to customers or to patients? So in generic type, what they say is that OK, you can create a set of whatever type you want. It is a double string student, provided you give me a mechanism basically a method to compare to objects of your type. So if I want to create set of type integer, I need a way, a method which compares to integers, which is easy. If I want to get a set of type string, I give a method which allows to compare to strings. So far, so good everything available in Java. But if I want to create a set of student records I need to provide a method which can take two student objects and return are the same or not. If one is less than another or one is better than the other, that method I have to provide the rest of it. He is already in the set class, so generics is parameterizing class definitions interface definition method, extremely powerful and used by all modern languages. And when you read those lots of brackets and it will be confusing, so what the heck is happening? But if you break it down, it's easy to understand and extremely powerful, because you can see the reuse of your software only once you write said Edit only once you write a realist. But in the R a list, you can tell a list of integer or double or a student record. This is already implemented for us. The job. One. Implementation of a release. That's it. That collection OK, so benefits removing, casting so earlier. Like I think, before Java three, there were no generic types, So what we have to do is that you have a real list, and this list is a list of all objects. The most generic type and then I can. So whenever I retrieve something from that that will be of type object and I downcast a string because I know it is upright string. If it is not of type string, it will give me error message. However, as you may have become across otherwise, I say create an release and this is the parameter where every element is of type string. So in that I can only source string now. So then I simply say Go and get the element at index zero. I don't need to cast anything. It is SG Now I'll go through examples. Ask me questions. So generic types generate type is a generic class interface which are parameterized over different types. You can have more than one type. Same thing method, also, example is coming. So the idea is that when I'm declaring a class the name of the class and then you have this bracket and you say you can only create object of that class if you tell me these types. Otherwise I can't create that object now. Generally, these are just the variable names. But if it is element, we use E. These are just the normal common practises. You don't have to, but these are common practises. So we understand that type refers to element or a value or whatever. So look at this example. Look at this example first. So it says if I don't use any type, there's a There is a class called box. Now this is not parameterized. And I say any time you want to put something in that box, you know, set, it takes that object because, remember, anything can be considered as an object and I simply save it. And when you want, I give you back. But here I don't know what that type is. It could be anything. But then I had to downcast that Parameterize says, If you want to create object of type walk, you have to give me type T. Now, when I'm writing that class, I can just treat that as a T and write my logic because T can be tomorrow. Whatever user wants, it could be an integer, a string. It can be student also, it can be customer also, it could be whatever that he could be a type miss. It is just a name of a class or an interface. OK, so now I say I declare a variable which is lower T which is of type T You see that T is basically whatever user is going to give me Then you give me whatever it should be of type T and then I just save it in T so and so forth The whole logic is based on T Now what is T How do I use it? Look at the example Now I say I want to create a new box and I have to provide integer that will be assigned to T So the variable will declared of type integer and I can save integer And this is an object Now remember And this object is stored in a variable integer box So what is the type of that it is integer box of type integer Do you understand the whole thing? Now You see, there's lots of brackets and text and everything So Java says ok it will try to infer few things for us, so just save typing So this is the way. Actually we need to write but to save typing I can skip here. Why? So Java says if you write like this. OK, so that's my assignment statement. So it says that if you don't write it, it will go to the left hand side and infer that it should be of type integer So it will put integer here for us. So these are inferred types. Are you with me? So that saves me typing, That's all. Originally, this is what I should be writing. If not, then I can skip that it will infer it, put it here. So now you understand that everybody fine online. So now gets multiple types Now, Now I am declaring an interface. Now it says a pair. But hang on you to give me two things key and value. So I say K and V kind of makes sense. So this interface anything of the type pair must have two parameters. Why? Because there are two methods. One method get key, will give you value of type. K get value will give you a type B. So all this is very abstract. But when I when you see the implementation which hopefully will be covered today only you will see how wonderfully it can reuse. You're cold. So now I'm declaring a class. See, everything is parameterized right now. It says you can only get an object of type pair if you give me two types KNV you decide what is K? You decide what is V? It implements pair because now this is interface which we just declared here. Ok, now what happens? They say Well ok, you give me K and V. So one variable is of type K. Another is of type V. Now this should be indented by the way. Sorry. So when you create, uh, object of type ordered pair, you should give me two values. One is of type K. Another is of type B value. Yeah, we I'm just going to save it and get we'll get it. It's very simple just to explain to you generic types here. No, why? These things are useful. Look at here now. Now I'm using them. So I am creating an object of type ordered pair. Now I'm giving you these two types here. So this is my K and this is my V and I provide string and I provide integer. Do you understand that you got it? And so now P one is pair which is of type pair where this string and this India. Now I say P two is also a pair where the key is string and value is also string now. So new pair now also provide both the strings here they should be compatible obviously Otherwise they are. And then I provide key and value. So you see here I can use any pair. Now I tell what is the key type and the value type. Now, as you can expect, this is the originally what I want to do. Ok, now I'm creating new pair. OK, now the same thing I can write like this. Saving, typing OK, All I'm doing right now is that See, I have to write this and I have to write this So he says you only write on one side this side You don't write anything, it will infer it here. But of course remember, this should be comparable to this, so everything should be comparable. But you can save typing by inferring types. So if you see just the empty bracket on the right hand side, they are inferred from the left hand side. Now it doesn't have to be integer that You can also create a pair where this is of type string and this is actually of type box, which in turn is also parameterized so on and so forth you can see getting involved right now. That's what I'm saying. When you see some definitions, they will be a bit more involved. So I'm going step by step here. But please make sure you understand what we're doing and ask me if you have any questions. So now this pair P is actually key is a string, and my value is box of type integer the object which is of that box parameterized to when using generics. The type gets long and we have to specify, uh, new. Is it OK to use? I'm not sure, Mike. It's too abrupt with short here, so you may want to give me a programme as such. Ok, I mean, for this course, as far as Java compiles, it's fine, By the way, if that is the question you're asking me and OK if you're asking about the triple dot thing, Uh, yes, you can if you we don't cover it explicitly. But if you want to use it, you can use it if that's what you're asking me. OK, so I'm not sure the question abrahm again String X equal to my string And then you say VX equal to my string. But that war either is a parameters type or a type given war. For what? No, we can No, you can't use V. It should be either a parameterized type or a specific type available to you. A type could be class interface or existing type in Java. So you can't use war here. OK, now, So far we have used classes and interfaces. You can do the same thing for methods now. So this is a class UT very short class. Now there is a method. Now it says, hang up. If you want to execute the method, you need to provide me two types again. Can we? So it's a static method just to make it simple. Give me Can we? Only then you can execute the method. Now what is the method? The name of the method is compare. You see it is getting involved Now what is the first argument? The first argument is P one It is of type of KV. I'm putting everything together. Now the next argument is P two, which is the thing but object of type pair of KV. So when I'm writing this method, I'm assuming that somebody will give me K and B and the targets. The two arguments to my method is P One and P two with a pair of kv. Given that I'll do something so as a given that what I'm going to return is that I go to P one because I know pair is an interface which has got method get key. So I say P one dot get key equals P two dot get remember now equals we discussed earlier already compares two objects and generally every class will have equals suitably equals implemented. So without knowing what is K and V, I can go and use P one dot get Why get key? Because that's part of the pair interface then equals to available to all the classes. Ok, so now I compare two keys and similarly I compare two values. If all of them are same, it returns to others. So you see here This logic doesn't depend on what the value of K and V is because few things happening here. P One is up type Pair, go to the pair interface. I know what methods are available. I call them And generally we are assuming that every class object would have equals Properly implemented These two have is true. This method will work now see how I use it? I create P 11 pair. I create P two and then I call this method and I say in TJ K value string Compare P one and P two. If it is equal, it will return True. Otherwise false. You get it? Yes or no? Now again, it says, Look, it's maybe a bit complicated. So you say. Well, look, if you don't give me, it will look at these values and try to infer that for us. So this can be also written like this. So as you compare and I don't write anything like this if you do that, it will infer that it will infer that type from P One and P two. But if P One and P two are after two different type error message, it says if they are the same type KVKV, it will infer KV and execute. So I don't need to write it explicitly. Initially, you should write explicitly, but otherwise it can also let you infer it from you. So a lot of things are happening behind the scene. And still, at this point, you must be thinking why I need all this. Just wait. When I go through collections and I give you a few examples, then you will see these things in action and later on, in all patterns in design. We are going to use a lot of this all the time. But these examples are small, targeted examples just to show you that one feature. So you may think OK, but what this pair does nothing meaningful. Fine. At least you understand what's happening then we're going to put together and use it to solve some complex problem. Is it clear so far? Ok, we'll come back to part two, which is a bit more involved, but this is enough for this. Yes, mate, rehab.

SPEAKER 1
So, like all the two pairs had. Thank you.

SPEAKER 0
So in this case, P one is of type this P two type this But tomorrow if you want, they can be of different type. So for this particular method. We want that to be of the same type because I want to compare them. But tomorrow, if you are not comparing doing something else, there can be a different type. Uh, so in this extent, Yep. Yeah, we want to. So in that case, you just pass integer integer, No. Good. Ok, ok. If I understand your question correctly, what we are saying is that when you execute this method, you give me K and V and the rest of the method will be only executed for What can we give me? I can change it later on. If that's what the question is. OK? Same same thing? No. So that's what I say you before you execute the method, give me all the KNV or whatever. T one T, two, T three. Then the matchup will be executed for that. But you can call next time with different can we I will execute differently. How do you see it? Yeah, but for the one call you can change once once you call it same thing as a new box integer So it's integer then I can change it. But next time I say new box string or new box student. But once I put that and that's it, then I can change it. So it's not a variable in a way. OK, It is just type which we provide. Yeah, good question. You can change that later on. Yeah. Any other questions? Guys, please. OK, so what are the collections? OK, so in, in in, in C, You know, you basically have array. That's the only thing available to you. OK, that is also not very nicely supported. Uh, and then link list. We have to create three we have to create and you learn all of them in your data structure and so on and so forth. So Java and most of the new higher level languages will already give you a way to create a structure which is called Ali, which is very popular one. So you can excess it like an array, or you can It's like a link list because you don't need to pre define it. It will automatically grow and shrink and so on and so forth for you. Ok, so that collection is already available. Guess what? Java already has a implementation of tree which is a balanced tree tree So you simply say Create a tree. I mean in a simple language. It will create a tree for you, which we are going to do shortly. You don't need to implement that. An extremely efficient we have implemented it. You can also create structures like maps, key value, P, which is very popular in many applications. So all these are already available. So in the earlier Java they were all separately. You know, there's a class for a release. There's a class for a tree, blah, blah, blah And then later versions. They created so Java collection framework and then say all the collection types are under the collection framework. Now what does it mean in plain English? First of all, OK, what it means is that look, it says, Look, if you are dealing with collection, there are a few things which are common. You want to create a collection. You want to add something. You want to remove something. You want to check whether two collections are same or not. You want to check the number of elements. You a collection. I mean, this is common. Now. Collection can be stored as an array or a link lease or as a tree or as a graph or as a hash map. But that can change. So all these common methods are available in all of them. So you don't need to go and find out how to add in one to other. They are all commonly available under the framework. The next interesting thing What they have done is this says all the classes under the collection framework, they will provide constructor which will take another collection. So what does it mean? So I can create an R a list some numbers and then I can create as well. I can create a balance tree, but I don't need to add all the elements. Take this R a list. Take everything in this R a list and create a tree for me or I have a tree. And can you just give me a list from that? So Ali will have a constructor which will accept 33 will have a constructor which will accept Ali and so on and so forth. So that makes it very easy. You can create a collection of one type and in one line you can convert them into another collection and use accordingly. Now each collection will have individual methods obviously specific to that type. But a lot of general classes are also available, so that's the overall picture about the collection. And it is extremely useful because you can then focus on high level problems. You don't need to go and spend time on implementing Balance Tree or even set is available to you. Set class is available to us. We don't need to implement it. So on and so forth. OK, so that's the basic idea. Now I'll go through slide by slide and then we will go through some examples. OK, K is unified architecture for representing and manipulating collections. And, uh, all collection frameworks contain the following the interfaces, the actual implementation, the actual algorithms. OK, now again, let's go through example, which will make it much more clearer to you. So these are the interfaces now. Next, OK, core collection, interface, core collection, interface and capture different types of collections, and the interface is implemented. I think the best one is this light. So these are the interfaces, so there is a There's a collection interface set, so obviously as you can expect that interface gives me all the methods to create, Set, add to set delete from set so and so forth That is me, yes or no But that's interface. It is then implemented using so called hash table which is actually a class. The set is also implemented using a balance tree a set This is all available part of collection framework. A set is also implemented using lithe. Now we decide I want to create a set. Now I pick for example out of the three which one is suitable for my application. Now you go to corresponding API. It will also give you a time complexity of every operation. You pick the corresponding one and then we are going to use three set in our example. But tomorrow you can create a set of other types. Now list. So I said OK, yes, you can create a list. This is just the interface. It gives me all this basic method. Now the basic R a list I was talking very popular. You can also classical link list also if you want to create Q and so on and so forth. The map is very interesting key value pair, so give me key. I give you value. So in 2521, you must have studied hash tables. Have you yes or no? So this is hash tables. Hashtags. Having said that, you can also create key value pair using trees, balance trees and I don't know whether you studied in 2521 or not. Often, trees balanced trees are far better than vegetables because they are guaranteed to give you login under any circumstances and also have ordered structure. So for a lot of people don't see it. But a lot of time. That's much better for many applications and and so and so forth the link. So go and look at the API. So what this does these are the classes available and that these are different implementations of the corresponding interfaces and all of them will share some method names as a constructor will also take object of the other collection type and kid object, so on and so forth. All these are the advantages for us. OK, And again, see, these are the basic methods across all of them. So and so please read through this slide. But that's what we are trying to do here? OK, now the overview of the collection framework is also available on these websites. So you should go and at least browse through those pages. OK, now wrapper classes. I mentioned that already Like you know, integer class in IT is a basic type, but that is not an object. So I said OK, the rapper class is in Teacher, which basically gives me all the methods useful for the basic Intertype. So convert string into basic in type given in type convert into string so on and so forth. OK, so generally, for all the base types, Java gives me wrapper classes which gives you it wraps around the base type. So a wrapper class, as you can see, is nothing but wraps around the base type. It gives you additional methods which can be used for base type. That's the idea. OK, now let's go through the demo and that will bring together many things we discussed today. So that is part of code my collections one. OK, ok, the few things happening here, so I'll explain that to you a few things. Ok, now this is where now we are going to bring together the collection, the generic types, everything coming together. And this is how you write programmes in Java or similar other high level languages. OK, and this will show you why these things are so important and useful. So I create a customer class very simple class again and just to illustrate the concept. So we only store three information here the name and just the one string here the rewards point postcode. Hm. Of course you can add more field but this is just for a simple example. So it says you can create a new customer here which was you have to give you the name, the rewards point the postcode and I get it now. Of course, you can provide more constructor but our aim is to show you the collection and the generic types and so on, so forth. So let's say this is how I create a customer. Now the cat name will give me the name set name. Get name all of them. Get the set. That's all I have. Two string gives me the string representation of this customer. So far so simple. We have done everything ok, got it now the only difference here is that? I'm saying this class implements comparable. Nobody is comparable. Comparable is a type is an interface this interface. Now, if you go to API, you can read the same thing. This interface imposes a total ordering on the objects of each class that implements it so and so on and so forth. OK, so comparable. So it should be fine for me. OK, So comparable with the interface is a generic type interface. Remember, Pair was an interface. So say Well, OK, it is an interface, so you can replace T with any type. In our example, we replace that with customer. OK, now what is this interface? Remember, Interface tells that which method the corresponding class should implement. So any class which implements this interface needs to provide those methods. Are you with me or not? Yes or no? There's only one matter available here. Please read through this and I'll talk about this shortly. It says, Well, OK, you need to provide one method compared to that's all. So any class which implements comparable needs to provide compared to methods. So what he says is that you are a given object of the type T what is TT is the one which is parameterized So basically it says that if you are given object of type T then you can compare that object with the current object. And obviously the current object is also type T. Otherwise, there is no comparison. Now it returns zero if both are same minus one if one is less than the other plus one if one the other is greater than the first one Simple logic Now this is how you compare strings If you remember. If I compare two strings if they are same, it returns zero. The first thing is less than the second one, then minus one. It's vice versa plus one So it compares to swings here. It compares to object of type T and it will tell me which one is greater which one is less which if it did equal and the logic of that must be in this method and returns in. Teacher, are you with me? Yes or no Clear No few things here. So in this class, when as I implement these, I must implement that compared to method otherwise it will not compile. Ok, so I go here and you see, this is two string but I I implement that compare to method And my T here is customer Remember why? Because this is customer. So I have to take the customer class And I said this is the other object given to me. I'm going to compare that other object with this current customer This customer so by logic currently is very simple to start with OK, my logic says that get the postcode of this customer and they get the postcode of the other customer. No, If both numbers are the same, it will return. Zero is right yes or no? If the current postcode is less than the previous one, it will return less than zero. So it doesn't have to be minus one. Anything less than zero means this is less than the Given one. If my postcode is good and the other one, it will return positive number so I can write if LCF also But all three are covered by this one expression. So you may see this. In fact, what they are saying is that comparing three ways in one case, negative value, zero value or positive value. So now I'm comparing to customer only based on the postcode. Are you with me or not? Yes or no? If I want to compare them differently. OK, so this is same as writing these three lines here. If this postcode is less than that written minus one, instead of writing this three line, I'm writing the one line there. Is it clear yes or no Tomorrow if I want to compare to customers based on the name, all I need to do is change this logic. So let me put that logic because that's more explicit. That's easy for you to understand. So if I were to compare on the name, I change this. If I were to compare the name and then the postcode or on all of them, whatever, whichever way, I want to compare customer. I put the logic in this matter. So I decide in this method how I want to compare to customers. Is it clear or not? Yes or no? And then I say, I'm saying now that class customer is comparable. Why, by saying it that it implements comparable customer. I'm telling to the outside client that I have implemented compared to method, that's all I'm communicating to the client that I have implemented compared to method for customer. Now how I'm going to use it. See the example of that? Uh OK, no. OK, now I create a main class. There's a package I'm importing a tree set. You see, I'm just creating a tree set set using balanced trees. It's already available in Java collection and Comparator. Ok, ok, that's comparable. Sorry, they are related. OK? Yeah. OK, now let's go through the example here the main class Please ask me if you have any questions. OK first. No, Uh OK, skip that line first. I'm creating a new pre set. What is tree set? Preset is again parameterized trees set It is T here. If I go to API so I can create trees set of any type T OK, so, um if I go here, say ok what is the API here? It onwards is the same for us. So tree set It says E here because element it is just parameter type. This tree will contain these elements of this type. Basically got it. So this parameters. Now, if you read through here, it will tell you navigable tree tree map. See It's login time. Please read through the whole thing, OK? And a few other things synchronisation will discuss later Part of this course. So a lot of things we're going to cover this course. But at this point, all we know is that I can create a three set. No. OK, so that's my constructor. I just created a reset. Or as I said to you, I create a reset for some other collection here. OK? And few other things super and all this we are going to cover later on. Okay? No, A tree. I can add something. Add all you know, so many methods available I can use on the tree. OK, so you see a lot of things that are available. You just need to go and go through each one of them. OK, that's a three set. No, um so Furthermore so OK, tree set. All elements inserted into the tree set must implement comparable interface. Can you see that here So its OK, you can create a tree set and you can insert elements in a tree. But remember, tree is an ordered structure. So whatever elements you give, I should be able to compare to elements because, you know, tree is an ordered structure, so you can't create a tree structure. And if you don't tell me how to compare your elements the three set classes I don't know how to compare you Tell me how to compare it now. How does it tell us? It is telling us that whatever type you give me, it should implement comparable interface because comparable interface has got compared to method and that will be used to compare to objects. You see how it is expressed and used. So if I go back to the example here, I created the customer. Now it is working fine because customer is implementing comparable. If I don't implement that, it will give me an error message, he says. Sorry, you can't create a tree set because the customer does not implement comparable because it is comparable. It doesn't give me error message, but it knows that there is a way to compare to customers and internally it will use it to construct tree. I don't need to worry about it. All I have done is provided that compare to method decoupling how to construct tree put to left right the logic of I don't care. It's all hidden from me. But it just wants one thing. How to compare two elements and I give that method. That's it. Then I forget about the restructure. It will implement a log and time. Everything is there. I can reuse that logic. My responsibility is to give compared to so whatever required method, I'm repeating it a lot of time because that's the crux of it. I could have put that inside then it is tightly coupled. I can reuse it easily. OK, Now I create different customer and add it. So there is one customer John Emma Peter Different rewards point and so on and so forth. So at the end of it set is a tree set in which I got these four customers. Are you with me? Because the tree sat, it would already ordered it. So when I see these, they will be ordered currently on the postcode because that's how I compare them. Are you with me? Yes, sir. No what I want to do, I just want to convert them into the R. A list so easy. You see here I say I want to create a new array list. This is just I want to show you and I will create the R A list of course, of type customer. Every element is also parameterized. I don't need to answer. Take everything from this collection. You see how easy it is? So it takes a tree inserts into a list and gives me this R list here one to another. Easy. I also do vice versa as far as far as it implements comparable. Then you know the for Look, I go through every customer and I print them and end of it. So this will print all the customer which are ordered on the postcode. Are you with me? Yes or no? Thus compared to always return positive or negative? Positive. It must written in teacher positive. Negative or zero. Jim. Sorry I missed something. I think it is recognised Conversion. Yeah, I think I miss it, but somebody answered it already. Sorry, guys. OK, so this will just print it. This is an example of what it is. OK, now remember, all preset is possible because customer has implemented the interview. Otherwise it won't do it. A list doesn't have restrictions, so I can create a list of any type because it doesn't compare anything. It just adds it. No. Now what I'm doing, I'm creating the list again. I can renew a list customer B customer B and I'm adding Yeah, I'm adding some more entries here into that. That's another list. Now this is not sorted. Remember 6075. So OK, in this case, it will. Basically whatever order in which I inserted it is unsorted, so it will simply print it that list. So this will be the 1st, 2nd and 3rd unsorted end of it. OK, Ok, but it is. I'll change that later on. Anyway, Let's see what happens. OK, so now there are a few things. I'm teaching you here so so far it will simply print the order in which I edit them. No, another feature of collection. So collection is a class. It gives me static methods. So there is a method called sort. It's a static method in collection. Can you see here? So it says that you give me an R a list and every element again should have implemented comparable interface. It will use that method compared to and it will order sort this So sorting is done for you. All you do is provide a method to compare to objects and it will sort it for you. Now, this will be a sorted list right now. So this example is just to demonstrate that this is good to sort this list, but only if these elements implement comparable interface. Therefore, it has got the comparative method. Are you with me? Yes or no? Got it now? No. Ok, Um so it will compare it based on the logic. I put it there. So let me just show you that. Then I'll go further. Otherwise you lose track of what's happening. So let's go and run that. OK, so I run it. So So the first thing the example covers lots of things. OK, so So this is the original list. Remember this two string? So it represent customer like that. This coming from our two string? OK customer, 81. So John and, uh, 60 61 75. You said this is already in order. Got it because our compare to compares on the postcode. And so therefore, when I insert the tree, it comes in the post code like this? Are you with me? Yes or no? Is it clear? Yep. I said and I don't like this. Ok, what I want to do right now if I go to the customer here, OK? If I go to the, um compare to Can I do this? Vice versa. This is minus one and this is plus one. So I changed the order now? Yes, you know Save it. I run it The higher lower, lower, lower. So I just change the order by changing the logic in that method. Are you with me? Yes sir. So you see the decoupling here. My all I do is provide how to compare the rest of the logic doesn't need to be changed at all now currently I'm just comparing these. I can always compare the names also. Then it will order the name Or I can put complex logic Compare all the three fields whatever I want to do. So the ordering, the logic everything I just need to put in that method and it will work from there. Ok, sorry to hear Did I say that or not? Uh, sorry. So that's one. Ok, so that's I reverse the logic there. And if I run it now, then yeah, so So now the higher than the lower, then the lower. Then the lower reverse logic. No unsorted again. Here is 6075. That's what the order in which I inserted. Then I'm calling that sort method. Remember, this is unsorted. I call the sorted method now because our sorting is reverse order, it goes to higher to lower to lower. So this order is changed to the new one. Until then, I discuss the main logic there for you. So all I'm showing you here is that that one method decides the way you compare. You can use it for trees set or you can just use it just to sort that collection based on the logic which is available in that class. Are you with me? Yes. Even though this is so elegant and nice, there are limitations to this. And the limitation is that there is one way I can compare customer which is written here. What if I want to compare customer differently sometimes based on the postcode, sometimes based on the rewards point, sometimes based on multiple criteria, I want to have same R a list of customer, but depending on my task, I want to order it, order them or compare them differently. So the basic way of comparison I can write here, but I can't keep on changing this method all the time. Got complicated. So can I provide the logic to compare to customers at run time? I said these are the collection and use this method to compare tomorrow. I provide different method. You compare differently. So my logic to compare is even external to your collection. As far as they are compatible, it works extremely powerful. And then we will go and say I provide that logic using so called lambda expression, which is very succinct way of expressing the competition and that you see that you see Ah, that's pretty smart, Pretty elegant. So I look at the time right now, but so what? I'll do, I'm not going to go the whole thing today. So up to this Fine. So this one simply sort this list and it prints it assorted. OK, OK, that's the original. Now the next one is says collection sort. You give me the list and then you tell me the way to compare so it will not go and use compared to implemented in that class. But it will use a method available in this object, and I can then create these objects differently. We do that in our next lecture. OK, because I think it's 49. So I better stop here. We we can't cover the whole thing today, Ok? Any questions, guys just compared to always? No, I OK. Any questions So you can see here? Yes, ma'am. For what does the collection have to now? Now the collection will just use compared to from what? What is provided. Therefore, compared to say, look, you give me collection, but each object should have compared to implement it. Otherwise I can't do anything, so that's a precondition. But the second one says You don't even need to do that. You can give me how to compare separately, which we'll discuss next. Lecture. Yes. Any questions? Yes, In customer. Yeah, So it's a good observation. So he says that look OK, this one is one method. Can I have multiple ways? There is right. That's what he's saying is right. Yeah, logic. Yeah, that's what we'll do next. Lecture. That's the one this one. The whole logic is here in case you are very curious. I just want to show you not now. Eventually you write something like this complicated stuff. OK, you won't understand what this is right now. Lambda Expressions. But we will go there when we go to Lambda Expression. OK, so OK, so it's all very nicely crafted examples. We are going step by step by step by step. So you understand exactly where you are. OK? But yes you can. The idea is to have a default which I generally use. OK, so I can have default comparing on the customer ID for example. So I don't need to write all the time. But then I have flexibility that I can provide logic on the fly and it compares accordingly. Ok, I'll see you on Thursday. Please start your assignment one. OK guys. Yeah. Any other questions online, guys, otherwise we will stop. I didn't take a break, so I better stop now. Is this symmetric I? I just Yeah, yeah, yeah. You We can talk here. There was some question online, which I answered. I'm not sure who that is. Yes, yes. What is it? If you don't catch it. Then it goes to the calling programme calling programme. And uh, first of all, it will not even come by because your main programme should throw that. Remember, in the main programme, I say through Are you accepted? So if I don't do that, it's a Sorry. So So said Ma M and throws an exception. Ok, now I don't catch an M one and I'm calling from my main. Uh no, no, I say M one, I'm not catching in my mail. And my name is also North Korea. It won't come back. Destroy them if I see you. Ok, Ok, so OK, so OK. It's very simple logic. Make sure that your hand come here, OK? We can Yeah.
