SPEAKER 0
OK? Yes, You played one.

SPEAKER 1
OK, I think. Probably keen to get started. Ok, Um hi, everyone. Hope you had a good break. Um, apologies for absolutely everything. Uh, basically, from, um the end of last lecture I had to run and I've been interstate. I only just got back yesterday. Um, I'm just letting you know, because it may not. Uh, it may happen again, but hopefully I'll have things a little bit more sorted, Um, and ahead of time. So, um, first things first, I guess the quiz, the first quiz is now out. Um, to do this, um, and because it was so late getting out. Um, I do want to, um so to give you a little bit of fair, fair warning. So I've now pushed the deadline back. Um, so I released it yesterday. So you have until Tuesday 6 p.m. six PM is my usual deadline time. Um, just so that if there's any issues, they can get resolved, and we're not doing it at midnight trying to resolve those things. Um, it is available on Web C MS You do it through web C MS. You can make multiple submissions. You can submit again and again and again. But it is your last submission at time of deadline, which is what is marked, I believe unless I've changed web C MS since I used it last, um, please use Haskell. Like, get get a version of Haskell. Go onto the the lab computers and, um, switch into the 3141 subs shell or use, um, use ed forum, um, high school playground to explore those answers yourself. I'm more than happy for you to do that. Um, I'm actually kind of happy for people to collaborate as well. I'm not so fussed on that matter. Um, you're all adults. Um, you're allowed to, you know, I. I more or less encourage collaboration through assessment items up until the final exam. The final exam has to be your own work. So use the term to learn, um, the material so that when it comes to the final exam, you can demonstrate your ability. Um, so, yeah, so the first quiz is available on, uh, Web C MS. Um, I'm not sure if I'll continue using Web C MS. Um, I just had to do things at a very last minute. Um, and I know that it's easy to set things up on that. I will just see how this quiz, uh, how how easy it is to transfer the marks from this quiz over. Um Right. So just to recap where we got to last time, um, I do apologise. I didn't also have a chance to finish. I said I was going to, um, complete the word frequency task. Um, offline. Do a recording for that. I haven't had a chance to do that. I will still do that. It's not, um, it's not required, Uh, for what we're about to talk about today. Um, instead, I'll sort of, like, just sort of go through a couple of things. Let's create a new file what they called lecture three. Um, Alright. And, um, and get going on the on the content. So, um, just sort of a reminder where we got last time we were talking about lists, So just a reminder. So a list. So a list is a sequence of objects, and they can be can be of two typess. Alright. We had the idea of, um, the first type being the empty list. Um, and then the second type being, um, something of the form. Um, object Cons. Concatenate Sorry. Cons constructed with. So don't think of cons as concatenation, but rather than, um, construction. So X is an object, and Xs is a list of of objects. I'll just go with this. Objects items and item in my list. Um and of course, the X has. So if I've got a list of integers, X will have to be an integer X's will have to be a list of integers, right? And you cannot construct um, you cannot. You cannot, um, have mixed types types in the list. So, um so you, um so one false three a is not is not a valid list, right? You can only have lists of SO of a particular type, and so that gives you a list of types or type. Uh, your your sorry, It gives you the idea of a type uh, a listed type. Right. So I can talk about the list of integers. Alright, So a list of integers 123 has type list of in like so, um right. And, uh yeah, and so So what's the type of? So that sort of makes sense. What's the type of cons then? Well, cons is gonna take, um, an object a and a list of A's and give you a list of A's. Right? So here we're using our type parameter a sort of to represent any type. And we'll talk a little bit more about that going forward. If I actually run high school, open up a thing. Um, let's let's let's get this to the side. Um alright. And I can ask, what's the what's the type of cons? Um and it'll say exactly that same thing there. So Colin T will tell you the type of things might be helpful for the for the quiz for the first, uh, five questions or five questions I can't remember. Um, in the quiz, there will be some things. So we haven't really talked about type classes. I will talk about that in a little bit. So for you know, for instance, if you look at the type of plus right plus, we normally would think it takes two integers takes two integers, add them together, gives you a new integer. But here, if we try, if we ask, ask Casca what the type is we get something that looks a little bit weird and we'll talk. Hopefully, we'll get a chance to talk about that today. Um, but for all intents, suppose for the quiz. Just sort of read this. Um, as you know, this this is effectively What? This? Well, actually, I was going to tell you what it says. It says if a is of type I is is a number, then Plus will be a function that takes +88888. Right? And so things that are a tight number are things like ins, and so sort of like this is a broadening of the definition. So if you see something like this, you can imagine it's like saying, OK, well, we haven't come across anything. Well, we we've come across different kinds of numbers. We come across INTs, we've come across doubles. Um, there's also floats. There are other kinds of numbers in there. Um right. Um but I for all, for all intents and purposes, just imagine this just says in, In, In, um I think that's relevant for one question. On the, um, on the quiz if you try and plug, if you ask Casca what the type is it looks a little bit weird, Um, and just basically infer that it means in when it says number. I'm right. So that's that's lists, talking about lists. And one thing we, um, did with lists Was we mapped? We talked about mapping a function across a list. Um oh, sorry, actually, and define defining functions for lists. So, um so, for instance, I might want to compute the length of a list. So if I take a list of, um, Well, I can take a list of anything. Um, and the length of the the length of the list will be an integer, um, and I There are a number of ways of defining this. Um, but the the easiest way, uh, the most straightforward way is to say, OK, well, I'm going to say, What if I give if I give you a list? Well, this can be one of two can be expressed in one of two ways. Let's, um, deal with both of those two cases. So my first case, I could say what's the length of an empty list and say, Well, that's just going to be zero. And then the alternative thing. Well, what else can a list be? A list could be, um, eight. An object consed with another object. Um, here we put the brackets in because I want to. If I didn't put the brackets in, um, it might it might work, but it may also, um, do what it was supposed to do and sort of pair it up like this. So put brackets in just to remove ambiguity. Um, I can't remember. I think I think this one might have been a problem I had in the lecture last time. Right. And so this is my alternative version. So the list is either the empty list or it's an object concatenated with a list. Sorry. Constructed with a list. Um, and then So how would I define the length here? Well, what's the length of a an ob object? I think of my pile of papers. Have I got a piece of paper and a smaller piece of paper? I can just say that the size of that piece of that pile is one plus the size of the smaller pile, right? Thinking recursively one plus, um, the length of X's. And so I don't have to worry about brackets, right? And so, um, we've got to start thinking recursively because our objects are defined. Recursively we've got our list. Our list here a list is defined in a recursive way. It's either a an empty list or it's an object concatenated with a smaller list. And so we define our functions. Um, in this way. Now, if you were dealing with linked lists and you asked, you know what's the length of a linked list, you might write some sort of code that looks something like, um So again, apologies for my mixed, uh, language things. But you might say something like, um while no dot next is not equal to null. Or you could say something like length Ah, and oh, my gosh, in length is equal to zero while not no dot N is not equal to null um, length plus plus. And then, um, node equals no dot Next and then you and you have a base case. If node is equal to null, then you know, return zero and so on and so forth. You might do something like this and this is an iterative approach. This will say OK, I'm gonna count this and then I'm gonna move to the next one, move to the next one, move to the next one, move to the next one. Which approach is better? Why? You know what? Is it better to do it? Recursively? Or is it better to do it in, uh, iteratively Any thoughts? OK, what else? Again? Which approach is better? Any thoughts? Yes. Uh, we'll go the front here. Old memories, the the initative one is more memory. What? Sorry, M More memory efficient. And what did you say? Memory efficiency. OK, memory efficiency. Great. OK, that's a good That's a good reason. OK, this is a fantastic question, which is better? This is what you're gonna get asked, You know, Why should I implement it this way over that way, Right? And the answer is my way is better, but better is not It's not a a black and white thing, right? There's Yes, The iterative approach is is maybe maybe the iterative approach is more memory efficient. Certainly if I were to implement this, um, like, very naively right, the the recursive call. We're building up a recursion stack. It's S, you know, saving all this information in in, um in memory. But if you actually if you if you took the recursive definition and plugged it into a decent C compiler, it would use what's called tail recursion and effectively turn it into an initiative approach and not quick, not keep track of those recursive stacks. And so the the actual, um, in terms of memory, a good compiler will probably turn the it, uh, the the recursive approach into a something that looks like the ITER iterative approach. Right, So memory suddenly doesn't become an issue. So which is better, right? If memory's not an issue? Yeah, recursive Why? Why recursive OK, I love that. I love that thought right. So I which is better I don't know, right? Either one could be better. What's important about which is better is the why, right? Give me a reason why the recursive is better. Give me a reason why the iterative is better. Yes, You want readability, OK? Yeah. Fantastic. Yeah. If we're interested in in, like trying to understand what's going on readability, maybe maybe this one's readability. This one's not, uh this one's not so readable. I. I like the top one because there's less moving parts. It's like Boom, boom! And so it's like, OK, yeah, you know, this is This is there's not a lot going on. There's not a lot of things where I might have inadvertently like if I started with length equals one instead of length equals zero, right? There's just fewer moving parts, right? And so it's it's, you know, it it falls under the category of more readable or something like this. But, um, which is better will depend on your application and your purpose, and and, um, so on and so forth has school is actually very quick. Um, but things like this like, um, this sort of recursive course getting thinking like this is very useful. Ah, is that important? Don't know. Um, thinking like this is very useful. For instance, if you try to paralyse your code, particularly with map and, um and and, um, W, which is another version, right? So mapping, mapping a function across an entire list is something you can do in parallel, um, with lots of processes. And, um, one of, uh, one of Google's drives a few years ago was the idea of mapreduce right, trying to paralyse. Um, a lot of a lot of problems was to sort of convert. You know what was sort of linear code into try and try and find points where you could paralyse it and run it on lots of processes and then gain efficiency like that. So being able to look at code in two in multiple different ways is very, very important. And I'm not just saying that, you know? Oh, we should go with the recursive one because, you know, this is this is it's more mathematically nice. That's also another reason, right? This is this is mathematically nicer than this we can do. We can prove statements about correctness, the mathematical correctness with this particular definition. But there's nothing wrong with this definition here either. Right? And if a push came to shove, this might be the way you you implement it. And so this is something to keep in mind that I'm I'm not telling you that this is a better way to do the world. This is just a different way to to look at the world right and and a and a different way to think about things and to to sort of expand your two books. Um, and if you find it's if you find it's more enjoyable like I did, then you might You might go down this route, but it's like, you know, um, anyway, da da da So my length, Yeah, which one's better? Better is a such a a weird term, um, so we shouldn't worry about it. OK, um, I caught it my length because there's a length function already defined, and it's defined pretty much exactly the same way. Um, I would generally tend to do this. This is sort of like mirroring what Johannes did last last year, Um, effectively redefining the the the basic, uh, basic things but sticking my in front of it just to sort of see, see how it goes. Alright, So anyway, so which is better? Hm. There's much of a muchness. As I said, I like this way because, um, there's fewer moving parts. It's very clear to see that it's doing exactly what it says on the tin. This is computing the length of a list, right? It's It's Either the list is either empty or it's an object with a smaller list. OK, so it's either empty or it's the object, plus the length of the smaller list. Boom. +12. Very nice. Um, and and you don't have to worry about the implementation. The underlying implementation as well, you know, is are we implemented this as a a link list with no dot next or no dot um, future or no dot um, successor or something like this. It's like going Yeah, no, A list is just a list like this. Um, and this is sort of brings me back a little bit to to the motivation for this point. Um, with that that tug of war where I had, you know, fast versus correct, fast and cheap versus correct and and safe. Um, it's Yeah, it's a it's a spectrum. And, um, but what we're you might be interested in in sort of look so, so far, what you've been looking at probably, um, is coding with a view to maintainability. Can I write code that I will be able to update later in the future? Uh, in which case, something like this, with appropriate commenting, might be a better, better, better fit. Um, And here what we're doing instead of looking at code instead of our motivation being maintainability or, um, you know, legacy as it were. We're trying to sort of focus on correctness and safety from the start, right? And now is it maintainable? Is it? Is it? Uh um is it is it, uh, extensible that sort of questions that we're not really trying to address here? What we're trying to address is the the correctness. And so yeah, fewer moving parts Being able to see that it's doing exactly what it says on the tin is what we're trying to aim for. And so this is why, um, we want to We want to implement things in this way. Uh right. So anyway, that's my length, so you can see here. Sort of like defining it. Um uh, so this is sort of like how we define recursively defined functions. Um, and also, um, it highlights the idea of pattern matching. If I take a function, um, I give it an input. My input, sort of. It's gonna say right. Well, what kind? What is my input? And then it's gonna say, OK, my length of my particular input, I'm gonna work out which particular, um, definition applies. Um, Alright. and the other one I wanted to talk about was my map. Right. So mapping I I talk about this, takes a function and maps it across the list. Right? So it takes a function that takes, well, an A to a B. Um, and it takes a list of A's, and we'll give you a list of BS, right by basically just applying the function to every element in that list. Um, so how might we go away and define this? Well, pretty much exactly the same. So my map given a function F, Um, and an empty list like so? Well, I'm gonna apply F to everything in that list. There's nothing in that list. And so I'm just gonna get the empty list back now here. I never used F anywhere. And so actually, I can use, um, what's known as a wildcard token, which is underscore. It's a bit like, uh, apparently rust. Um, for those of you who know rust, this will match. This will basically match anything. It just sort of, like throws the match away. So we use F if I want to use, uh uh, I want to use F somewhere in my definition, but it'll plug in the the thing in there. But if I don't really care about this, um, use underscore again. Good coding practise. It sort of highlights. Um, that, um you don't you This part is uni. This is, uh, is unimportant, right? And then the the recursive case. So given a a non empty list. What's gonna happen? What's what's what? What? What? Will this be Your thoughts? Yep. S is F of X cons. F of X is like that. Um, good thought. Now what the FF takes A's to B's and X's is a list of A's. So F, this is not gonna work because it's gonna complain that I can't apply X's to F. So yeah. Um, Edie Yeah. Yeah. So, actually, what I wanna do is actually re put in my I wanna recursively map F through, um, through X's like so, so close, but yeah, just just missing 11. Critical step. Um, let's see if that compiles. Um, right. Um oh, yes. Someone posted a couple of posts, actually, um, about loading files. Um, call an L or call and load. Make sure you load up the file. Oh, that that works fine. Um Yep. So suck is a is a function that adds one to to integers, for instance. Um and so yeah, So we can see here that my map successfully um, works. So I didn't I didn't have to put put my parenthesis in there, but yes. F of X cons. So I take F of X. So I take X out, I apply F to it, and then I, um, stick that at the front of a list, and then I recursively call to make my my list slightly smaller, like so, um and right. So what I wanted to in particular I wanted to do here is like, um for instance, um so maybe suck suck. Let's call it suck. Suck. Um, I What I want to do is take a list of ins and add two to the add two to every element of that list. Like so. So how could I define Suck, suck? Um, I could I could go with the with the version of, like, my length. Right? So I could say suck. Suck of the empty list is equal to the empty list and then suck suck of X cons. X's, um, is going to be equal to X. Plus two cons, um, of X's like so and so I could do I could do that. Um and so that's sort of like defining it, Um, in the same way that I def define my length. Um, but I could also let's call it S suck again this time. Um, how else could I do it? Well, I could make use of my map function here, and I could go. What I wanna do is actually, um, I want to map. I want to map the function That adds to to a number, so there's no function like S adds one. There's no function that adds two. So maybe maybe I want to introduce, say, a lab term and say, um, was it I can never remember never let me look back. Do do, do do do do Do I see Ah, I just I'll just see if it comes out. Um, yeah, I took my lamb to somewhere. Mm. Right. Sorry. Apologies. My, uh So I could just say straight to take X a map. Say two plus X, um across. Well, so it's like like SS and about X's like this, and apologies. If this I'll go, I'll work out the notations soon. Um, to reload the file. Just control. Ah. Oh, that's fine. Um, yeah. 345. Great. OK, that's fine. Yep. Um right. So I could do something like that. Now, this is good, but this is there's some There's some, uh, programming, uh, improvements we could make on this, um, on this particular definition. So first of all right, we want to think in the abstract. We want to think in terms of functions rather than applications of functions. And so if we ever see, if you ever see something like this, like, sucks up, X is equals blah, blah, blah. X is like so F of X is equal to G of X. Then you can just drop the Xs right there, like le leave it up to to, um, make keep it at a higher level. So So we can sort of start off by doing, um, something like that, right? And they're sort of saying OK, yeah. I'm looking at this at a function level rather than at a the application of a function level. Um and we can, but we can actually improve this even further. Right? So this this anonymous So this is an anonymous function here. This is, like basically a function that, um I don't really care to name it, so I'm just gonna give it Say so on input. X. It's gonna return two plus X. Um, again, this is very similar to the idea of F of X is equal to G of X. What's going on here? Right. How many of you have written something? And I know I have, um of the form You've got something like, if blah, blah, blah, uh, return true else return False. Have you done that? Oh, come on. Right. Yeah. So many people. This is like a very common first year thing. And so how do we improve that sort of code? Yeah, yeah. Just return the condition now. OK, So instead of doing that, we would just say return blah, blah, blah. Now, why is return blah blah, blah better than like the if blah, blah, blah, then return. True else return. False. It's much easier to read. Um, it's easy to maintain if you if you inadvertently switch your true and your fals around, it's like, you know, blah, blah, blah return false self return. True. And then it's like I and it would be a bug that you you would struggle to think, whereas, like going OK, yeah, I this I'm just fundamentally I'm returning this bull in value. Right. Well, the same thing is going on here with this map, right? So So it's the same idea. Basically, I'm saying, if I take an X, then what I wanna do is just add two to it, right? This is, you know, effectively. This is like basically saying, Well, this is really this is just take two and add right, Add to add to, uh two plus blah, right, two plus, um because, remember, two plus is indeed a function that shouldn't be bracketed, But what's the type of two plus? Oh, there's nothing like it. Let's go with plus two. Alright, what's the type of plus two? Um, it will take a number and basically add two to it. Plus two. Yeah. Yeah, so right up like this. Plus two. So plus two, not two plus plus two. Right. So plus two is a function that will take a number and add two to it. So instead of so not plus two plus plus two, I could do plus two, maybe just check spacing. Yeah, right. So instead of doing, like, take X and then just add two to it, right? Basically, I can just simplify that to just plus two, right? There's my function there, and I'm mapping plus two across that thing there. So, um yeah, so just be careful with your your anonymous functions. If your anonymous functions are just like doing one thing to X, then just take that one thing out right again. Think at the think at the higher level, I work at a at at at a more abstract level. Um, right. Anyway, so that's that's map and and anonymous functions. This is sort of a quick recap of what? This long recap. Actually, Gosh, we're already 35 minutes, um, of where we got to last time. Um, now, So what? What do I want to do today? We're gonna be talking. So we're gonna talk about types, um, and induction. So I kind of wanted to build all this up because, um, the particular types I want to talk about so we're gonna start by talking about basic induction, which many of you may have come across in high school or in discrete maths. Many of you have probably forgotten it. Um, if that was when you came across it and we're gonna lift the idea into more complicated types of of, of induction and this is what I was talking about last week, we have our recursive types right, Which we want to have because they allow us to just describe arbitrarily complex objects with very simple rules. And then, um, we have our So we have our recursive types. We have our recursive functions, which lets which basically give us definitions of those things. And then the third piece of the puzzle is our recursive proofs. How do we prove things about these recursive types and these recursive functions? So recursive recursive functions think of also recursive programming. And so induction is induction is the trick. And I think we we talked about it, uh, last last time. Um, we tend to think of recursion as top down. Often we I say Ok, you know, in order to compute the nth Fibonacci number, I need to compute the N minus one and the N minus two Fibonacci number to compute those that go there and they should keep going down. And then eventually I'm going to compute the base case, and then everything's gonna bubble backup. Whereas when we talk about induction, we tend to sort of think about the idea of OK, I'm gonna do I'm gonna prove two things. I'm gonna prove that it's true at the ground level, I'm gonna prove it's true at at Case, um, N equals zero. And then I'm also gonna prove the following result that if I'm on, um, on a step on on case N, then I can get to the next step. I can prove it's true for N plus one. Right, So this is idea. So I'm proving two things prove one. It's true here. And two, if I'm somewhere on the staircase, I can take the next step, right? And then from those just those two particular facts, it then transpires that I can prove that it's true at any point of the staircase. Why? Well, it's true here, So therefore, it's true here, So therefore it's true here and so on and so forth. So I'm not gonna keep walking up and down the stairs. Um, so we get that. So that's how induction works, right? Induction is about proving just two facts, and then that allows you to establish an INF. Uh oh. Sorry. Well, infinitely many facts, eff Effectively. Alright. So what we want to do is we want to prove that some property or some some, um uh proposition holds for all N, for example, N. Um, every natural number is, um, composed of lots of primes. Um, or every natural number is divisible by two. Or it's not divisible by two. I mean, these are these are these are simple things. Um, but like certain other other properties, like, for instance, the sum of the first N natural numbers is N times N plus one divided by two a little bit more complicated thing. So a proposition or a property is something which is either true or false, right? And here I'm gonna plug an N in. And so, you know, P of zero is gonna be true. Maybe P of one might be false. P of two might be true and so on and so forth here. I want to prove the fact that this property actually holds for every single natural number. And so how do I do it? Well, um, I build it around the definition of what? Actually a natural number is right. So what is a natural number or the natural number is either zero. So there is a natural number, right? We'll take zero. It might seem very unimportant, but it's actually kind of critical, because if we didn't have that natural number, we wouldn't have anywhere to start. So zero sort of gives us a starting point. So zero is a natural number. And then, um, I'm gonna define all the rest of the natural numbers sort of recursively by saying, Well, if N is a natural number, then N plus one and I wrote, I've written here N plus one. It's better to think of this as the successor of N, right? The the number. There's a number that's one more than the previous number that you gave me. So don't think of it as plus one. Don't think of it as addition and adding one because, of course, we haven't defined what one is, um, but so zero is a natural number and so therefore from zero is a natural number. I can define the fact that one is a natural number because one is just the successor of zero. I'm gonna define one to be the successor of zero. I'm gonna define two to be the successor of the successor of zero. I'm gonna define five to be the success. And I'm not gonna do that. It's gonna take me too long. But five is the successor of the successor of and so on and so forth. And yeah, and so and then. But then so now that I don't find what natural numbers I should I'm gonna diverge a little bit Here I define what natural numbers is I can define. What addition is right. I was like, How do I define addition? So let's flip. This is this is one of my favourite things. I like doing I. I already did this. Um, somebody I can't remember who asked somebody. Oh, yeah, it was you you asked. Yeah. Yeah. So sorry. You get a you get a 2nd. 2nd round. Sorry. What's your name? Uh, OK, I won't remember that. Um yeah. So addition, Right. Addition. You take what's addition? What's the type of addition. Well, you're gonna take, uh mm. Let's say, Oh, I'm gonna add two natural numbers. So take a natural number and a natural number. If you add two natural numbers, you get a natural number. Right? So we've got addition is defined by. So how would we define addition? Right. Well, we we look back at our our definition of what a natural number is. So zero is a natural number. Um, Or if N is a natural number, then N plus one is a natural number. So we can define addition. How do we define addition? Well, I can say if I take, um any number and add zero to it. I'm just gonna get that number. N. Right. So and And so what? Basically, what I'm gonna do is I'm gonna find out of N for any number, and then I'm gonna say right, Well, I'm basically gonna build it on the recursive definition of M. What's what else could M be? Well, it's gonna be one more than a smaller. Let's call it suck. Let's see one more than a smaller natural number. So say a sack of K. So what would this be? Well, This would just be one more than the result of adding N to K. Right? And you can see here that K is gonna get smaller and smaller and smaller, and then eventually, I'm gonna add N to zero, and then everything's gonna P pile back up, right? And then when people sort of say, Oh, you know, um, blah, blah, blah proved so I had a I had a, um when I was going through undergraduate, there was somebody actually wanted to go through high school, um, 11 of my friend's brothers, you know, C did in his undergraduate thesis proved that one plus one was equal to two and, uh, and we all chuckled. Ha ha ha ha ha. But actually, if you think about it, that's actually a nontrivial result. Why? Because what you're saying is you're saying right if I Well, what is one plus one? It's the addition of zero, the successor of zero and the successor of zero. Right, so that's one plus one. I've literally written one plus one there. And then what's two? Well, that's the suck of suck of zero. And now proving that one plus one is equal to two is actually a nontrivial thing. It was actually quite quick, quite easy, this particular one. But proving two plus two is equal to four is a lot harder, right, And for my foundations of computer science course, which is much more junior than you guys, I asked them to prove that N plus M well, actually, let's just say if you add N and M together, it's the same as if you add M and N together right now. So N plus M is equal to M plus N. If you ask anybody that that's obviously true. If I dare define ad like this, How true is this? How obviously true is it now? It's actually very. It's very it's It's not very nontrivial that N plus M is equal to NMM. In fact, the first question I ask my students and I'm gonna ask you guys now, Um, for the sake of doing it is six times four, the same as four times six. Who says yes who says No two of you? It's really interesting, I asked this. I asked this to students. It's a my Precose poll. I do it before I've said anything and um I've done it for the last three or four years. Like seven courses, basically. And almost without fail it is two thirds. One third, two thirds say yes. One third say no, no, two thirds say no one third say yes. Sorry I'm right is cos I, uh and I don't say six times four. I say I, I literally say, is six cross four. The same as four. Cross six. Right? Who says yes? Who says No? Who's ever written? Um, an Array A 46 versus an array A 64 a four by six array versus a six by four array. Are they the same thing? So if six times four is the same as four times six, how are they different? So th this is a leading question. This is another one of these philosophical questions. The answer is not clear. Uh, yeah. Ah, they represent the same thing. I love that great question. Great point. Great point. They represent the same thing. They're written down differently. Well, do they represent the same? So this is the question literally the question I ask, Is that right? I don't actually say six times 44 times six. I like is six by four or six X four, the same as four X six. And if you think of them as a race, they're not, you know, they they don't represent the same thing. But if you think of them as numbers, yeah, they maybe they both represent 24 in a different kind of way. And so what? The actual point of the whole exercise is that, um, syntax is different from semantics. So syntax is how things are written yet like a suit. Yeah, but no. Yeah, exactly. So this is You already had a kick, Kat. Yeah. Um, yeah, it's the meaning. The meaning is different or can't be the same. Right? So, um and this is this is this is critical. This is This is actually like, I'm sorry, delving into into a lot of things. It's It's about programming languages, right? If I write code, if I literally write code like that, X equals six that Y equal four, print X times Y, right. And I say let X equal four, but Y equal. Oh, Z equals X times Y. Let's say Y equals six. Z equal four, X times Y Are these the same programme? Who says yes? Who says no? Who said No? They're not the same programme, but yes, six times four is the same as four times six. I mean, uh, don't don't worry. It's like, um I'm running at a mile a minute. So you don't have I'm not try. I'm not trying to trick you here, right? OK? Why are these? Why are these programmes different? Who said this is different? Yeah, thanks. Yeah, yeah, but this is the This is the thing, right? Syntax versus semantics. Syntactically They're different literally. The first line is different as things are written semantically it depends. What? What's the end goal? Am I looking at the behaviour? If I ask if the next line is print right, all I care about is the output. If all I care about is the output, then they're the same. They have the same behaviour. But there's there's other subtle things going on, right? If if I execute it on a on A on a machine, right, one of them's gonna put six into the register associated with X, and one of them's gonna put four into that register And so you know, the memory management is gonna be different, right? And this boils down to, like, What if What if instead of something like this, I instead of six and four, I had zero right? And something that takes forever to takes forever to compute, right? And same thing there right now, literally. A good compiler will say, 00 times anything is gonna be zero. So it's never gonna bother working out what Y is right? If X is zero, um, whereas here, you know, I might say Oh, you know OK, I don't know what let let me see what X is and I'll ask what X is and then say it takes forever to compute. And then finally it works out. Oh Y zero I should have done Y equals zero first now I a goer Pilots not gonna know. It's like I'll check all the cases to see if any of it is a zero. A goer pilot will just go say left or right or something like this. Um and so yeah, so suddenly these have different behaviour. One's gonna take forever. One's gonna be executed very quickly, but is X times Y the same as X times Y times X! So, uh, uh, sorry. This is a really random philos philosophical rant. Um but so it boils down to syntax versus semantics. I love I love talking about that. Um, that concept anyway, the purposes of of functional programming. Um, all we care about is is the output right? Does the Is the output the same right? If the outputs the same, then we consider the programmes to be the same. Um and and and yeah, so But how do we How do we show that these programmes are the same? Well, we can actually prove these things. How do we prove these things? Particularly when we've got, um, results based around infinite sets. I want to prove that these that that adding adding N and M is the same as adding M and N, right? They're gonna have the same output no matter what. M and N are right, but there are There are infinitely many possibilities for N and M So I can't just try zero and 00 and 50 and 10 or or can I? Is that a proof? If I just try like 12 cases this is literally what I talked about last week. Is it a proof it might prove some people some people might be convinced, Right? That's what we do with testing. We pro. We prove things to a certain level to a certain standard, and I'll say, OK, let's lift our standard right? Let's prove it. Not just for like all the test cases, we can think of all the special edge cases. Let's prove it for all possible natural numbers, right? And so how do we go about that? Well, that's when we get into involved with, um notions like induction. And so how do how does induction work sort of a reminder? We need to prove two things basically, and and those two things we we prove are based around the definition I, I wanna prove. So what is a natural number? A natural number is either zero or one more than a smaller natural number. So in order to prove things, I need to prove that the result holds a zero. CO zero is a natural is one of my natural numbers. And then, instead of saying, Well, OK, Um OK, I prove it's true. Zero. Let's prove it's true for one more than zero. Let's prove it's true for one more than that. Let's prove it's true for one more than that, I wanna say, No, no, no. Let's just assume I'm somewhere on the staircase. I don't care where and I'm gonna assume for the sake of argument that it's true at my current point. Now I know that it's true right down the bottom, but I'll just say, OK, it's if it's true now it's true for the next step, right? And that that just that one little thing I can take one step from my current position. And then because my definition of a natural number is built up in this, uh, in this way, I it then follows that I've now proven it for every single natural number. This is kind of neat, right? And so here's a Here's an example. Right. So I'm gonna define our function. Um FN, um uh uh In the following way, I'll leave one of these things up. Um, so this hopefully this is the one that's being recorded. Um, so I'm gonna say F of zero is zero. Um, and if N is bigger than zero F of N is equal to two N minus one plus F of N minus one. Right? And I want to prove Well, let's let's let's work out What a few values of F of zero. What FF is so F of zero is zero F of one is two times one, which is two minus one, which is one plus, um, F of zero. So I'm gonna get the The F of one is one F of two is four minus one, which is three plus one. So let's give me four F of three is, uh why am I doing this by hand? Gosh, this definition here Oops. That definition there you can now can't see. Um Well, that's just that's just Haskel code. Yeah, yeah, yeah, yeah. So, um, F takes integers to integers. Um, F of zero is equal to zero. F of, um N is equal to two N minus one plus F of N minus one. Right. Like it's literally has school code there. So if I reload this right and I can say what's F of three F of three is nine. Thank you. F of four is 16. Great. OK, so let's go back to my document camera. F of three is nine. F of four is 16. Anyone wanted to have a stab at what F of N might be? Any thoughts? I mean I. I can tell you what F of N is. F of N is two N minus one plus F of N minus one. Can you come up with a definite diff different definition of F of N? Yeah, And squared. Thank you. Yes. Sorry. Um, yeah. OK, so F of N looks like it should be N squared, right? So how do I prove that? So I want to prove this. I want to prove that for all N F of N is equal to N squared, right? So for all natural numbers, N. Sorry, I should clarify here because F of N is not defined for negative numbers. F of minus one. If I plug F of N minus one in here, it's gonna ask me for F of minus two, and it's gonna ask me for F of minus three, and we can see that going on. If I flip over here and say, what's F of minus one? And it's going to, um what's not F minus one. What's F of minus one? Um, and it's going to sit there and think, um, and kill cos it got too big. So anyway, so how do I prove FN is equal to FN minus one? Well, I do it by induction. Um, this is my proposition, right? So notice if I plug in a value of N, it becomes true or false. And if I put in N equals zero like F of zero is equal to zero squared. That's something which is true or false. If I plug in, N equals 27. F of 27 is equal to 27 squared. That's something that's either true or false, right? So P of N is a is a property of the natural number. N right? And so how do I do it? So, you you basically, um, induction case in induction proofs are are very, um very formulaic. Right? So, base case, right. You take N equals zero. I want to prove that P of zero is true. Right? So I take what is P of zero P of zero is the statement that F of zero is equal to zero squared right. Well, what is F of zero? Let's look at the definition of F of zero F of zero happens to be equal to zero by definition, and then zero is equal to zero squared by arithmetic. You don't need to write by arithmetic if you're giving a proof. OK, um and so therefore so P of Zero is the statement that F of zero is equal to zero square. So P of zero is true. P zero something. It's either true or false, right? And then the inductive case. So, inductive case. What do we do? We assume that the result holds We assume that P of N holds right. Basically, what I want to show is that if P of N is true, then P of N plus one is true. So P of N implies PFN plus one. And so the way you do that is you assume that PFN holds and you show that as a consequence of that assumption, possibly you might not necessarily need that assumption. But by making that assumption, um, you are able to show that PFN plus one holds right? And so what? What is the statement? P of NP of N is the statement that F of N is equal to N squared. So I'm gonna assume that I'm gonna give it a nice name. Um, give it the initials of my father. Um, Ian Hunter or inductive hypothesis. Um, inductive hypotheses is probably more apt. Don't give it the initials of your father. That would be just weird. Um, so yeah, so that's our industrial hypothesis. So I'm allowed to use that fact if I if it ever comes to it, Um well, it turns out it's gonna come up really straightforward, and I want to show that P of N plus one holds So what's P of N? Plus one P of N plus one is a statement that F of N plus one is equal to N plus one squared. Right. So I want to prove I want to prove this. So I've gotta do a list of things. Well, I don't know very much about FFM plus one other than from its definition, right. F of N plus one is equal to two N plus one minus one plus F of N, right again, by definition, right. And that's just going to be two N plus two minus. This is like two N plus one plus F of N. OK, that's just some arithmetic to get there. Um, now what? How do I get from that to N plus one squared. Well, now I use, um the inductive hypothesis. I don't phone a friend. I don't call my father. Um, I use the inductive hypothesis and use the fact that FN is equal to N squared. All right. And so this is equal to two N plus one. And then F of N is equal to N squared right by the induction hypothesis. And then if I do a bit more arithmetic N squared plus two N plus one that simplifies to N plus one all squared right? And so, under my assumption, I've proven that PN plus one holds. And so therefore PN implies PN plus one. So I've got two facts. I've got P of Zero. The conclusion always. I always like my induction proofs to be, um base cases. If there's more than one base case inductive cases. If there's more than one inductive case conclusion so three main topics conclusion. What have we shown? We've shown that P of zero holds and We've shown that, um, if PN holds, then PN plus one holds. Right. So those are the two facts we've shown, Um, And then basically induction by the principle of induction, if you like. Right. P of N holds for all natural numbers, Right? Makes sense easy enough. Great. Let's get more complicated, and then we'll have a break. So what are we gonna do? Well, we're gonna talk about induction on lists. We're gonna generalise it. We're gonna talk about it, OK? So we're gonna we're gonna build this idea, so I should go. So we we'll walk through that induction. Yeah. So in in list. So what's a list? Well, we go back to our recursive definition. A list is either the empty list or it's an object consed with a smaller list. Uh, very similar to the definition of a natural number. Right? The only difference is like here, like the the plus one has, like no data, no additional data associated with it. Like it's just it's just one more object. Whereas here, we've actually got like, um, this object has a value. Has a value X. Right. Um And so if I want to prove that a property holds for all lists here. I'm actually technically what I mean is finite lists. Why? Why? Why? Well, here's a really cool thing. Um oh. Killed the killed, the whole programme. Um right. I'm gonna find my object ones to be one consed with the object ones. Is that OK? Do you think I can do that? No. Yes. Let's see. I mean it just OK. Didn't complain. What is this object once any thoughts? Well, I mean, here, I've got a list construction, right? I I've just It's the object one at Pender two or Prepend two. Sorry. The object ones. It was basically the object one pointing back to yourself. So it's a list, because this is the list constructor. So it's gonna be a list, and the first object in the list is gonna be one. Right? What's the second object in the list? Gonna be so I can take I can take I can take 100 items of that list. I could take 1000 items on this list, right? It's just an infinite list of ones because the one followed by well itself, which is sort of like one, followed by followed one, followed by one, followed by one and so on and so forth. If I try to, if I try to print all of one right, I run to a bit of a problem. It goes into an infinite loop, so Ones is technically an infinite list, so you can define infinite lists in Haskell. This is not a problem because Haskell's a lazy language. It will evaluate as many ones as it needs. So when I say take, take a Hun 1000 ones, it's like, I'll take one. I'll take one. I'll take one. I'll take one. I'll take one and I'll take one. And then it's like, OK, I've taken 1000. I'm done. It doesn't need to keep evaluating what ones is. It stops evaluating what ones is. It says it's done. You know, it gives me a list of 1000 items. If I take two, give me a list of two items. So one's sitting there like defined but not not evaluated, if you like, And then if I try to evaluate it, it goes into an infinite loop. So anyway, So, um, yeah, so the way I want to show you if I wanted. So there are infinite lists in high school is basically the upshot. So let's let's not talk about infinite lists. So in order to deal with infinite lists, you need to deal with what's called co induction. Um, and that's way beyond this course. Um, what I wanna do is I want to prove a property holds for all finite lists. So how do I do that? Well, I need to prove, Well, I need to break it up into the what? What a list can be. This is either the empty list or it's an object, followed by a smaller list. Right? And so what do I do? Well, I say, OK, I prove if I can prove that the property holds for the empty list and assuming that the property holds for the smaller list, I can show it holds for the more complicated list, then combining those two things there I can get. I can prove that the result holds for all possible lists. Why all possible finite lists? Because every single finite list is built up from those two. Those two things right? It's either it's either the base case or it's multiple applications of the recursive case, which boils down to the base case. So here's, um, one last demonstration. I want to prove I want to prove that map preserves the length of its input. What do what do we mean by that? Well, basically, um, my statement. So if I take the length of if I map F across X and take a look at the length of that list, then that's going to be the same as the length of Xs, right? And I want to prove this is true for any list X's. So this is my proposition. I'm going to call this proposition the X's. It depends on the value of X's, whether it's true or false, right? And so now I want to prove that this is true. I want to show that P axis holds, So I want to show that P axis holds for all finite lists. Right? And I'm gonna do this. We proceed by, um, probably a big space here. Induction on X's. Now, what do we mean by induction? You might think, Oh, we we're gonna do it by induction on the length of X's. But I'm kind of like using length as part of my thing, and it's got boiling back to Let's not do it on the length because the length is sort of like built around the definition of of the structural properties of X. So, actually, what I'm gonna do is I'm gonna do it by what we call structural induction. I'm gonna build it around the structure of X's, right, and then that's That's what I mean by prove. It's true for Let's see prove it's true for the empty list and then prove it's true for ex cons. Xs. So again, right, So base case, Right? So I wanted to prove that the property holds for the empty list. OK, so what do I do? So I want to prove that the left hand side is equal to the right hand side, so we'll start writing the left left hand side So length of map F empty list. What's that? I don't know, but I looking back at my definition of map, it's just No, let's go here, pick here. I'm gonna use my map here by my definition of map map of F of the empty list. It's just the empty list. So my definition tells me that this thing here is just equal to the empty lists. So this is equal to the length of the empty list by the definition of map, right? And but that's my But that's now my proposition. That's what my proposition was. Is this When I replace X's with the empty list is equal to this where I replace Xs with the empty list. Right. So therefore, P of Empty List holds pretty straightforward inductive case, right? You assume it holds for the simpler structure you assume it holds for for X's. So what I wanna do? I wanna assume that the property is ho true for the for the smaller list X's. In other words, the length of map F um X's is equal to length of X's, right, So that's my inductive hypothesis, right? And now I want to show that it's true for ex cons xes right? I want to show that the property holds for X Cons Xs right, So this X is here matches that X is there, right? And so what do I do? So I start with length of map FX cons, xs alright And what do I uh So what can I do? Well, I don't know very much except well, I know the definition of map of F cons. F uh ba ba map of FX Cons X's right. It's written here. Voila. OK, so I am flipping that just for the recording. So this is so I'll just leave length alone. For the moment, I can delve into using the definition of map. This becomes FX Cons Map FX S. OK, now watch. So that's so That's definition of sorry. Definition of map again, right? So this is now the recursive part of the definition of map, right? So that's why this is equal to this. What now? Well, I can't do anything with math FX SI mean I could do something if it was length map, FX, S. But it's not quite that yet. Um, but what I can do, I've got length of something con something. And so if I go back to my definition of length right, which is up here? Length of X cons, X's or something? Cons or Y Cons. Ys, if you like, is one plus length of Ys. So this is one plus length of this thing here, right? And that's just the definition of length, right? So all I'm doing is unwinding definitions, right? And now length map. FX, S. Oh, that's that's I've got that. I can replace that with that. So what is that? That's just length ais right? So that's my induction hypothesis. So this one follows some definition. This one follows from definition. This line follows from induction hypothesis. And now what? Now where do I go? Well, now this is where the and this is where we start to. Um, remember that when we have equality here, it's it's mathematical equality we can swap. We don't just swap the left hand side with the right hand side. We not swap the right hand side with the left hand side. We can go in both directions. It's it's literally equals. So here I can go from one plus length xes to just length of X cons Xs because that's sort of going, going the definition, but in the opposite way. And don't. But don't think of it as going the opposite way because we've got equality here. So I, I mean Xs right again. So this is just definition of length, but if you like it it's backwards, right? It's basically this. You know? Normally you think of it like this evaluates to this, but it's like this is also equal to this, right? And so now. And that's and that's that's my result. That's all I That's all I need. Right? So P of X cons Xs holds, right. So, in conclusion, what have I have established? I've established that the property property is whole property is true for the empty list. And if the property is true for a list, any list, then it's true for any list built up by throwing something in front of it, right? And so those are the two things I've shown and therefore by the principal of structural induction, P of XS is true for all finite lists. Xs right, straightforward structural induction is not actually all that scary because most of it, um, works out from from, um, following definitions and following your nose. Um and so what? I just want to say so. Reasoning about functional programming is a combination of equational. Reasoning is using these equalities and structural induction. Um, and I should point out that structural induction doesn't just work for lists, but it works for basically any recurs or any data type or or any other kind of data type. Um, but in this course, um, for for the sake of, like, not stretching you guys too much, um, we'll keep it to lists and and simple data types. Just just so you're familiar if you want to do more, take 316141614141 theory of computation. We kind of dabble a little bit on this 9020, right in 9020, we do Induction over trees. That's an assignment Question. It's like the It's the It's the It's the equivalent of math 1081 for the for the Masters students. Um but yeah, right. Uh um, are there any questions on that? So far, other than can we have our food now? Yep. Why doesn't it work for infinite list? Because we basically because of the the, um, idea that it's it's gotta it's gotta be grounded at some point, right? So it's like, um yeah, II I If I If I didn't have the base case, if I just proved that PFN implies PFN plus one right. Um, I there's no starting point. It's like, Yeah, as long as I can get onto the staircase, I can get anywhere up it. But I haven't proven that I can get onto the staircase. And the problem with infinite lists, like, for instance, ones is how do you get onto the staircase in the first place? To get onto the staircase, you have to prove it's true for the whole list, in which case you're proving it's true for the whole list. So it's kind of like it gets a bit circular, but great question. Anyway, have some food. I even brought because of complaints. Last time I brought a rubbish bag so you can dump your rubbish in this one. You can throw it out later. Um, grab some food. I'm gonna split it up so you can spread out. So it's nobody. Everyone likes the plain crisps. So it's like I brought plain crisps. Is she, um and we'll be back in five minutes,

SPEAKER 2
so Yep, yep, yep, yep.

SPEAKER 1
So So, um, basically the way it works is is, um you you build it around the the structure so as to say, OK, if you if you want to find a list? Um, you know, there are multiple ways. So if you're going with with the way the list you can say like empty list is a list or, um, it's a concatenation of two smaller lists, like So, um, or it's an object Cons with a small list. Right then it's like then your, um so this is your definition. Then your your induction proof has to deal with all those three cases, right? So you prove it's true, you prove it's true for the empty list you prove. If it's true for Xs and it's true for Ys, then it's true for X's plus plus Y. No, this isn't this isn't CO so co induction works the other way around. So, um, the way the the general structure here is that we start from a small set and we just keep adding, adding more and more and more until we basically, um and we sort of assume that the the the first point where you don't add anything more. Um, they Now you've proven everything in that set. So this is like so if you think of the natural numbers, you say zero is a natural number. And if N is a natural number, then N plus one is a natural number. Yeah, and then the natural numbers is the smallest set. So N is actually the smallest set where this applies, right? Because this would also be true for the integers. Zero is an integer. And if N is an integer, then N plus one is also an integer. Abso it's true. It's true for the reals. It's true for the rationals it it's true for true. Yeah, it's true. This is true for the reals, right? Zero is a real And if N is a real, then N plus one is a real so yeah, no, no, that becomes a different question. Now that becomes a much different question. Yeah, so? So the natural numbers is technically the smallest set. So basically, you you do this. You keep going until you don't go it anymore, right? And the first point where you don't get anymore, we call that the natural numbers. So it's like it's It's a weird thing because it's like you're doing a finite process, but you do it infinitely often, so you get infinite, infinite things. But it's like the natural numbers is the smallest set where this applies. And so, um And so the idea of induction is basically what? Where if we prove P of Zero and P of N plus one? Uh, sorry PN plus PM plus one. Then the idea is that PN holds for the smallest set defined in this way. Right? So PN will hold for the so if you do this PN holds for all the natural numbers. But it doesn't hold for all the integers. Even though the integers will satisfy this definition. Does that make sense? So So it's it's I mean, the idea is like going Basically we've proven this and then we prove this and then we prove this and then we prove this and it get bigger and bigger and bigger, and then eventually, at some point, this is just gonna stop right? But it's like it's at at at Infinity. It stops. And then the point where it stops is what we call the natural numbers. And it's the same idea with the proof. It's like we prove until it stops. And this is what we call the least fixed point. So the first point where it where it stops when we're building out with co induction. So induction That's induction with co induction. You go the other way. Essentially, in intuitively you start with. It's true everywhere, and then you slowly reduce you eliminate the cases where it's not true. So you start with a bigger set and you sort of like get smaller and smaller and smaller until you don't shrink anymore. And and so that's what effectively co induction is. So it's basically it's gonna be true for everything that way. And so when you're talking about infinite lists in order to sort of, like, include infinite lists in in this, you need to sort of like give a co inductive definition as like so it's it's a little bit backwards, but it's like, um, yeah, it's It's like super super deep stuff, but it's like, um but yeah, yeah, yeah, no, but the idea of least fixed points um, we touch on this in 3153, next term if you want to do that, um, but like least fixed points is is computation right? It's basically what happens when you iterate when you when you compute things, you Yep. Yes, yes. Yeah, yeah, yeah, yeah, it's kind of Yeah, it's like, Yeah. Yeah.

SPEAKER 2
So what I was wondering is like, if there's, like, a sort of pre image function Um, I don't know.

SPEAKER 1
Um but it'd be a good question, a question about

SPEAKER 3
induction. So why wouldn't it be? Why isn't it possible to, uh, look at the success though the you can You can You can, So you

SPEAKER 1
gotta You gotta do it. You gotta work around the definition. So we define natural numbers like this. Um, if you wanted to say include the So here it's just like the national numbers in terms of zero and the successor if you want um uh, include the predecessor, like, say, for instance, you want to do the the integers like you'd have a you'd have an extra definition. You say zero is an integer. Um, if N is an integer, then the successor of N is an integer. And if N is an integer, then the predecessor of N is an integer. Yep. So Yep. Yeah, so I mean so this I mean, this it was wasn't Yeah, you can pick. You can pick anything. So zero is just this just says we're on the staircase and then it's like we can go up and we can go down now what's the deal? We've got a more complicated definition. If we were doing the proof by induction, where we go here is that we have an extra step. In some sense, we need to prove that we need to prove that the property holds at zero. And then and then if it holds an N, then it will hold an N plus one. And if it holds an N, then it holds an N minus one. Now this might look like the same. You know, it's like almost an if and only if statement here. But it's like actually, when it comes to the integers, what we might say is like, um if N is in ZN, plus one is in Z, I would say, like if N is in Z and N is bigger than zero and I would say and N is smaller than zero, right? And sort of like OK, now, now this only applies when N is bigger than zero. This only applies when N is smaller than zero and it was like OK, Yeah, we're getting a little bit weird here. Like I haven't defined what bigger than zero and smaller than zero is. And the don't really say like a N as in Z, and it's built up from plus ones. Then N plus one. You can keep building up by plus ones if it's N and Z and you built up from minus ones and and so and so, Yeah, but But basically, as your definition gets more complicated, your induction requirements get more complicated. Correspondingly makes sense. But great question. Uh, it looks like I under it. Right, OK, good to see. Keep coming on Wednesdays. I will keep bringing more food until we'll find a nice level playing field. Some great questions in the break. Um, I can talk for hours about induction and and co induction. Um, another area where we talk a little bit about the concepts. So, um, I was talking a little bit about. So what you do with induction is you prove, um, inductively defined objects. We think about them. We we sort of start from a a core and build up, and then the the end result is the sort of the the the limit, Uh, the the point where we don't build anymore, right? So the natural numbers are the smallest set where you start with zero, and then if a number is in it, then you add M plus one. like the integers also satisfy that property, and and the rationals and the reals, they all satisfy that property, but they're somewhat bigger than the natural numbers. Um, and it's the same idea with with induction. Induction will only prove it for the smaller set as you build it up is what we call the least fixed point and least fixed points come up all the time in when you're analysing programming, right? Because basically, um, the recursive calls or iterative calls are just generating these list fixed points. You're just you're just keeping. You're doing extra stuff, extra stuff, extra stuff until you are done effectively. You don't add anything more. Um, And so if you want to know a little bit more about lease fixed points and and and programming um, my course 3153. Where we look at, um, algorithmic verification. We touch a little bit on on lease fixed points there. Um, so there's there's Yeah. So 31614161. Talks a little bit more about, um, other kinds of induction. Um, 4141. We also do We do induction over regular expressions, right. You give a recursive definition of a regular expression. You want to prove something's true for all regular expressions? Um, so that's 4141. Um and there's lots of things. So basically, um, I think I I I'm quite happy to sort of point out that as your definitions get more complicated So I had another question about you know what If you added predecessors, right, How would you do induction there? So basically, as your definitions get more, more complicated, more involved So zero is an integer N is If N is an integer, then N plus one is an integer. If N is an integer and minus one is an integer um, the corresponding induction matches. Uh, you need to prove that the proposition holds zero. If it holds for N, then it holds for N plus one. If it holds for N, then it holds for N minus one. And now here it's a little bit a little bit iffy because, like sometimes you you don't want to sort of, like, duplicate it like I prove it. It's true for five, based on being true for four and if true for four, based on being true for five, you don't want to get this circular reasoning. So you sort of, like split it up into cases where where you're bigger or smaller than zero. And the same thing applies for, um if you had, like, a more complicated definition of a list. So if you want to split your list not just by a first and the rest of the list, But like, for instance, in merge sort, you actually divide your list in half. So your recursive definition of a list is a list is either the empty list or a list containing one item if you like, um, or it's made up of two smaller lists of approximately the same size. Um, so you don't have this case, but your your definition looks something like this, right? Um, with some requirements on, uh, on Xs and Ys. And now So now your induction. Um, your induction proof gets a little bit more complicated. Um, it matches but it matches the idea. Basically, it's true for the base case. And assuming it's true for the simpler cases, then I can prove it's true for the complex case. And that's all. Structural induction is is basically assume. It's true for the simple cases show. It's true for the complex case. Um, anyway, that's enough about induction. I talk far too long. Let's talk about data types. Let's go back to some programming. Um, Alright, so we want to introduce. Maybe we we want to, um, define our own data types. It's very useful. Um, you we define objects all the time in Java, for instance. Um, ens we play around with with ens. This is something this comes from Johannes, of course, who had to apply for, um for, um permanent residency? Um, similar for my my wife. She also had to apply for permanent residency when you actually have to apply for permanent residency. Um, there's there's a number of rules you have to meet. You have to meet. Um, you have to submit, uh, uh, some primary documents or a at least one primary document, and then match it up with secondary documents. Basically, you have to have a total of 100 or more points. And each of these items sort of for give you a certain number of points. So, for example, a passport, um, is a primary document. It gives you sort of 70 points, um, and secondary identification like driver's licence or student ID. Um, the first instance of that is worth 40 points, and then subsequent ones are worth 25 points, and then things like credit cards are worth 25 points. You don't need to know so much about the the details, but basically, at the end of the day, you need 100 points to verify your identity. Um, so let's sort of work through a bit of a case study. You work for a bank. Your task is to write a programme that calculates the total point value of a given list of documents. Right? So we want to, um, we wanted to sort of set things up. Let's let's comment out this function. Cos F is a silly name for a function. It's just gonna make things messy. Um uh and so, so far what we've seen, we've seen the idea of introducing what we call type synonyms. So type synonym, um is like using using, um, an existing type or or, you know, a very similar idea. So I remember last I last time I touched on the idea of maybe, I think I don't know, um, of the of the type keyword. So the type keyword basically is just as well as we saw. We saw this. So, um, we have a string is a synonym for a list of char, Right? So that's that's what's defined formally. So type synonyms. Basically, we define a A type, and we might do it to to aid with readability. So, for instance, here we might say, a document to find our type of a document. In this case, Well, we don't really have very much, um, to play with, but let's just say OK, so we want passport or a birth certificate. You know, all I all I'm really interested in is the the object itself. And so I might just say OK, a document is a is a string, and so, like, for instance, like, um, so passport passport would be a document and so on and so forth. And then I say right, OK, I want to define my my function points. Um, it's gonna take a list of documents. Um, and give me an integer. You gonna cal calculate that value for me? Like so, um, and then So how might I go about defining that? I might sort of say OK, Well, um, OK, if I If I don't provide any documents, then it's gonna be zero, um, and well, if I give you a list, if the first item in the list, um, is a passport, um, and then the rest of my list is something like this. Then it's going to be something like, um, what did I say? 7070 points, 70 points. Plus how much points? Um, Xs takes right and I do the same thing for birth certificate and so on and so forth, I might say, um, points birth certificate. Um, X's equals 70 plus point sixes. Now, it's gonna get a little bit complicated when I get down to the secondary items, but we, um But before I get there, there's a bit of a There's a bit of a bit of something ugly going on here. Has anyone sort of, like got any objections to me Going this down this route. Your thoughts? Yeah. Brody. A lot of repetition. Sure. Um, good point. That's Kit Kat worthy? Um, yes, a lot of repetition. There's something more fundamental. Yes. Um, it's OK if I got a list of objects. Like, if I've got multiple passports, is like, um let's let's not worry about that. But the good point? Yes. You know the idea of uniqueness. Um, certainly, when I might have multiple credit cards, I might be able to use, like, multiple credit cards. So let's not worry so much about duplication of things at the moment, But good point. Anything else? Yes, it does make it hard to maintain. Let's not worry about maintainability. Yeah, sure. Yeah. So there's gonna be an implementation issue down the track, but we We'll do that. Yeah. Um, Sim. Yeah, exactly. Right. I've said points is a function that takes a list of documents, right? But a document is just a string. So, in theory, I should be able to ask, you know, what's the value of points? Um, like, hello world, because these are strings, right? And points is a function that takes, um, strings to to Uh oh. Sorry. List of strings, um, to two things. So, like, basically, yeah, it's I've over specified points, if you like. It was like points points is the the co domain of points. Alright, let's start another kind of the domain of points is too big and I don't want points to be defined for any string. Alright, so what we would rather do so instead of doing something like this is I would sort of like say OK, I want my documents not to be like any string, but, like only just a sort of a limited subset of of strings or or have have, um, a limited type. And so that's so type synonym the the keyword type. Um so for type synonyms keyword his, um, type, he just basically just like, uh, just gonna give you an association between routine things. Um, if we want to create our own limited sort of range of of da of data objects, so like an EAM, if you like, we use the word data and so I might say here data a document, and then I can sort of specify, um, what my list of documents are So I could say Like, um so a document is either a passport. Um, or a, uh, birth certificate? Yes. Um, or a credit card. Um, or what else is their driver's licence? Um or, uh, uh, Sun nai. Now note here. Um, because remember, data types have to have capital letters. So all of these things here have capital letters. Right? But in particular, um, a document has a capital letter, so document is my type. But then these are These are what we call different constructors. So this is like an enumerated type. Um, right. Basically, um, that's just for the sake of readability. Let's put them on. Yeah. Thank you. Down there. Right. And so these are all separated by bars. So it's like, um and it's It's like a union type a some type, right? So a document can either be a passport or a birth certificate or a credit card or a driver's licence or a student ID. Right? So if I if I load up well, yeah, and complain, I can ask, you know what? What's the type of passport? And it will say a passport is of type document, right? And so now I can sort of say, OK, my points. I'll get I'll still get back to this in a second. Um so points is a function that takes a document. So I list of documents, um, to, uh and introduce, um and I can say right points of, um, so points of a passport or points? Uh, du, du du du du. Now what do I want to do? Points. So points and list of documents. So points of empty list is equal to zero and points of, so if I have a passport and a smaller list, right. So now my the first item on my list is a passport. My, you know, so on and so forth. So you can imagine, um, I can build up a list, say, of a passport and a credit card and a passport, multiple passports or whatever, like so on and so forth. Um, and I can ask about that, and that's gonna say, Oh, it's a list of documents. Great. Fantastic. I realise this is getting a bit hard to read, like so on and so forth. So yeah, so ask. Ask about that type now and through and through a hissy fit in a second because, um, if I type, if I just say passport, it, um, actually doesn't know how to how what to do. Right? So there's a method. Um, sorry method. There's a function called show, um, right. Which basically converts your object into a string so I can show one, and it converts one into a string. I can show a list of things, show a list of things 123, and convert 123 into a string. And so then, if I type 123, right, one. If I type that, um, it it tries to pretty print the result in order to pretty print it and needs to convert it into a string. So it will call show, and then output the result. It'll print the string, um, to to the world. Now, if I try to show passport right, it throws an arrow. Because basically, when you define when you define a type, that show is not not a guaranteed right. There's no you, not you need to basically define your own, um, way of converting something to a string. Thankfully, um, uh, if you want to just do things very basically, you don't. You don't want to deal with anything too complicated. You just sort of say, OK, derive show. And that will sort of, like, just do the default application. So I do something, like, say, deriving show. Like So, um, let's just comment this out for the moment, because right. Um And so now I can say now I can ask for passport, and it'll print out the word passport. So if I get my list before of objects, So a list of passport, credit card and passport, that's just gonna go passport, credit card and passport. So the default, um, behaviour. If I just say deriving show is to just literally print out the the constructor. So these are we call constructors. So this is like so a document can be constructed by calling passport or constructed by calling birth certificate or constructed by calling credit card. So? So, like, it doesn't make the distinction between a constructor and the object it constructs. Um, right. So the these are instances of the type document. I should should clarify that. Um, now, what else can I What else can go on? Well, I can ask, You know, is a credit card equal to a credit card. Um, and it will throw a hissy fit. Right? So if I have, like, one credit card and another credit card, instances will say, I don't know how to check if these things are equal. Um, And so another thing you can derive, um, is EQ. And when you start driving more than one thing, you you pair them up. Um, so EQ will also let us, um, check if the object credit card is the same as the object credit card. And so again, EQ does does the default. It'll ask if you ask if is a credit card equal to a credit card, it will say yes if it asks if a credit card is the same as a passport, it'll say no. Right? And so this is these are so here. I'm using the default behaviour. Basically, if you use a different constructor, it gives you a different instance. If you use the same structure, it gives you the same instance. Um, but you can define your own equality, right? And so this is the the deal. The equality, The Equality Operator is in itself a function. If you look at it says OK, um, as long as my a is of type EQ, Um, then this is a This will take two A's and give you a boo. Alright, so here we've got this double this double arrow here is implication. Think of this as implication. If a is of type equality, then, um, this will be a function of a A to pull. Right. So the upshot is this isn't defined by default, right? This is this is this is I I imposed, right? So anyway, so we define what a what a document is. And then now we can carry on. And, um, why was it complaining about points before? Uh, probably because points was defined. So my points, let's go with camel cut. Um, my points, right? No, it doesn't like that. Do do, do, do, do, do, do, do do do Do do Oh, yeah, OK, 70 plus my point. Uh, sorry. Yes. I don't need my points. Let's go with points right and so on and so forth and so we can carry on and like, define this for for each of the individual one. And now we get to Brodie's point about duplication of code, right? So what What I want, You know, if I'm here, I'm sort of, like ironing through things, and and also, um, point raised earlier. What about secondary items? Like the first time I come across a secondary item? It should be, um, defined as as 40 points. But then, the second time I come across a secondary item, it should be defined as 25. So, um and instead, what I might do is sort of say, OK, let's go with say points. Um, X cons X's is equal to and now I say, Right. Ok, let's, um let's do something like, uh, so it's gonna be 70 times. Um, primary points plus, uh, 25. Let's go times tertiary points to do the tertiary points because they they they're always 25 and plus, and I'll do the secondary points additionally now. So here I'm doing, I'm coding in a top down manner. I'm basically sort of like, um, work. Sort of like initiating what? What I want first. And then gonna, uh, fill in the blanks later on. Right. And so here, Um, I don't think I talked about the wear clauses last time. And so we? We've seen this at the start of every everything. When I introduce a A module, I start by saying module third lecture blah, blah, blah. Where and then we just sort of like leave that hanging. And basically, the idea is where sort of just grabs, um, sort of what you write after the where and incorporates it into the definition. So you can sort of like, um, define things later at a later point using the where clause. So here I said, this is 70 primary points and 25 tertiary points and secondary points Where and then in the next line, I'm going to define what these what these guys are where primary points is. Well, let's start with undefined for the moment. Um, secondary points. It's undefined. Tertiary points is undefined. Just so we can sort of, um, hopefully double check that this is, um, not gonna throw up any any hissy fits. So this is why I just keep checking it all the time. It can. It It, um, reloads the file without any complaints. Um, so we know we haven't introduced any, uh, any typos. So what about primary points? How do we work out what primary points is. Well, what I want to do is I guess I want to look through my list and work out which ones of those, uh, primary documents. Um, and there's a nice little function for this called philtre. I haven't covered philtre but philtres a little bit like map. Um, if you what's what's philtre do? So let's look at the type of philtre. Um, it takes a function that maps A's to bullion A's to true and false and a list of A's and gives you back a list of A's so intuitively, what you would think of do is that basically, it applies this predicate to every object in the list. If the object says true, then it throws it into the list. If it says false, it throws it away. Right? So it's just like if I want to check, like, take all the even ones I would say I would philtre by. You know, even in this particular case, I'm gonna philtre by, um, say a function is primary and I'm gonna define this as primary up here. So is primary, right? Is primary passport primary? Uh, passport is a primary. Um source that through capital T not by miss. Let me see. Yeah. Should be, um, birth certificate. That's true. I don't look like in it, I think. I think, um, And then well, anything else, um, is not primary. Right. So here I'm using. I'm making use of the wild card thing. Now notice here. I haven't given the type definition. You don't have to give the type definition. Um God. OK, something's gone wrong. Maybe. Oh, because I'm down here and the state is undefined. I'm just ok, um, so I've got a function. Is primary which sort of checks? If if we've got a primary. So we're gonna philtre um, my actually, I don't need to I don't need to break this up. I'm just gonna go with an exis. Um, I'm just gonna take all the the primary ones on on X's and were actually my primary points. Um, or 70 times primary primary items, perhaps, but primary items items is better. No, I believe there's points. Um Alright. So that's gonna give me a list of all the PRI primary items, but I don't want a list. I actually want a the length of that list and so I can just use the length, um of and let's just make sure we've got the bracketing around the right way. Um, like so. And then I can do the same thing for tertiary. Um, like so on and so forth. So copy that credit card is tertiary, and then anything else that is false. Oops. So and then what about secondary items? Well, now secondary ones. Um, we've got to deal with the we've got to deal with the case of, um, a first item. Um, so secondary points it's got to be equal to so sign points is equal to, you know, how do we do this? Uh, du du du, um how did you do it? Uh oh. Sorry. Is that just just blanking on the, uh, on this amount? Um, uh, yeah. Right. So now I'm going to introduce, uh, another, Another bit of syntax. So, um, we can do case, case analysis. Um, so I'm basically gonna do, um uh, case thing. It was like, uh, I can remember, um, So if X is empty, then it's just gonna return zero. if X's is a what do I do? Um, that's all and exits first for for philtre secondary. Get all the secondary items first. And it's going to be, uh what is it? 40 plus 25 times the length of X. So we, uh Yep. Oh, sorry. I'm doing the doing The calculation now, right? And then I'm sure this is I'm sure I've dropped some some things. So Right, so what am I gonna do? First of all, define is secondary. Secondary. Um, what have we got? Driver's licence three is secondary. Um, student ID. That's true. It is secondary. Anything else? False, right? I do realise we we're running on time and physical work. No, it doesn't like that. Um, why is it Thank you. I can Yep. Thanks very much. They gone dry, and that should be tertiary to Cherie, right? And then there's gonna Oh, it worked. Brilliant. Um, right. So, yeah. So the way you do case So yeah. Apparently the way you do case statements is like this, right? Um, it's good. Um, so notice here. It's the arrow. When we were doing, um uh what? What else do we, uh, when we did the the guard was equality. Right? Um so when we did the guard definition of of function. It was equality. Um, right. And so here it's, Um Yeah. So what I'm gonna do, I'm gonna philtre X's by is secondary. That's gonna give me a list of secondary items. If I've got an empty list, then a then there's no secondary item points. If I've got a non empty list. So an object followed by a smaller list, I'm just gonna take, um 40 points for that first object and take the length of the the rest of the items and multiply that by 25. And then that should hopefully give me, um if I go back up to my list of items and I can ask, um, how many points? If I had two passports and a credit card, I would get that fantastic level
