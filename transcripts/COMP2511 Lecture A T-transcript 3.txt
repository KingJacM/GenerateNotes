SPEAKER 0
Hello. Uh, can you hear me here? Hm? Good. Ah, online If you can hear me, please say yes. Um Yep. Hello? Ok, can you let me know if you can hear me? Please? Can you hear me right now? I'm just typing something. Ah, let me know. At least you should be able to reply to this message. Uh, it looks like everybody is in a relax more. No, you can't hear me. OK, uh, I don't know what K. Uh Okay. Um hello. Can you hear me now? Can you hear me now? Anyone? There's some change in this. Hello? Hello. Does it come to the speaker or not? Huh? It did work. Everything fine last time. I think this is Hello?

SPEAKER 1
Hello? Hello? Hello? Hello?

SPEAKER 0
Hello? Hello. That's the problem. So there's eco here. Coming. Hello? Hello? Ok, can you hear me? Yeah, but I need don't need that echo here. Why? It is giving me the feedback. OK? Can you hear me? Hello? Hello? Yeah, but there's an eco I need to I don't know why. Hello. Ok, let me try another mic. Hello?

SPEAKER 1
Hello? Hello? Hello? Hello? Hello, I think.

SPEAKER 0
Hello. Hello. I know I know.

SPEAKER 1
I know, I know. Hello. Hello.

SPEAKER 0
Hello. Just a thing. Jesus Christ. Hello. No, no, it's not very pleasant, isn't it? It's a very complicated OK, this is zero. So that's the speaker I don't want Hello? Hello? Hello? Oh, my God. Yes, it works now. Okay, so remind me next time so it somehow goes to Exxon. HDM. I don't have any idea about that. And, uh, I hope this works.

SPEAKER 1
Hello? Hello?

SPEAKER 0
OK, now, I was stuck in the theatre now, Alistair. Now I think it should be all fine. Uh, please tell me without echo. It should be fine now. So you had to go to the speaker and somehow disable that, OK? Can you hear me now? Guys? I hope you can online people. If you can hear me, please let let me know. Say yes. That's great. Yeah, Great. OK, so let's get started. Um uh OK, so, um, just looking forward a little bit. Uh uh. We will be releasing your assignment on Thursday. OK, uh, but we have a lot of interesting things to cover today. So Thursday, uh, we will release the assignment. You still have the end of this week and three weeks basically after that. OK, so three weeks 34 and five It's, uh, Friday 5 p.m. is the deadline. Now the assembly is based on what we are covering already. And, uh, today we a RE going to cover a lot of interesting topics about object oriented progra mming. And please ask me if you have any questions. Now, having done all this, I need to do one thing where I need to disconnect everything. Unfortunately, um, be Oh, OK, let's go through the slides first, and then I'll do that later on. So the we we talked, uh, we discussed here about the the course review introduction to Java. Uh, we are currently talking about object oriented paradigms. Um, and we talked about abstract classes and we talked about how to create a class so on and so forth. What we're going to today discuss, continue our discussion on that. And, uh, initially, I'll go through lecture slides, explain all the important concepts to you, but then we have examples for everything discussed in this lecture slides. So, uh, I will go through that also at the end of this lecture, and I really strongly recommend you guys to download this code and go through every example Every example Go through. Just don't think that I know the Slav is in the slides, OK, The reason why we have given you example is that they cover every important topic. You need to know in this course, OK, And the code is that you don't need to type from scratch. You can just run it, modify it, run it again, see the behaviour, understand? So for example you know qualifiers We're talking about what is private and public and protected Well, you know all of them. Can you just change those qualifier and see what happens? Can I see it in the subclass, Not subclass. So even though you know it will reinforce understanding in a method overriding overloading, inheritance. All these things we are going to cover today for each of these There are examples in that example set So please play around with those example code read those comments. Why? Because all these will be absolutely relevant to your first assignment and also, for that matter, for the second one. Ok, uh and so please, please do that, but conceptually, we'll go through all of them first. And then we'll also go through examples today. So don't take me wrong. But we will first, Let's understand conceptually OK. Constructors, for example. Uh so on and so forth. So we will basically cover this and then next lecture will be also on domain modelling. And that would kind of end the object oriented programming. So the object oriented programming is basically say Well, how can I write programmes in Java? How do I create a class? What is an interface? What is an abstract class? So this is all about programming, you know? Then we say, Well, ok, now Once I know this object oriented framework, the programming how can I design Softwares which actually exploit or use the features available in object oriented framework? So that's object or needed design. And so the rest of the course will basically use design pattern software principles and we realise that using object oriented design which will then be implemented in object oriented programming. So these are This is how all these concepts are related. We start with actually Well, this is how I basically write the programme bottom first. Then we talk about OK, well, how do I design the software differently so that I can use inheritance and interfaces and everything. And then we say, Well, OK, there are many ways you can do it now. How can we write a good software art of software design? OK, so we'll say. OK, you have to use software principles, uh, software, design patterns and so on and so forth. Go on. Ok, so, uh, there you go. So basically, uh, let me. I think I may have the whole slide in one place so you can see here all the topics, so we're going to cover all of them. So what we have covered so far is basically subclasses and inheritance we already covered. We also talked about abstract classes in the last lecture. OK, and, uh, this is single versus multiple inheritance. I'll come back to it at the end of the lecture because, uh, it basically will show you how you can also implement or realise multiple inheritance in a different way, OK, through some interfaces. But for that so we'll skip that. And then today we are going to mainly talk about the interfaces extremely important in software design far important than abstract classes. OK, and then we talk about method method forwarding, which we have also briefly mentioned about uh and then the most important aspect. Again, we touched upon that briefly. But we will also go a bit more in detail about polymorphism, which is the one which is really makes soft object already programming different to, say, programming in C or just simple python without objects and so on and so forth. So that's very, very important point here. And then briefly, we'll talk about method overloading, which is kind of, you know, uh, says that the method signature is depending on the the name and the argument and the type. And so it's not very complicated because it's very simple, but used quite frequently. I already covered a constructor, remember? Because I that's what we need to know. So But that slide simply summarises what we already discussed. OK, so that all these concepts you need and then we have examples to explain each of these. Now here you have opportunity to ask me questions about why what's happening, why it's not happening so on and so forth. OK, so the first hour let's go through conceptually now. Uh so we did all this already. And, uh, a case. We talked about the circle graph and so on and so forth. OK, earlier I used to put everything in one slide, but I think recently we just divided into different parts. So you don't kind of get confused with that. OK, so yeah, that's the second part. OK, so now we talked about Subclasses, remember that we already had a graphical circle exa. So everything we covered before already So, um, that's the the subclass. So you can create Uh um uh the object of the types graphical circle graphical circle is subclass of a circle so I can store it in a variable GC. And because subclass of circle, I can already call all the methods available in circuit. That's the inheritance. OK, got it. So, um so we can also treat graphical circle as a circle. But then we cannot call those methods which are associated at the graphical circle level. I discussed everything in the last lecture. If you have any issue, please ask me again. Ok, so OK. The super class objects and class hierarchy. We talked about all these things. I'm just quickly abstract classes where not every method is implemented. At least one method is not implemented and the method which is not implemented we put abstract before that. OK, so we have an example already here. So we have the the abstract class because this class not all the methods are implemented. Therefore you cannot create object of an abstract class because not everything is implemented. So one of the subclasses will implement all the methods and at that time I can start to create objects of that type. And then we said OK, it has got two abstract methods. One is area one is circumference the advantage of this abstract class In this example we discussed everything last time. So I'm just quickly repeating that OK, is that rectangle exchange circle extends shape similar rectangle excess shape. OK, that means that circle is subclass of shape. Rectangle is subclass of shape and in here we implement those two methods and the advantage is that we can implement the area and circumference in one way. In circle another way, suitable way in rectangle. Tomorrow triangle so on and so forth. So now we have the same method signature, but for circle it will behave differently to rectangle it behave differently. And why we do that. The reason we do that is because now, if I have object of type circle, I can treat that as a shape. If I object of type rectangle, I can read that is of shape. And so if I have a canvas, for example, in which there are different circles and rectangles and more other shapes are drawn. If I were to select few of them of different type few circles rectangle and say, I want to find area of everything I selected Now with the traditional programming, you will have array or a link list of circle a linked list of rectangles you need to create this collection for each one of them. I have to go through each one of them and add them up together. Here, I can treat all of them under one umbrella under one type called shape, and I can just have a one loop, which basically goes through every shape which is selected and just a call area. Now, obviously, is that example I think we discussed last time. So here is the the rectangle. Again, the area is implemented differently to circle, obviously. But now the example here was that I create a circle and I I created a shape array. OK, so this array of type shape every class or abstract class, or even that for that matter, interface when this later on all they are nothing but other types. So I said, Well, can I create an array of type shape so I can put shapes in that Now remember, circle can be treated as a shape. Rectangle can be treated as a shape. Even graphical circle can be treated as a circle and therefore can also be treated as a shape because it's a superclass superclass relationship. So I can. I'm creating different kind of shapes here. Can you see that all of them I'm storing as a shape so I can treat all of them. Now I only need one loop, and that's just a for loop. It says, Well, OK, go through every element in the shape. Now call this method. So this area method, when I'm calling for, uh, zeroth element, it will basically execute area from a circle For one and second index, it will execute area from rectangle. And for the last third index. It will execute from circle because graphical circle is circle. So it really shows you the strength. Now, in case you're new to Java, you know Java has got array. Array is also an object. Everything is object in Java and that object has got one field called length. So whenever you create an array, it stores the length of the array in this variable. So all you need to do is go to that instance that that array dot L gives you land. So C and C you need to pass the A array A and also the land separately. We don't need to do that. They address that problem. So all I need to do is just pass the you know, the shape that is an array. And there's also one field which tells me the length. Of course, that's just the java for you. OK, so that is where we discuss. So you see why abstract in this case, abstract class is used as just a common type across all the shapes. And then we say, Well, ok, it has got two methods which has got the same signature across all the shapes, So I can use it. Is it any questions so far? No, I'll come back to that later on. OK, now Interfaces in Java are extremely important. OK, so what are the interfaces in Java? So they are like abstract classes, but there are some extremely important differences. When I define an interface, it is also a type. Now when I say that interface by default has a zero implementation and you don't need to say abstract class or abstract method interface is all it defines. All methods within that are implicitly expressed. Abstract means there is no implementation. So it is just a type and it says anything of this type will offer these methods. And these methods are just the he the the the signature of the method. The header that's it, No implementation. So when I say this, you say, Well, then what's the use of that? It's useless. In fact, interfaces are the one of the most important thing you will get in new languages. You must be wondering why the reason is because they give you tremendous quality. The feature called abstraction. OK, now you may not write the programme now, OK, which goes and use Chad GPT or Germany or Lama Tree. All they tell you is this is our API. What is a P? Anybody? Application programmers interface. So they say This is the way you can call our Web service. You provide this values and we return these values. Do I know how Chad gpt work? Gemini work Lamma three work? I don't know, but I can use that service. All I need to know is how to call that service application programme. All I need to know is the interface to that service. How that service is carried out. We don't need to know. But as far as implementation is available somewhere, I get that service now. This is not radically new for generative A. You have been using it even in C. When you open a file, what do you do also in Java you open a file Say I want to open this file with this name. And in this director, for example, Do you know how? Actually the file is located on your hard drive or on your, uh what what different drives you have nowadays or in the cloud? Whatever. And then it opens. It creates a file point uh, lots of things happening behind the scene. And then, more importantly, when you open a file on Linux, it is open in a one way completely different when it opens on windows completely different when it opens on Mac operating systems or or some other, you don't care. I don't care. We simply open execute that statement. And we know I have a file punter, and I can do whatever I would do with that because all I'm using is the interface to opening a file. All I do is that I say, Well, open a maths library and just give me square root of this value How square root is calculated. I don't know. I don't care, because all I need to know is the interface. Implementation can be different now. This may have been discussed earlier in 2521 abstract data type In the abstract data type, you always segregate your hero file and implementation. Have you Do you realise that yes or no? And why? Because I can change my implementation. But as far as I don't change my header file, the client programmes don't need to change anything in them. Are you with me? Yes. You know, same thing as so You know, the way you do software design, you have a requirements, and then we'll do domain modelling and so on and so forth. In the next lecture, you don't go and create classes. First, you're gonna create interfaces. I need a type which provides these matters. So first you will design interfaces because you know, from your requirement what things you need to do. And so you said this is the method and it needs to do XYZ and it needs this value. It returns the value. That's all I know. Then you write a class which implements this interface, meaning it will implement every method in the interface tomorrow. If you have a better way of doing it, you just implement a new class. But the interface remains the same because all the client programme are only going to rely on the interface check GP D changes all the time from three to,

SPEAKER
, you know all the new versions.

SPEAKER 0
We don't need to care about that as far as the interfaces. That's not changing. It's a tremendous way of connecting to, uh to the connection with the client programme and actually implementation through interfaces. So so interfaces are extremely important and what they have is that everything in the interface is by default abstract. So you don't need to say abstract. You simply write it and it is only the header. OK, now I mean, I'm not going to go line by line but that's what it says. That you can also create a constant interface you want to generate. We don't do that. But if you want, you can do that. There are no variables there. OK, so interfaces are there is no variable, There is no implementation Now let's look at example of that So that makes it much easier for you to understand. Ask me if you have any questions online guys. So here we basically create an interface. Look at here. So interface says that only the name interface there's no abstract here. Draw. So it says that I'm defining a type draw so anything of type draw will offer three methods. OK, what are the three methods? Ok, um what are the three methods set colour. So it says you give me the colour, it will set the colour set XYZ three, This is implemented. You see, That's just semi Colon here. Got it. So now then I say, Look, shape. We did discuss before already. Now that's an abstract class here. But then circle implements some methods area and circumference. Whatever. Then I have a rectangle. Now all I'm saying is that there is an interface called Draw. I let people put eye here for interface. Ok, then I'm saying I have a draw rectangle which is a subclass of rectangle. So it will inherit all the properties of rectangle is classic subclass but it implements So there's a dotted line In case you see here this interface that means it needs to implement all these three methods here. Otherwise it will become error. So it will give me all the methods which are defined in draw Only then I can say so. I say draw a rectangle ex rectangle, but implements draw. By the time I say this, I need to implement all the three methods here. So 12, and three, whatever. The implementation is not an issue here. But all the three are implemented now. So when I come to any object of the class draw rectangle, I know it will have these three methods, and I can call them now. Same thing. Draw a circle will extend circle and implement again. Draw. So that will also provide me these three methods. So now if I want to draw something, I say, Look, if you want to draw any object, that object should be of the class, which implements, that's all. I just give me any object which implements, so then I can drop. It may be of any class. It can be rectangle triangle. I don't care. I don't care. As far as so, this is how the interfaces are important. The question. When would we use an abstract class over an interface or vice versa? OK, it's a good question, and we'll come back to this all the time. Abstract class is used if we have few common methods which we want to share across so undergraduate student postgraduate students so I can have a student as an as a superclass. Now I may provide some implementation there, which is common across both of them, but some of them I provide as a abstract, which can be implemented differently for undergraduate or postgraduate, however, so because interface doesn't have any implementation. It is just a type generally speaking later on. As we proceed, it is going to be all about interfaces. OK, so abstract class. It is useful. You should use it when there are things you can share between the classes, but not everything. If you can share everything, there is no abstract class. You can just create a class for a student, for example. But if there are things which you think I, I know the signature just like area and circumference. For example, as a classic example, then you can use abstract class, so it all depends on the problem you have. The other limitation of abstract class is that it's a single inheritance in Java. So once you abstract class, the subclass extends the abstract class. And that's it, that subclass cannot extend anything else now. But that may be OK in your design. OK, so it all depends on the problem and then you decide whether it is abstract class, suitable or interface. Good question. OK, so now in case how to use it now you can see here. So now I create a shape array and we can also create another array of draw now. So what is draw? Draw is nothing but a type is an interface. So I'm I'm declaring an array of type Draw. Draw is an interface so I can put any object which implements draw interface in this array. Now remember that draw a rectangle. And so now what I'm doing is that I I have two arrays now what I'm doing, I'm creating a draw Circle draw square, Dr Rectangle assuming all of them implement the dable thing. OK, so now I can treat them as a shape also because all of them are under shape Abstract class and they also implement draw. So I can also assign the same objects to draw so I can treat them as both Now See, I have only one loop here. I calculate area by calculating that and I'm somehow setting the position to something. Doesn't matter what here. All we're saying is that we can treat all of them as a draw. Now, in fact, the shapes are different. But I can just use on a draw. But can you see the power of interface and abstract class here? You got it. Any questions? Please ask me All these examples are already there, OK? Yes, ma'am, If you implement what? Yeah, you can create new class human or a class A. If that class implements doable, then we can treat that as a rival. It needs to provide those three methods. That's it? Yeah. No, no, no. So it doesn't matter. As far as that class implements draw, I can treat it as a draw. So they are two separate are with me in this example. All of them share that they are also a subclass of shape and they implement, but it doesn't have to be like that. OK, that's a good question. So I mean, the simple principle is that it's a subclass we know already. And the other one is that if a class implements an interface, I can treat that. That's it. Other relationship, it can share whatever Doesn't matter. Really. That's the question. Yeah, the INS have to be the final, so that yeah, interfaces are a separate file. Just like a class file interface has got a separate file. It's like a header file, but yeah, it's a separate file. OK, now, now, generally speaking, we don't need this, but in case you want to, so you can see here. So a class extends the subclass of some other class. So now getting deeper and deeper OK, and then it can implement. This is very important. It can implement multiple interfaces. Important. OK, so you don't need to only implement one interface. So the idea now is that I have a class and you can treat that as a draw. You can treat that as a movable. You can treat that as a scalable means. You can scale this. I have some way to scale it. I give a corresponding method. I have a way to move it. I give corresponding method. I have a way to draw movable, scalable. We have different interfaces and say any shape in our example can do implement this interface. I can treat it accordingly. It gives you this flexibility. You got it. Any questions? Jasmine. What if let's say let's say just the job of

SPEAKER 1
rectangle has the same. Um, So So the question is that what is the

SPEAKER 0
dry rectangle? Uh huh, Yes. In what? Let's say so. The very good question asking. So I'm just writing. OK, so let's say what he says something like this if I met M one here and he says that What? What if it has got the same signature as What? In what? OK, remember important things in interfaces. We only have signature. You got it. There is no implementation, and a signature is the name, the number of arguments and the corresponding type. It doesn't do anything so I can have this. Let's say it takes integer with me. I'm just making it up OK, and it returns double. For example, I just put D for D for double. OK, now that's simply that's just that's all it is now I can have it here. I can have it here. There's no conflict. So implementation. Now tomorrow. If there's another method, somebody write M one and say it takes string. String is a type in Java, OK, and returns double for for Java. These are two different methods. Nothing to do with each other.

SPEAKER 1
Yeah, yeah, question is what it also it can as

SPEAKER 0
well be. So what's the problem? It's the same matter. The idea is that if this one appears here and this one appears here, that's OK. It's the same thing. So it gets away from here gets from here the same method. It doesn't do anything, so there's no conflict. You got it. That's the advantage. That's why I can implement multiple interfaces, because are you getting? It's a very good question. He's asking, because as far as the signature is the same, there is no conflict and you don't implement anything. So then what will happen to clarify? Here he will implement M one, this one you implemented here and that will be used for these. And these both. There's only one implementation which is in their class. And if you change the signature, it's a different method. So this is the reason why interface is very popular because I can class can implement multiple interfaces and we'll do a lot of time and that that means the same object can be treated in a different way. Depending on the interface you're using, we can also have a subclass, and there's hierarchy and type, so it gives you a lot of flexibility how I can treat one object as of different types as required. Got it. Now we are just beginning. Later on, we will get more interesting. OK, we will use all this feature in different patterns and then you realise why these are important. And then you realise that Yeah, that's that's a powerful mechanism we have here. Yes, uh, in rec in, uh, in in here. Draw calibre. No, in rectangle. Here is right. Yeah. So then it will be already available here and available here? Yeah, now? Yeah, those things. So both are available because subclasses So if if M one with this method is implemented here, then I don't need to do anything here, Ok? Any questions, guys OK? Yes, ma'am. So if the same method in different interface but because there is no implementation, there is no conflict. It's the same method M one takes in interior returns double and so it's ok. You have both of them. Fine. No, no problem. Because the problem starts with there are two different interfaces. Sorry. Implementations. Otherwise there is no issue. Ok is movable and scalable abstract. No, they are interfaces. OK, so they they are interfaces. So all of them are interfaces. Ok, ok. Any questions, guys? No. OK, now if you want to, you can also have like subclass. You can also extend interfaces now we don't generally need to do for this course, But just for the simplicity I can create an interface transformable which extends these other interfaces. So all the methods which are declared here are already part of these and I can provide more methods. But remember, in interfaces there is no implementation. It is just the headers, OK? And the word for some reason, is still extends. But this is not the extent of a subclass its extent of interfaces now method forwarding. We briefly discussed already. Uh, but just to kind of one slide to recap the same concept again. So let's say this is a class. This is a class. This is also a class, OK, And let me just change the colour here. Um and this is an interface and OK, now it says that let's assume a is a class. B and C are subclass of a OK, now what is better for? You know it already, but I'm just kind of recapping it here. Ok, now it says that C there are classes like uh uh CPQ and R All these classes four of them all are implementing interface X, so interface X may have few methods. OK, so let's assume interface. X has got method M one M 22 methods with some signature. OK, whatever. Now, because CPQ are all these implement interface X, they need to implement M one and M two. They need to implement M one and M two. All of them need to implement two methods. Are you with me now? One way to do is just I go and all of them are different. We implement all of them differently. There is no issue with that. However, for some reason OK, let's assume for some reason uh, you know this again C is also implementing So it will also implement M one and M two, for example. Now let's say M ban is the same across all of them. So I can just in this class C I can just create instance of C so I can say C one is equal to new C and then C one M one I can use in the implementation of my M one and then forward that result. So when I'm implementing M one in class R, I just create a new instance of C and just return. Whatever the answer is so I'm just forwarding the reply as my answer. So it's my method forwarding. That's it. So the idea is that if you think that a particular class implements some behaviours or some methods which you want to use as they are, I just create instance of that class and then call that method forward. We don't copy and paste. That's a summary. OK, don't do copy and paste, but rather do method forwarding. OK, OK, what is the distinction between area in a shape? OK, uh, what is this question? What is the distinction between area in shape and any method in an interface? Well, area in a shape is an abstract method not implemented. Same thing All the methods and interfaces are not implemented. So that way they are similar. OK, now in uh, the answer is given here In that context, they are the same because we are describing the expected behaviour of the area method. That's right. The answer is correct. OK, so concepts are the same. We are just providing. This is how the signature of the method is. That's all but because one is an abstract class and one is an interface the way we realise it or implement it is slightly different. OK, OK, so that's called method forwarding And I think it's rather simple, so I'll move on to the next one. OK, just everything is describing the points here. Now this is where it gets interesting now again. I briefly talked about now so far we had a shape class with area and circumference and we implement that in a circle or rectangle. It is actually giving me multiple behaviours when I treat objects as a shape. So that is polymorphism. But we can do even more interesting. Um programming. OK, so polymorphism. As I said, Polym is multiple in, I think Greek and so it's a multiple behaviour of the same type. A type can be same, but it can behave differently. OK, so the question is that one example we saw already of the shape and circumference. But more interesting example is this and again there are lots of examples already in the example file which we will go through shortly. OK, so this is a very simple so you could simply make an interface to calculate area, calculate the area and implement that in each shape rather than finding it in the shape abstract class. So look, uh, basically, if I may answer the question we started with abstract class because there are two concepts we need to learn abstract class and interfaces. And but there was one question already What's the difference between the two? So the difference is that we use abstract class when we want to put some implementation and then rest of the matters only as a matter signature when we define interfaces where everything is only, uh, a abstract. OK, now, when we go through examples, look, we have one way to implement the shape and the circular rectal using what we discuss already abstract class. We can do the same thing by creating shape as an interface and we have that example. We'll go through that so we can as well create shape as an interface. And then I say, circle, implement shape, which we have example we'll discuss later on. So I hope that at that time it will be clear to you so and again, you decide which one you want to pick, and increasingly, we are going to use interfaces. I'm already telling you, but there is also places where abstract class are useful again. I repeat, when there are a few common methods you want to add between the subclasses then of course, put in abstract class and create an abstract class and then behaviours which you think you can capture as a as a signature which is common across the Subclasses. Therefore, that example, we pick is a very deliberate, very simple example which communicates the concept very clearly about the area and circumstances. Same signature, different behaviour. So please again, I repeat, go through all the examples and try to make sense of it. Now let's go back to the overriding, which is a very important thing, OK? And ask me if any questions, not difficult concept, but we need to be very clear about it. So here is a class A and class B extends class A OK, so I got class A here, OK, and class B is extending class a B subclass of a You got it. Now there is a method F implemented somewhere here. OK, method F. Now, whatever implementation is now, there's very good examples of this already there, which you should run and see the behaviour now exactly the same signature you see Here is another method defined here. So also a method F is defined here in B always happens. It thinks that I'm scrolling You got it? So both these methods are implemented like this. See what happens now If I create an object of class A which if I am going to use So So now let me go here And I say variable A one is of type A obviously is what new E. Now if I go and say a one dot F which F I'm going to use when I do this, it thinks I'm scrolling. So let me type with this Ok? Which F I'm using here Because the object is created as of Class A. I'm using this F. Am I right here? Yes or no? Got it now if I go And if I say B So that's a type. So B one is variable is of type B equal to what you be. If I say B one dot F Which one? I'm going to call this one. That is me. You got it. So the behaviour is different here. I'm only returning. What? The value of eye is again. He's not doing anything radically interesting. But here the behaviour is different. Don't worry about what that is. I'll come back to that super and all of that. But the way it's implemented is different. Are you with me? Yes or no? No. Remember that B is a subclass of a So can I do something like this? There's a variable, a two which is of type A. And I say a two is nothing but B. One. I can do that. I can treat B one as of type A, isn't it because a is a superclass of B? Am I right or wrong? Yes or no? Got it. Now if I say a two dot F which F I'm going to call. So the way it works is that whenever you create an object the level at which you create that object, you pick up methods from that level and they stick to it. Because if I'm going to read online, just just a minute. Let me explain because I create object at level B here it will pick up F from B because the same signature. So this F is going to override F declared in the superclass because of the same signature. So if I create an object at level B, I'm going to pick up F from B and that remains with that object. So even if I treat that object as of class A, which I can this F is still coming from B. That doesn't change. Are you with me so dynamic, binding dynamic means when I create an object the level that I create I bind all the methods at that level and that they remain all the time. Even though I can treat that object as a superclass one of the super classes. If there are methods overridden at the level at which I created the object, they will be coming from the class at which I created an object always. OK, now you see here. But however, when I say a one dot F because the object was created Class A that comes from here. So what's happening for the outside person? A variable of type A. I call F. It behaves one way variable of type A. I call F. It behaves differently. Poly different multiple behaviours polymorphism. Do you understand that? That's it. Now this is just a very technical way. Explain. You will see why this is important and interesting when we actually use this feature later on. So that's that's the matter. So this is called method overriding. So Method F is in class. B, I'm overriding Method F with the signature wide. There is no argument and written values integer in this example. You got it. Let me see if there are some questions online here. So So the method already is similar to implementing an abstract method in the sense that that would be abstract. OK, so in a way, in the abstract method, I'm not overriding anything because the abstract class has no implementation. So I'm not overriding it. Conceptually, it's the same. But there is a slight difference here because abstract class area in the shape class is not implemented. So I'm not overriding anything technically, but yeah, it is coming from the same concept here. Ok, uh then say just wondering if you could then do is a relationship for saying that circle is an oval, but then use. So OK, so uh, OK, there are a few methods, OK, so you can always override methods in subclasses I think that was the question here. OK, the question is that if I use is a relationship, that means I inherit everything from Superclass. Now, if I override one or two, it may be OK, but I don't want to over at so many of them. Because then my design is incorrect. Why do I I rather use HAZ a relationship, so that is a design choice. OK, but you're right. A lot of time. We may inherit all of them but just modify one or two, which is OK, ok, that's the answer to look now what does it mean? I is being shadowed. I welcome II. I haven't talked about variables yet. OK, I'll come to it later on. Why don't we use override? We can OK, so we can write override as a comment. OK, this is just a concept. But yes, you can say I'm overriding Method F OK, Yeah, that's fine. So do we need to override thing? Yeah, Yeah, you can write override before that. OK, If you don't, it will still compiled, by the way. But you can ride over there, OK? The idea is that when you write override and if that method doesn't appear in the implementation in the interface or the superclass complaint that you're not override anything, but otherwise it will still work. OK, so I think I answered all the online Otherwise, please repeat again. Is it clear so far? Now I'm going to erase this and go back to variables now the rest of the concept here. OK, so So that's where we are talking about the methods. OK, now what about the variables? OK, I is in both of them. So in a simple language, when I refer to I in this I'm referring to when I say I without any qualification, I'm referring to the local I just like, you know, scope of the function, the function. If X is defined, then you add X in the function. Does it make sense? Yes, I know. And here also, when I say I of course I'm referring to the local eye Makes sense. OK, now if I want to use I from the super class so I is a shadow variable here. If I want to use I from the Super Class, I can use the keyword super dot i So this is now referring to that. I Are you with me? Yes. Big warning. I'm teaching you because this concept you need to know, but having a shadow variable tells me your design is horribly bad. Ok, next question. No. Ok Are you with me? Because shadows are absolutely bad Design few things. OK, Shadow variable is basically see the variable. I is declared in class a again. I'm declaring I in class B. So if I go to class B and if I refer to I which I am referring to So I is a shadow variable because it is in the superclass and also in the subclass. So in the subclass, as you may expect if I refer to I, it is basically I from the subclass in the super class. It is from the superclass Makes sense. It's very simple, I would say If you want to store two different values, then just name it differently. So maybe I in a superclass in J in a subclass. It's a default if you don't provide any excess modify. There is a modified called default modify And Abraham, we will talk about that shortly. I have a slide for that. Ok, ok, so a default is basically available to all the subclasses in the same package. OK, so the idea back to it. So if I want to refer to I in a super class, I say super dot I Similarly, if I want to refer to a method in a superclass, I can use super dot F So this actually now refers to F declared here so you can go to one level higher and access variables and methods from there. Now why I say variables are, uh you should not use shadow variable because first of all, all variables, as I discussed in the first week, should be private. And we should use gutters in the sets. Are you with me? And if it is a private, it is not available in sub to sub in subclass anyway, so there is no issue of shadowing it, and that's the best practise that very was a private and getters and now gets and setters are the methods. So then we go back to the method overriding concept, which is much more cleaner and neater, so you can also override the gutters in the set. But then it's a classic method overriding simple that's the advice. But in case you want to know what happens if you declare variable, This slide is for that. But not that I want to encourage that for you to use second thing. You can only use super once you can't go to Super Super Super because again that shows you bad design. If you really want to use some function in a subclass two or three, step down Say just name some differently so you don't override it. OK, so it's just the design things OK, so the next slide basically says that OK, super gives you, uh, method or a variable in a super class. But remember that this is not legal, OK? You can't do more than one. You can only use one super not more than that. OK, so at a design time, consider do I really need to use the same variable limit method below the method name below is great. If I want to change the behaviour of a method, then you should be using the same signature and override it. Then you know all about dynamic binding polymorphism That's easy to understand. Get over it variable. Just use different variable name and decide private or default or whatever. Generally I would recommend Variable should be private. OK, now method overloading is more like a simply saying Remember that I keep on saying signature includes the name and the number of arguments and the corresponding type. So for Java this is completely different to that you see, written double. These are same. These two are different. So for Java they are two completely different signatures. Are you with me? Yes or no? So all of them are completely different signatures. So this is called not overriding. It's called overloading. So we still use this feature. Sometimes it is useful. Why? Because you see, I want to add two integers and this will give me the summation of given two in it is possible that the numbers are represented as a string. OK, so if I want to, I can also say something like this. Double add same and then string is already a type in Java by the way and string Say you are reading something X XML file or gsn file or something, and they give you number as a string, for example. Now I want this method to behave in a similar way. So I want to add two numbers but the numbers can be represented as two integers double an integer or two strings one string and double. Eventually, I want to convert them into number and add them in return. So what this add method does is the same just that I want to accept you. So this is actually quite useful sometimes. OK, so eventually the behaviour would be same. It does something and gives me this answer. But user can provide me so example is like again going back to generative a I or another example, I say, Well, I give you text and can you summarise that the other one? Well, I give you PDF file. Can you summarise that? So what I give you is not the text is a PDF file or I give you a file, but it is still summarising it. The task is summarization, but what I'm providing is different. So that may be method of writing. So the different call takes a different values but does the same thing. OK, so that's not pretty sure you can OK, uh what is OK if we have a private class that is being extended or a or a subclass is inheriting from. Can we use its private methods? OK, if you declare variable or a method as a private, it is only available in that class. It is not available even in the subclass. Got it? If you want method to be available in a subclass, it should be a default method, which is available in a subclass or a protected method, which is available in a subclass or, of course, public, which is available everywhere. So the private is absolutely private to that class. It's not available anywhere else. A lot of pressure and protections. Qualifier. So let me tell you something too simple public available to everybody private only available to that class. Only two more left now protector and default Default is available in Subclasses, but only in that package, meaning in that directory, for example, default protected is available in subclasses in that package and also external packages if that class is imported and it can also create subclasses in the other package. So that's only one subtle difference between them. OK, watch. Yeah, no. So Satter and gets are not private, they are public.

SPEAKER 1
If we want to override.

SPEAKER 0
Yeah, so very good question. The question is, sir, very well is declared in class A as a private. And then I get X and set X, which are public. Now I go to class B and I want to somehow change access, act differently. Whatever. I want to add five and then return or whatever. OK, so his question is well, X is private. So how can I access X in B? Remember, in V, the gators and setters are available for me. So I'll say Get X. Got it. So the idea is that I always get it. So because class A has got G sat by the public. So I just go and say, Well, give me, get X and then add fire, multiply fire or whatever and that's my behaviour. Now that's it. So that's why you can use super also if you want to. But these are the questions you should be thinking about, and therefore we again I maybe 10 times have said lots of examples. Open the file, read the line, run them, modify them, run them, do that. Does that mean default is more secure than protected since default can only be accessed. Yes, exactly. It all depends on what you want to do. Guys in your design. OK, so default. Yes, it is only in that package. You can't extend it outside the package. Now, if you am writing a package which my client may use and create up, I want that facility. Well, then it should be protected. And if I want to just keep it to myself and I don't want others to use it because it doesn't make sense for the outside world, it should be a default aspect. No, no super will only get you access to if it is not private. And this is very and this is exactly why all the files are there. OK, so I would create a variable as a private and go to subclass and do super dot It will show me whether I can see or not. So just just do hands on. OK, now, sometimes, like I mean, as you may expect. I mean, I teach so many languages and deal with so many languages. OK, so I may sometimes what was in Java, what it is doing because tomorrow is a python and then prologue and I literally go to ID and you see what it is doing because it's already implemented. So it's like all of us will forget tomorrow you come back and play it out on it. It's not rocket science at this level. I mean, Java will be after 10 years or six years. Some new language will come already there are so many and you guys will pick it up. OK, It it's now more and more You need to learn how to learn because what you are going to we all going to learn is going to be obsolete in a very short time. OK, so we need to keep on learning. OK, now. Oh, this is a lot of questions already asked here. Ok, I've answered many times. The idea is that try to keep all the variables private, access them through gas in the setters make matters public. So in of course, you want to make things available to outside world. So all the services you want to offer or the behaviour you want to offer to the client programme, they should be public, so they can just go and use those behaviours. OK, These two I have already mentioned OK, so it's only visible to the package and all the subclasses and is visible to the package. OK, so this one says it's inside the package as well as all the subclasses, even if they are outside the package. But package, I haven't explained that much. We'll talk about package shortly again. The example is there. All the examples are there, so I'm just looking at the time. Now that's pretty much it is. Then there's a constructor, so we'll take a five minute break in which I'll log in and then the rest of the lecture. We will go through all the examples and repeat all these concepts in those examples and see what happens. OK, so constructors, I think we covered everything here in detail, so please read through them. That's a summary of what I discussed in my first lecture about how the constructors work. OK, so it's, uh, I'll. I'll come back in a short period of time. OK, did the break soon? Could you re answers the question from previously When would you use inheritance and when would you use extra class or other is in like a header file? I think she I already answered that. So the answer to that question is the following again. More examples. You will see It will be clearer. But the answer is very simple. If you have common methods which you can implement across different classes, then I would consider abstract because in abstract class you can implement some method and some not. But if I only want to get a type like draw able, movable and without any implementation, I go interface. And increasingly, we are going to go and use interfaces. But abstract classes are also quite important in some cases. OK, now interfaces are like abstract data types in C. So yes, so I mean as AD T and classes. There are a lot of common things, so hydro files are like interfaces, So interfaces are like your hydro files. Ok, Ok, guys, I'll I'll be back in, uh, 57 minutes. Yeah, right.

SPEAKER 1
I have registered one online tutorial and lab. Can I attend the, uh, in-person one?

SPEAKER 0
Technically, you need to move because it's already foolish, right? So the question is that you still need to get it marked from your online tutor, but if you physically just want to go and talk to other tutor. I don't think they will mind, but they may not assess you get it assessed from the other tutor. But of course, you can go to physically and yeah, learn. That's fine. Thank you and everything. Every single, they're different. It may. It may not even accept it if it is exactly the same. Yeah, but signature is all. It's a different method. Yes. I don't think it will accept it in your campus. Just write it down and find out. Yeah, that's what I was saying. That I will try myself because in every language that has got the nitty gritty from my point of view, they are all different and I don't think it accepts it. But check it out here, OK? There is discussion about abstract class and interfaces. We have one good example to show you. OK, so we'll start in a couple of minutes. OK, guys. Ok, um we can start. So, uh, this week, 02 package. It's got lots of things in it. So first, let's go to these first classes here. So we we were going to the shape class, you know, all of them last time. But before that there is a class A Now what I've done is just implement class A and class B Just where was XYZ? Just it's a playground for you. OK, so class A You see there are two variables Default Then if there is one constructor, another constructor This matter F does something again you know behaviour will be different and it returns X plus Y, you know, then method overloading. Can you see that here? It's all different examples. Just just go through this example. You know it does different things. Now let me talk about this briefly, Ok, OO OK, remind me Wrapper classes ok before we finish. But let me continue at something else. So they it is all doing different things. The equal method we discussed already. Ok, so then we say, What is class B. So the class B extends a So B is a class of a Now you see, there are some shadow variables here. Some additional variables here and the same method is implemented to behave slightly differently. OK, and then you have a test class here in which you can create different objects. You can call methods run it. Test your understanding. Is it right or wrong? Modify these things. So this is for you to play around all the concepts we already discussed, which is about method overriding, overloading shadow variables. Again, I don't like that concept, but if you want to know this example is there for you to play around. You got it. OK, so that's a very good example here. Now, Uh, any questions, please ask me. No, it's not used. That's why it's connected. Now you see here there's another example. So I am defining a package here. This is how we defined package. So it's a package and the name of the package. And generally all the files are in the same directory. And every time you write that as a first line, all those classes are under that package and we can then import that package in another package or another class. Which example is coming shortly? OK, so class B A and Class B, both are in the package method static versus instance, and then test is also part of the same package. So what this example shows you is that I am declaring this method is a static method. Sorry instance. Method because there's no static word there. So this method is associated with an object or an instance. Athm me OK, this method F two is a static method, so it's like a global method that means this method is associated with this class, not with a particular instance. So how does it matter if I want to call F one? I need to create an object of type A. Let's say I save that in a one variable. Then I say a one dot F one. If I want to call F two, it is not connected to any object. All I need to do How do I call it? I go and say a dot F two. The way I'm going to call this is here a dot F two. That's how I call it. And because that is basically, I can say a one equal to new A. I'm just making up here. And if I write in the same line, uh, let me say right and then I say a one dot F one. Whatever. So So that's instance Method. I create an object and call it This is directly connected to a class with me That java is a little bit generous. OK, so if you go and do this, it will still not complain it. OK, I know what you mean is have to which is a static method. You want to call a me, but it will give you warning as you will see in my test file. So this is not preferred. You don't want to do this, OK? You want to call it through the class. That's a good practise, but it may work. The second thing is that in the instance method I have access to all the instance variables in a static method. I don't have access to instance variable because instance variables are connected to every object and so the static method can only access any variable which are static or constants. It cannot access instant variable. OK, got it. Set a and get so B again. I can go through that again. This is a static instance. Now you go to the test one and again please read all the comments. So it says that I create object of type B here. Then I'm calling B one dot F one it's instance method so it says it is F one here also overriding is also here. I think so. So this is F One. It is. I just say F one is from a and this F one. So B so implementations are different. We just printing a message here. OK, so in the test file this is a classic example of method overriding. So it will print F one from B. Now, if I say this now you see here F one is a static method in a static in B, Are you with me now for the static method? There is no no no notion of override because they are connected to the class, so there is no override. Ok, so this method is B dot F two. That's it. There is one matter. And if I want to call F two from a I'll go and say a dot F two. So there is no overriding. Overriding only happens for instance method not that matter. You got it? Yes or no? Now I think it should depending on I say What was that? He be one dot F two so it may not like it. Ok? Yeah. It complains OK. He says, Hang on. You should not be doing this, but most of the time it will still compile and run it. But he said Don't do that. So yeah, don't do that. OK, so it's just more like a warning. But yeah, just call it through class. That's the way to do it, OK? And again it gives you all the output and so on and so forth. Two examples Very nice and fine. Again, the same example for inheritance. It gives you class a some comments here. Different constructors here. Argument. Remember I was mentioning. I think I mentioned earlier already. When you type your comments in a particular Java doc format, basically Java Doc Command will extract these comments and will create an API file. We discussed that before. OK, so I don't repeat that and I think that may be also one of your labs. OK, so this is why it basically said this is what matter does. This is the parameter X is of this and so on and so forth. OK, so it's not you can interpret it very easily, OK, Therefore it is written in a particular structure, so OK, it will be extracted and create a document API document from that then class BX and class A in the same package. Then there is a file which shows you how the equal works. There's a file which shows you how the inheritance works. So there is method overriding method, overloading all the comments, Everything we discuss. OK, there is also two string method Which does it? Got it? One thing I haven't covered remind me is about strings. We'll come back to that later on, OK, The strings are handled slightly differently in Java. OK, it's almost the same. Is the string class is available. It does everything for us, but just one different thing. It does OK now what does it mean when you call the F through class? F said I will. Um I know, I think I can. You can static functions be accessed by subclass so Luke is asking Can static methods can be accessed by subclass, so there's no subclass behaviour, so static F two in a can be accessed by a dot F two static F two in B can be accepted by B dot F two. So there is no subclass problem here. You have to write the whole qualifier class dot the method got it. So if it is static, it's It's not a question of inheriting anything because you can only access the static through class. So therefore all the examples are there and therefore any doubt go and play with that and see what happens. And of course, at the end of the day, you can check with your tutor and ask them and so on and so forth. So two string. We discussed that already. All these examples I covered But here are also those examples separately for you to go and read and understand. OK, so this again says that you can just write print B and then it will go and call the corresponding to string method and execute and so on and so forth. OK, you got it. Now let's go to something interesting because half an hour to go now we already discussed the shape one start with circle graphical circle, different way of implementing in this circle. OK, now here we are again, creating a you see here P shape and then we have all the classes in package shape and we discuss them already. OK, so different ways to implement one. Using is a relationship. One using has a relationship which is part of the lecture slides and so on and so forth. Here shape is an abstract class. As we discussed that, a lot of you were asking, you know why you want to use shape or is everything So here, Look at this example. I am declaring class shape. These two we discussed already. Now we have a static variable number of shapes. We discuss that what we haven't discussed is I can actually implement one method here, and I can implement more here, which are will be used across all the subclasses and they will make sense. So see what this is doing here. He says that print area so I can go to any object of type, shape and call print area method. So what does it do? It prints a message, whatever it is, and then you see what he's doing. He says this dot area, because remember, it's an A class. When you create an object, that class would be subclass of shape. Obviously, Therefore, it would have implemented the area method because area method is abstract, so it has to be implemented before it can create an object. So it says that I know this. You know, this refers to the current object, the current instance. So we know I can just go to the current object and call the area method. And I print that Now that this object can be a rectangle can be a circle tomorrow triangle or whatever shape. I don't care, because whatever it is, it would have area method with the signature, so I can call it. So you see, methods like this I can put them in my abstract class. Got it. This circle will create circles. OK, A few more things here. So we talked about this already different shape under that. Now, I briefly mentioned this, but there are two ways I can decide what is the type of a particular object. So how do I know is this object of the type circle or graphical circle? Because then I can use the corresponding method. So in this in the shape array, I have put circle rectangle, all of them I can put. But now, at one point, I want to find out what What kind of class is that so there are two ways you can do. One is use keyword called instance of So this says that if this object is an instance of a circle, it is going to be true. It is a keyword. So if this object is of type circle or of any subclass type, it will be true. Everything is written here, object of the circle or its subclasses. It will be true. So if this object is a graphical circle, it will be also true. Got it? But if I go to the same thing and if I say get class, it gives me the class where it was originally created. So if it is created as a graphical circle, this will return graphical circle. If it is a circle, it was created as a circle. It will return circle and then I'm comparing that Whatever the class of this object where this object was created, if it is equal to the circle class, then only so this will only count pure circles. It will not include graphical circle. Got it? Yes or no. Now see lots of comments and then I go and print the total area. The Count circle which includes a graphical circle because circle and every subs This one only circles. Everything is there. These are static variables. Lot of things you will learn if you just study this example. OK, any questions, guys? OK, now somebody was telling me about abstract and asking us about the abstract class. I don't want to say this. OK, now now the whole shape thing is now implemented as an interface. I can also then say shape as an interface, so I don't need to say abstract anything. Now it says. Two method area in the circumference Now don't need to use the word abstract because it is an interface. It is in the package shape interface package and now everything. I will come back to that briefly. Let's focus that first these two areas the classes, which is basically anything now the circle implements not extend shape. I so it has to implement those two methods. Otherwise it won't combine and the rest is the same. No difference. Graphical Circle exchange circle now because circle implements shape I so I don't need to again write it. It will be inheriting implementation from the super class rectangle again implements the rest is the same and test class is the same. So there's no change here because it's just a type. So again, the same thing. Now here I'm using the array list rather than array. But there is the same thing. I create a list of type shape I. I add different shapes. Rest is exactly the same. No change, slight change, but otherwise the same concept. So you could easily have created the interface. Is it clear? No. Earlier, when Java was introduced, there was nothing called default method in interface. So interface were purely no implementation. You got it from Java eight onwards. There were some new features added in Java and the story goes that that required them to use this hack. So I don't think this is an elegant way of doing it. So now, from eight onwards in the interfaces, you can write so called default methods and these methods are available to every class which implements this interface. So in a way, you see it becomes little like an abstract class. But here I have to say default method and this method is exactly the same as the abstract method. Do you see here? I'm using exactly the same. So now I can write. This default method will be available to every class which implements shape. I are you with me? You got it And they need to do that because they I think they need to add features like lambda expression and things like that, which is great. And for that they need some way of but and again they want. What they wanted to do was keep Java backward compatible as far as possible. So all these things. So now you have default method. Got it? Yes, I was expecting questions. I'm just waiting. Yes, still, what is that? No, no default method is only this particular feature is only for interfaces. Yes, different method is a see. It's it's it's an interface. So it's available in an interface, and if you want to, you can override it. But the yes, exactly. That's the question I expecting for a long time. So the reason why they did single inheritance is because you cannot inherit two classes because of this problem. Now, by doing default method, they're bringing the problem back because I can implement multiple interfaces. That means I can have the same signature default method in multiple interfaces. So the caveat for that now, or what they say is that if your class implements multiple interfaces with exactly the same default method, I will not compile. You have to override the method it says you override, so you decide what you want to do so that class has to go and implement in this example print area. So you are clarifying. But the concept I like it is that the concept I like it because it says that multiple inheritance. What happens is that I can inherit M one from two super classes at run time. Depending on some criteria, it will use one M one or other M one. And that's where the confusion was triggering in Java, says Resolve that at design time at design time, you decide what which M one you want. So it's I won't even compile you. Just you decide print area. How to do it. If there are two available to your class, you resolve it. They could have done it for multiple inheritance also, but they haven't done it, so they haven't done it. Is it a bad style to use multiple default methods I would say. Generally speaking, we keep default method to minimum. We don't want to keep it many, many of them. But if you need to, you can provide them. It's not a problem. As far as it makes sense, you can use it. OK, you got it. OK, so now what's happening? This is a circle class, which is a shape. OK, Now, just to show you about the package business, I just create a new package here, which is a new directory, and I'm creating a new package here. So this is the class A and I'm just saying this is some other package. OK, so this is package some two Now, how do I import classes for some other package? So this is what you do? I can import shapes is a package. Which one is This is the original package here. This is the shapes package. And so what I'm doing is that I say I want to go to Chef's Package and import all the classes. Now you can, so it will import circle rectangle, all of them, whatever there, OK, but I can also pick and choose. I can also say import from this package only this class, depending on what you want here, I'm importing everything Al. Alternatively, I could also input interface, input everything so on and so forth. Ok? No So Shan. It is not your confusion earlier So the default method in interface now is kind of you. I agree with you similar to methods in abstract class. You are perfectly correct in that OK, but earlier version There was no method in interface because as I mentioned a few reasons, they have introduced default methods. Then you're right. It becomes kind of similar to abstract. The only difference Now if you want to think if it is an abstract class then if I extend that then I cannot extend any other class. But if it is interface, then I can implement multiple interfaces. That gives more flexibility. So now now I see. See here I say class a and circle. Now that circle is coming from that package and I can do that because circle class is a public class, so I can use it even outside the package. No problem Now I'm extending it So this class has everything which is available in a circle. Ok, now I say I'm a constructor. Now you see, let's go to the circle class here and here again. These are different types just to show you the tissue. Generally, we are able to be private cat set, But just to teach you about the qualifiers Exactly. Now the effect class is more limiting than interface. That's what I keep on saying more and more You will be using interfaces. OK, so now you see here deliberately, we have done it. I mean, it's not a good practise to try differently qualified, but just to learn here. So X and Y are default. Ok, uh R is protected. So if it is default, it is available to Subclasses only in that package. Not outside It is protected is also available outside. So if I go here, I can use R here. So if I say this dot it only gives me R. It doesn't give me X and Y because they are default, so they But they will be available in subclasses in that package, but not outside the package. R is available outside the package also. So what is available outside the package? Public and protected. That's it, private. Of course, not. And the default of not OK, so try Try this This whole That's it. That there's nothing here just to show you the AIS modifies. Ok, now if I say X equal to this Sorry, I can I can X What is X? Because X is default and therefore it is not available outside the so on and so forth. Any questions now? Two things I want to show you. I think we can quickly cover them. Which one was that? If you see uh integer double. Ok, so quickly Java has got everything is a class Sorry Object. Ok, so there are different classes and objects of different classes. OK, but it still supports well again. I repeat that if there are more methods common between the classes Subclasses Sorry, then I would rather go for interface because I don't need default there because they are proper methods. OK, but after default method, the the difference decreases. Ok, so, uh, it everything is basically a It's a good style to Well, if you want to import all the classes, you start. But if you want to only select a particular class then you will go and select that class. Otherwise you just say star. The question is that you know, when I say package dot star, I'm expecting Well, good practise and depending on what you want to do now let's go to the wrapper classes. So it has got the basic types. Well, as I say, depending on what you're trying to do, whether you want to put star or not, OK, but if there are implications, you won't do it. If there are no implications, you do it. So in teacher is a basic type which is available in the sea, which is same available in Java also, so everything is object. But there are some values which are not object. They are just primitive types like in double float char. They also exist in Java, just like see, they are not classes. But then everything else is an object and that object is of some type class. So what Java has done in an original package? They give you a class for every primitive type. So for in which is integer, there's integer class. So what does he do? So it kind of conceptually wraps around the basic primitive in type. So what do you mean by wrap around. So I said OK, it gives you all the methods which might be useful to deal with integers. So what are these methods? So say maybe somebody gives you integer as a string like 25 as a string. You want to convert that string, parse that and get the number Well, that method is already part of the class integer you see here integer is a class wraps around the value of the perimeter integer. This is coming from the API so and there's a static method called powers. In what it does, it takes the string. It parses that string and converts into an integer value. Do you understand that there is also a method called two string so it can take integer value. P, 21 convert that into string of Phi character and things like that. Now you want to know more, isn't it? What other things are available? Even I don't know. Remember I give you an example. What is the postcode of Fremantle in Western Australia? I don't know, but we can find out easily. So go to Google now and say Java 17 API in teacher class. It will give you link. Go to the a P. It will tell you all the constructors, all the methods, what they do and you use them. This is what even I do. You do? Anybody does because we can't remember everything. OK, so this is where API S are quite useful. So there's a class for double integer so on and so forth. This is called wrapper classes. The wrapper classes. The concept of wrapper classes wrapping is used extensively in many different contexts. OK, the one recently I heard was, uh you get a lot of wrappers start ups now on generative A I because it does something and hallucinations and all of them. Now I want to wrap around and add one layer and have my start up company so and so forth. So this new word coming up wrapper start ups, you know? Anyway, so so and so forth. That's fine. Now, one more thing I wanted to show you is about strings. Uh so OK, the examples there, but strings are slightly differently treated. OK, so just to save space in the old days, so it's what it does is the following. OK, if you create a constant string like this. If I say I get a string, I save in one right here gun and then I create say, New York, I say another now when I come here and I said Sydney again Now what Java does and that's a little bit peculiar is that it says that look, you gave me this string literal. So it will create that string in the memory and say, save it at memory address 7000. I'm just making up here. Sorry. Next time you want to create the same literal, it will search it. Do I have it already? Say yes, you have. I don't want to create a new one. So when I do this, it will go and pick up what I have. So S One and S3 both will be 7000, not number as the same reference. They refer to the same strength because it saves space. Why do I create another litter? You got it. So to test your knowledge, it says that S one and S two it will be true or false. Here it will be true because they will be the same. Of course, the New York is is some other reference. Now you say No, no, hang on, hang on. I do want to create a separate strings, Sydney, because I can operate on that and I don't want that to influence the first one. No problem. What we can do now is that if I create new string classes already available as a part of Java and a string, so now this is reference S four maybe say, 2000. When I create another string, it will actually create a new object at a new address. Say, 8000. So now S four and S five are different. So if you really want to create two separate strings, they are not connected. You need to say new string and then provide the li if you just put the literal it refers to. If it exists, it's the same address you will pick up Now again, you can test your knowledge by running this, but that's what it's supposed to do, looking at the time. If you change one, though, will it change? Yes, it's the same string might. It's the same reference. OK, now, if you want to change anything, you just want to use string because the literals, you will be a bit limited The way you change it. You generally only use them to create new strings. For example, you generally do. It may not even allow you to modify. Just try it again. I haven't done it, but the whole purpose is that it wants to treat it as it is. If you want to manipulate that, then just use new string. But it's a pointers all over again, but it is called references and I. I generally give these numbers so it's very easy for you to understand that you don't see. But then you don't need to consider it. It is. You just consider that just a string. And the reference is string OK, it's 1050. Any questions? Guys, he's fine. You have problem. So this is called scoping, OK, name, space scoping or whatever they call it. OK, so generally you're right if you if you have two pack and that's why somebody was asking Is it good to do star? Because star gives me everything and I may have conflict now. OK, so yes, generally speaking, unless you want to input all of them, you want to go and selectively select them and then name differently so that we have to manage name scoping. OK, and there are different ways you can access particular package. Also, um, so the assignment one will be released. I'll release that in Thursday lecture, and I'll give it introduction to you briefly. OK, And then, uh I think, uh, Monday, week three Carl, who is going to manage the assignment will come and give you more detailed description. But the point is, Thursday we release it. I'll tell you what it is. You can read the the specs and get started, and more information will also follow in the week three. OK, so does Java Try and save space by creating the same oil? I think that's what it's trying to do. Well, this was the historical way Java handles string. Now don't ask me why. That's how it does. Python does something differently. Sharp C# does differently, and that's how they are. So at one point, we just need to learn what they do. I we have views, but that doesn't matter. Is it? OK, guys, Um, I'll see you on, uh, Thursday and we'll talk about your assignment. Bye. For now, Yes, ma'am. Yes, ma'am, to me.

SPEAKER 1
Mhm. Same interface that you share to Different.

SPEAKER 0
So So if you want to understand method forwarding, you don't need to get Let me log out here before I forget. So it's simple. OK, if a class gives you a particular method and if I want to use that method, you just create an instance of that class. Yeah. So the idea is that somebody has implemented that method. OK, so why do I read? So I think we created object of that class. That's very simple. There's nothing no more logic here. Sometimes we also do that because I can call that method and then I want to modify it slightly. So, for example, there's a method which gives me temperature of a particular device. OK? And that was made in USA. So the temperature comes in Fahrenheit. So I just call that and then convert with the cells here. So sometimes you can even modify behaviour. Once in forward exists, one is simply forward. 45
