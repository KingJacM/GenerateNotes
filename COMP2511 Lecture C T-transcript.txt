SPEAKER 0
mhm. OK, I think I'm sorry. I'm a bit late Sometimes traffic is not expected. Uh uh. Unexpected. Sorry. Ok, Um OK, so I hope people online can hear me and also see my screen. Ok, if you can then just say yes, please. Yeah, that's great. OK, so, um last lecture was all about, you know, concept and what is a class and what is inheritance and so on and so forth today? I think, uh, let's start from, uh uh this example And we interactively create a class and create an object and actually understand all the important aspects of how we can actually, uh, define a class and then create objects and so on and so forth They pretty much hands on. OK, now there are very few important points which I'm going to cover. Now, remember that this is your third course in computing. At least third one. Maybe you had done more than that, but at least two prerequisites. So I hope that we can move on, uh, reasonably fast. But if you have any problem, please ask me questions. What I'm going to do today is that I'm going to show you all the important aspects. Uh, you need to consider when you define a class what happens behind the scene, Everything relevant to what we need to do in this course. OK, But at any point, you can always ask me if you have any questions, OK? And then we'll go back to the slides. But we hopefully cover most of the things which are already in the slide. OK, I just keep it here in case I miss any topic here. But I'm just going to start first. OK, so, uh, first of all, uh, just like you define a type in AC class is nothing but a type. So when we define a class, the Java interpreter is simply going to remember any object of this type will have these properties and this behaviour. So these these are the variables associated with that. And these are the methods associated with that. There's only one copy of class, so it is kind of it remembers what it is, and it stores it itself. And when we create an object which we will do today, it will then go and look at this class and accordingly execute the methods method is nothing but a function here now. So first of all, I can say the class, which is a keyword and the name of the class, which is circle. OK, now, Uh OK, so what we do is that we provide the class sorry class and we provide the name of the class in this case Circle. So what is public before that? That's called access modifier. OK? Meaning that we say like this class is available to everybody. You know. Everybody miss all other java files in this package or other packages. So you see, the word package comes into the picture. So what is the package? So package is like a collection of Java files together. OK, so you can have a package for maths library. So basically, as you can expect that it will have few classes defined, which may give me some different functionality. Uh, regarding mathematical operations, OK, I may have statistical package which gives me functionality for the package. So package is nothing but collection of classes, OK, and then we can refer to them under that package. Interestingly, in UNIX in the Linux context package is nothing but all the classes in that directory In one directory. So package corresponds to a directory in which we have different classes. OK, now, in this case, because it's our first class, I'm not defining a package, but very next example. We'll also define a package. Just one line. We have to start right at the start. But anyway, so in this case, what we are saying is that this class is public, meaning it is available to every other class in this package or maybe even other packages also. And we'll go through those examples now. There are a few things I can write. I can write private meaning that it is not available to anybody which doesn't make much sense, maybe in some case, but not here. And we can also don't write anything which has got default interpretation. But let's make it simple and start with and say public available to everybody. OK, then there are few. So a class is a type. It's like a structure. Somebody asked me after the last lecture. Yes, it is like an ADT. So in ADT, you basically have somewhere I can store information about my cue about my stack about my set and then operation on this data That's exactly what the class is to start with. So in a way to start with it is an abstract data type. But of course, there are many other features like inheritance has a relationship abstract class interfaces. All these then gives tremendous power to class so that it really changes significantly generate types and so on and so forth. OK, but let's start first. So we we need to store information. So what is a class just refreshing our memory from the past? Lecture. We define a class to represent entity or a relation like a student, a customer, a patient or a relation so on and so forth. So we need to sort information about that entity or a relation. So here is a circle very simple example. So I say Look, circle has the centre, which is X and Y value, and it has got a radius. OK, so I want to declare three variables in which I can store information about a circle tomorrow. You may want to have many more variables. You want to have array, whatever all these you can do. OK, so that's first of all. So these are the three variables I'm declaring. Now you see, here we have declared it in a different way. So first of all, technically, I can declare it like this like the the the Classic Uh, three different lines. But that was an example. Say, um OK, so it say X is of type integer assignment exactly what you're saying in C. I don't need to tell you much. Yes, yeah, we'll come to that later on. Yeah, so? So basically you go to public private or default and what they are. We'll talk about that because it makes sense when we talk about packages because otherwise it's right now it's OK to public and private is fine now. So basically it says that So this is no, this is a default, by the way. As you said, I'm not putting public or private, so it's called default access. Pofi so got public private and default OK, and the fourth one is called protected. But don't get into that right now. Public, private and default kind of should be OK. Default also is available to everybody to other classes. Also public as is also every other class private is only available in this class and therefore deliberately. I'm only putting one variable R as a private. And so you will see that it is not accessible outside this class just to show you that. Now, this example, the way I'm declaring circle here is not the ideal representation. OK? But this because we want to teach you how to declare a class. OK, so therefore we are declaring some variables in one way, some the other way. Ideally, all of them would be private, all of them. And I tell you why. So, generally speaking, all the variables you keep private and you only access them through so called getters and the setters. So there are methods. So, for example, there is a variable R here. It is private. It's not even available outside this class so nobody can access this R. You can only access it inside this class. The matters inside this class can only access R. So I said, Well, hang on. I'm gonna make use of that. So first, of course, bats inside this class can make use of it. But if some other guy wants to outside class wants to change it, they can only change it through get setters. So what is getter and setter? So generally speaking, for every variable we put it like this. Get X! Give me the value of X Set X Whatever X. I set it here. So X is private. But these methods are public. So other classes or other objects can call this method to change the value and get the value back. Are you with me and the status? Yes.

SPEAKER 1
Yeah, a bit of a class. And I'm sorry to discuss a question As a private,

SPEAKER 0
it is only available to that instance not to other. Yeah, yeah, yeah, yeah. Private means private to that instance also. So So? So he says that there are two circles then R of First Circle is only available in that instance that's not available to other instance also. So it's really private to the instance. Good question. OK, so now you make considerable Why do you do this? Why did you make so in this case, for example, R is get R and setter. Ok, so R is a private sorry. And so I said, Well ok, I can only use get now You see why these getters and setters are useful? Because whenever you want to set the value of R, I can check it. Is it valid value or not? If not, I don't do anything. So before you modify, you can carry out checks if you want to before you return the value. In this case, I am returning as it is. But there are many examples where I process that value. Before I return. I do something with that value. Before I, for example, I may have a temperature which is in Fahrenheit because it's an American system. But here in Australia, we use Celsius so I can convert that into Celsius and return every time. So I have control on how to change the value, how to read the value. There's one extra layer on that. On top of it, methods are easy to override, which we'll talk shortly later on. So, generally speaking, every variable should be private and they should be changed or accessed through gets in the sets. You got it. I'm going through all the important things you need to consider while you define. So this gives me, uh, uh that control over what other people can use our access through certain methods the way I want them to. OK, now, Uh so that's the first thing. OK, now a few things here. So in this case, default is basically like public at this instance because we are just defining the first class so I could have put them as a public or a default Doesn't matter. So let me just just to make it interesting, let me make first default. Another is public and the last one is private. Now, as I said to you, this is just for educational purposes. Generally, art should be private. Now what is first line here? I can also define a constant OK, The way to define a constant in Java is basically I say static. We talk about what is statics? Early final means final. You can change it. So final colour reversal is a constant. It's a double same as in C. And generally we write them in an upper case and equal. So that kind of makes this is a constant. OK, done. Got it. Now what is this price static here? These variables are so called instance variables So they are associated with every instance. So I've got 100 circles Each instance have associated XY and R. You got it. But I don't need to store P value 100 times. It's just the one constant. So then I say it is static, meaning it is associated with the class, Not with instance. So there are two kind of variables instance variables which are unique for every instance and a class variable which is unique for that class. So there's only one value for that. So in this case, this value pi is associated with this class. And there is only one assigned value for that. Yes.

SPEAKER 1
How exactly does that work in memory? Is that store definition of Yeah, Yeah, So that will.

SPEAKER 0
I mean again. It's a bit different, but you're right. It is stored at the compiled time. It's just like a define of java, for example, something like that. It's not exactly, but, you know, you're just yeah, it's a it's a global variable if you want to think that it. So when you compile it just stores it. Yeah, you're finding OK, can it be a variable?

SPEAKER 1
That a change for all?

SPEAKER 0
OK, so there's an example here, you see? OK, I'll come to it. All of them. OK, so basically this is a static. So as a first thing, this is for constant. This one tells me that whatever you define, variable or constant is associated with a class. So it is a class constant or it is a class variable. So there's only one copy of that. Per class. The class is only one, so there's one copy if you don't have that variable for every instance. So when I say static, it is associated with that class. Now, in this case, I'm saying there is a variable of type integer number of circle. I initialise that to zero, and that is a static means a class variable. It's only one copy, and that's useful because what we will do down the track, we count how many times circle instances were created. Are you with me? So every time we are going to create an instance, we are going to just increase that value. So we know at the end how many times circle instances were created. That's all, just just to show you the usage of different class variables, you got it. Now what is private? So what he's saying is that Look, this pie now, you could have made it public also. But he said, Look, you know, everybody knows what the value of pie is, and every class will declare their own pie. They don't need to depend on our applic value. Otherwise, as we will see very shortly in the next week. Sometime is so called coupling. You know you don't want one class to depend on other class as far as possible so that I can take that class and use it in some other software. So the linkage of that class to other parts of the software should be there. Otherwise, no point in having it there. But you want to minimise that and easily controllable. And so the idea is that look, let's make it private. Everybody else will declare their own constants and let them use it. So I just want to make it private and it's meaningful, so I can also write this value. But through constant I can have meaningful variables. So far, so good, yes or no Now you know when we say subclass we talked about in the previous lecture. Please stop and ask me any questions online guys also because I'm going to go and cover every important points one after another. There are many of them here. OK? And if I miss anything, we'll go through the slides and we'll pick it up. But I'll try to cover all of them here and they'll run these create instances and so on and so forth. Now when I So when I say your student and the undergraduate student is a subclass of a student, so it it has. It has got all the property of the student, but I can add some more. Remember that part? OK, now in Java and for that matter, all these programming languages. There is one class which is already defined as a part of Java, and for some funny reason, the name of that class is object. OK, so that's the top most class in Java now. What does it do intuitively in a simple language? So it says that when I want to create a new instance of any class, you need to do some basic work. For example, find out the bytes required for that request to whatever operating system, keep track of the reference. All these basic stuff you need to carry out now. We don't want to do that. I don't even know how it happens on Linux versus Apple os versus windows and so on and so forth. So that object class carries out all these basic operation. Any time I create a new instance or a new object, do you understand that? And so when we write any class in Java, it becomes a subclass of the object class. You got it? Whether you say it or not, say it doesn't matter. Really. So technically, conceptually, what we are doing is that now subclass, you can say circle is a subclass of object here, object for funny reason. They name it as object. Object is actually a class. So you say extends O capital. See, that's a keyword. Green is a key, uh, class thing. So even if I don't write it, Java would insert that for me. So I don't need to write it explicitly. But this will be inserted that so meaning that my class is subclass of object. So I will inherit a lot of these nice methods and properties from object Which world will work behind the scene? You got it? Yeah. So far so good. So I don't I can write it. I don't need to write it. It will work, so I'll just go to it. Normally we don't write it OK now, So that's that's That's the definition of this circle name. They got us winning information now, and this is a class variable. OK, now this one is the same name as the name of my class, and it's exactly the same we call Constructor. So how are you going to construct or create an instance of circle an object of circle so we can decide different ways to construct? So they are called constructors. An instance. In this case of circle tomorrow it could be a class patient, student customer, whatever. So, for example, we are saying if somebody simply wants to create a circle without providing us any information, so they are not giving me any, there's no argument there, you see. It's like a function definition, but there is no argument there. There is no parameter. So he says that if nothing is given, then by default, the value of Y will be zero value of R will be six. We just randomly pick six. Yeah, you could put whatever you want to put and same thing. The value of X is also zero. So by default the centre will be zero and radius will be six. If you don't tell me anything, it will assume these values. Do you understand that? If I want to change, I could have changed it here. You know, I can go and change them here in this class. You got it now again, I don't need to write anything here. So as a circle, all I'm saying See this variable? I'm increasing by one. So I said, Well, one instance is created. That's all I'm doing. That's very simple. But technically I could have changed the ability of XY and R here if I wanted to. Are you with me? Yes or no? Now, before you create a circle instance in which you have value of XY and R, you want to just create an object or instance, and then you will add three variables to that. OK, so what it will do, it says again, just like the extent object, it says when you write a constructor, the first call in any constructor should be to construct the superclass, so construct superclass first, then add the value variables for this class. Do you understand that? So technically we could have done like Sorry, technically, we could have done like this. Super is a keyword This so it says, Go to the Super Class in this case, object and create instance of an object. So that's what Java technically wants to do. And therefore, Java says, First you create an object of the super class. In this case, Superclass is is is a is an object class, which is the default class. So I'm saying OK, without any argument, just can you Now? Super is a key word, so it calls the constructor of the super class without any argument. No argument, constructor, and it calls it now if you don't write it so, comments are slash slash. This is a comment Now. If you don't write it, Java will insert it automatically for us, he says. Hang on, you forgot it, but you must create object of the superclass so it will insert. First line will insert constructor of the superclass. If you don't say anything Superclass constructor without any argument, so you can write explicitly now why it is, but however later on as you will see we can call the construct of the superclass with some other argument. If you choose to prefer, then it will call that. And if you don't write anything without any argument, yes,

SPEAKER 1
it's very good. But, uh, a week. Would you dot com? Yeah, on this particular instance.

SPEAKER 0
So the idea is that when you are creating an instance, it's basically OK in simple language. What happens that it needs to go and seek memory allocation from the operating system, and it's somewhere in the memory it is going to store XY and R. That's all it does Remember. The definition of the class is remembered by meaning that all the methods and everything is remembered by interpreter or compiler and eat somewhere there. OK, now, any time I create an instance, remember what is happening behind the scenes. It basically finds out you need three variables so it will find a place to store these three variables. That's all it does. The rest is already remembered by the compiler or the interpreter. You see a new instance. It will seek memory or location in this case for XY and R and stores it. That's what it does. But to do that that that is the job of the constructor. And again, we don't need to think that low level in Java it just creates an instance in which I store something that instance is associated with circle. So when I go to that instance and call a method, it will call the corresponding method. Is it clear? Now we say, Well, hang on, let me give some additional functionality or benefit different ways My client can create circle so the client can also tell us the origin and the radius. Accordingly, we create circle. OK, so client can When they say new, so client can say new circle and they say X is three. Y is one and radius is R, so it will patch to here. Are you with me? Yes or no? So now these values are coming from user The client plan with other method which is creating instance of circle Are you with me? So therefore these values then should be copied to this instance Variable yes or no. So there are two X's here in that matter. One X is this one and the other X is this one. There are two different axes. So if you want to make it simple, you can just give a different name. ABC. So there's no confusion, OK, but generally we put the same name because semantically they are the same. So then how to refer to them? Ok, so if I go now because the ideas are useful nowadays. Sorry. Uh, if I go and put X here, OK? And let me just put some value here, OK? Ok, so if I highlight this X you see which one is highlighting here? Remember that? So when I only say X in that context, it refers to the parameter of that constructor. Are you with me? But if I want to refer to X which is part of this instance So this is a keyword. When I say this, I'm referring to that instance. So if I go and say this Sorry. So let me put X equal to five, Ok? And then I say, Look here. This is a keyword. If i put dot it will tell you in this instance you have these variables available to you, XYR and some other methods. You see, there are so many methods here, all these methods were defined here and some of them are available in the object class. So I goes and finds out. So I can now say X equal to eight. I'm just seven. I'm putting some value here. OK, now when I say this, I'm now referring to Sorry, I'm referring to, uh, this one. Is it clear? Simple. So you may say this dot X equal to X, you know? So you know which a we are referring to Now, uh, let me finish explaining this and then maybe. OK, so what's happening right now? So I'm just going to get rid of both of them here. So general practise, you will see this a lot is that user gives me value. Sorry. Sorry. User gives me the value. And I could have simply done like this this dot X equal to X. You may You may see something like this, Are you? Me? Got it? It is also not a good practise. You can do this. You will see this because we have decided that there may be some conditions applied before I change value of the variable. So it is always a good practise. You don't have to do it. But it is good practise to always use gutters and the set to get the value or change the value because all the control mechanisms, we can put that in one place. So instead of doing this, I would rather prefer this. So I go through that possible check. For example, if the radius is negative, it will not change the radius because it will say radius should be greater than zero or whatever. OK, are you with me? So the idea is that OK, I could have done this, but I would rather go and use my gutters in the setters. So through that. So this is a better practise here. You got it. Now what is the first line here? Remember, first line of any constructor must be a constructor of the super class or constructor of the same class. So I'm saying, before you could do anything, just execute This means this instance and go to the constructor of this instance without any argument. Meaning that one can you see is highlighting here. So this line will actually execute that first. Yes or no? Got it Now You could have this. No, no, you have to say this. So he says that Can I put circle here? No, It's like just the way it works in a particular language. So you said this. Ok, so this. Now you see it. You may be tempting to say Look OK, why don't you just do this? You know, all I'm doing is increase the variable. OK, so technically, this will work in this case. This will be identical, isn't it? Got it. But it's not a good practise because I'm writing the same code, increasing the number of circle Only one line, two different places only put at one place. So if you want to modify that tomorrow for some reason, then also one place you do, you got it. So this will work currently Because what it will do, it will go and insert a super here. Now, if I don't write, it will insert that so it will work. But why do I do it? Because this is exactly here. So I would rather go and, um say this. Go on. So always try to have a no argument, constructor. Then you define other constructor and try to use the constructor of the same class don't try to just copy and paste. Copy paste is a bad news. You must try to avoid it almost all the time, if possible. And then you can do extra things. So extra thing. Is that OK? You did this, but now these are the extra thing I want to do. So I do that. So I said I could have done this, but we don't do. Don't do that. OK? Now we can also go and say, Look, you can only give me the origin and I'll use the default value of R so you can provide many constructors depending on your requirement. And so now you see, I'm not doing here, I say, Well, if you only give me X and Y, then I'll use your X and Y And my default radius is going to be seven. So I'm calling this constructor now and then use the default So there are many. So you can create many different constructors? Yes, structure Different for the same class.

SPEAKER 1
Sit very exclusively for would last a day. Is it putting? It is putting a It will do it now.

SPEAKER 0
So basically, when? When I don't When I say this it goes here and that it will use this so it will always be super there. Yeah, OK, OK. How do we know that this command will go to the public circle function? Well, Christopher, that's how Java works. So when I say this, it is going to call the the constructor of that class without argument. When I say this, I'm referring to this particular class. And when I because I'm providing three arguments, it will go and pick up uh constructed with three arguments and in this case, all of them are integers, so it will accordingly use it. So that's how it works now in Java, every method every constructor has got a signature unique identity and the signature is consisting of the name of the method or a constructor. The number of arguments and remember the corresponding type that unique is that matter. So I can have a method with M one. Both argument in teacher next method M one same name lower case MMM one No change. First one is double second is integer for java. These two are completely different methods. So the method signature is the name of the method. The number of arguments and the corresponding type. Everything has to be unique and that's useful In some case. We'll see later on. That's called method overloading. We call it OK. Same thing applies for constructor. OK, now. So far, all we have done is understood how to declare a class class and the name of the class. And if I want to, it's a subclass of superclass extend in the name of the Superclass. If I if it is just extending object, I don't need to write it. Then I have a public which is available to everybody. That's good enough to start with. Private is only available local. OK, there are two main interesting thing. Default is also generally available to everybody. OK, now what are the properties? What are the methods for this class? So now I am simply declaring a very simple method. Get area OK, so if I want to find out an area of a circle now remember, the Method Area doesn't have any argument here because I'm finding area for this instance and for this instance I know X value Y value and value of R are you with me? So all it says when I do this? Of course, there is no argument here. That means this R refers to the are in that instance. OK, these are sorry. I should go up. These are refers to that argument. Is that because there's, uh yeah, where is this thing? Ok, so I just go and find out the value of R in this for this instance and give you the area. Same thing I can calculate the circumference also, are you to me? Got it? No. So far, so good. And if you're interested the way we are going to use this, I may create an instance. Save it in C one, and you're going to simply go and say C one dot gate area and it gives you the answer, which is of type Double because it returns value double. So C one will be instant and I call it C. I'm not passing R because R is coming from the instant C one. Yeah, we also see like you can also do that if you want to Yeah, you can also get R here if you want to. So that's up to you. What do you want to do? Got it. So so far so good. I can also write more methods like circumference and so on and so forth. Is it clear so far? Any questions online? OK, now OK, Ok. So all I did I selected that I'm on the windows machine right now. Control slash It just comments out the whole thing. OK, so now there are few methods which are by default implemented in the object class. So one of the method is two string, the other is equals. These are the two we are interested in. There are some more. There are five of them but these two are the ones we are interested in. So what does the two string does? The idea is that whatever object you have, whatever instance you have can you represent that as a string? OK, And how do you represent that? As a string is up to you, you decide. So if somebody wants to go and say print C one, it will use these methods and convert that into string and print it. You got it. So it converts your instance. So in this example, that string should have information about XY and R because that's what represents that circle OK, which one is that? There was a question here. Uh, what was the question? Does this apply to two classes? Say person and student where a student extends person student extends person. Ok, as in will students constructor automatically a persons constructor if unspecified. So the question is that we'll go through that example guys. So if I create a subclass which we are going to do shortly of circle, we're going to get subclass of that and we will see how the constructor works there. Answer to your question is that it is always a good practise to call the constructor of the superclass. If you don't, it will automatically insert that line for you. That's the answer, OK? No. So yes, it would by default insert that. But it's always good practise to write it explicitly. I think I answered you but Abram, thank you. OK, Now, um so two string is implemented by default, but generally it doesn't make sense. It doesn't convert object because it doesn't know at object level. It doesn't know how many variables are there and so on and so forth. So generally it is a good practise for us to create the method to string the way we want to convert that to string. Are you with me? But remember, I said to you one important thing that the signature of the method depends on the name of the method, the argument type and all of them. If I make any mistake there, if I change anything, it will be a different method and it will not be used. So I want to make sure that the method signature is exactly what is expected. Because if I declared this method in this class, it will override the method which is implemented in object class. Got it. And to override the method, it has to have exactly the same signature. So either I can just go open up the the API documentation and type exactly which you can do the other thing. If you are overriding something of the superclass and tomorrow will be from so called abstract class or interface, we haven't covered it. We're going to talk about it. But in general you are overriding something which is already declared earlier. Most of the ideas, including code and we we prefer you use code because that's available in the lab that will be available in the exam. So better to use that. But of course, you can use anything else if you want on your home machine. But in code right mouse button. It gives you many options here. Now you can see source action. We go here, it says you know it can create all these automatically. Now it may not be perfect. You need to modify later on, but it can come up with stubs for us. OK, so you see getters in the SATs. Also, you can do the time you declared three variables. You don't need to go and type those SATs at getters. Try to do that and it will find out all the variables for every variable according to the type. It will. But of course, the body you have to implement, obviously, But it will save you some typing, that's all. So now basically, I say organise imports generate gathering, set, generate constructors. So it will also create constructors for you by default. Now, I didn't do it because I wanted to show you that you can even type it. But you can do it OK now generate hash code and equals so it can generate these two functions for me. But I'm currently interested in generating that function. Remember? So see, I'm doing it now. So it says OK to select the field to include in the two string. Ok, so this is already selected. Ok, I see. Ok, so it says this is what is created by the So it included all the three and it gave me this one representation. Now we can change it to what you want so we can create this string what we want. But you can use to do that I think it removed. My comment is right. Sometimes they are just too smart. I think it removed the one I commented out before. OK, you got it. But I just wanted to show you that you can use these kind of tools also, but they are just like it saves you time. Conceptually, they are not doing anything. OK, so this one Where was that? No, no, it's no, it's here. My comment is here already. OK, so this is here. So it added that Yeah, it added here somewhere here it added. Yeah, location. Maybe my car sir, was there. I'm not sure why it added there. OK, and then I'm saying overriding, Miss. I'm overriding the previous matter. Is it clear? So far so good. Now the other one is a bit interesting. The other one is called E equals we don't need hash things. So we are not going to go there. So the other one is called and again I'm overriding that here OK, is equals and the signature is this. So I just put as a comment to show you so in the super class, which is the object class equals method is defined as public returns. Boolean value name is equal and the sorry sorry equal. And the argument is of type object that is in the superclass. And that's because see, in the class object we don't know what is the subclasses are so it can't say argument circle because tomorrow it may be a rectangle. So it says what you get give me is of type object. Are you with me? Yes or no? Now people new to Java can make the mistake. And instead of circle they object. They may write circle because they say, Hang on. I'm in a circle class, so I'm only comparing two circles, isn't it? So I should be given a circle, Is it? I don't know. Are you me? Yes, enough. But for Java it's a completely different method. There are two different methods. So if I declare something like this, if I declare something like this So if I say this is a circle here, all I did here, you see is already other message. He says if you're declaring circle, I can declare that. But then it is not. I'm not overriding anything because there is no matter. So now it's OK now. I just declared a new equal method for myself. It is not overriding what is in the object to us, so I can't say override it. But you are not overriding anything because there is no method of this signature available in the class. And our purpose is to override because in that case, by default, I will use that equal method. That's a bit tricky. So that's what I'm going through it slowly here. So the idea is that if I want to override what is already there, then it has to be object. OK? Only then I can override. No, because you are giving me object. So this is a new instance or object you're giving me. And I want to compare. Is it the same as my current object? Are you with me? Yes or no? Now we define what is equal. So in this example, we say two circles are equal. If the values of XY and R are equal, that's what we want to do. Two circles are equal. If the values of XY and R are equal, so they can be two different instances. They are stored in two different memory locations. Three of them four of them. But as far as their XY and RXY and R values are equal, we logically think these circles are equal. That's what we want to do. So somebody gives me a new object. I'm going to compare that with with which object This object. You know, This refers to the current instruction and what is given to me. OBG is the other instance and I'm comparing these two instances. So first I say, if you give me is null then of course, this is not null because I'm in some instance. So I'm not null You give me null so false is not equal. Is it clear if what you give me is equal to double equal to is exactly the same Value is this one. And this is true. If you are giving me the same instance What other instance you're giving me is actually a thing but the current instance anyway Ok, so my instrument is memory location 5000. You give me another instrument which is also 5000 the same. So I say, if they are equal then of course true. I don't need to do anything. The simple case is fast and I'll return. So when I'm at this point, I know one thing that what instance you have given me is not none. And it is not equal to myself. So now I need to compare XY and R. Are you with me? Yes or no? But remember, what is given to us is of type Object. Are you with me? Yep. In the class object. There is no declaration of XY and R. Are you with me? Because object class is a superclass of everything. Any instance can be treated as object. Remember, undergraduate student can be treated as a student Postgraduate can also be treated as a student and the student is subclass of object. So all these instances eventually can be treated as an object but with one important thing. OK, save. There are variables declared in undergraduate when I treat which are not available in a student. So when I treat instance of undergraduate as a student, those values which are declared in undergraduate class are no more available when I'm treating that as a student and with me or not. Yep. So when somebody gives me instance of type object at that level, I cannot find the value of X and Y. So if I say obj dot X, it will give me error message. And what are you talking about here? I'm just putting some value. Here is error message. There is no X associated with because what you're giving me is of type object, and object doesn't have variable X by now. But remember that instance may have been created as a circle. But I can treat that as an object because object is super class of circle. And when I'm treating that as an as an object for that time, I can't use XYR but like you see, I can downcast it If I'm confident that it is coming from a a circle class, I can downcast it so as you can see here, So that's not possible. So first of all, I say, OK, can you go to my current instance and get the class? So what? This will return. We know we are in a circle class, so this will return circle Conceptually. Yes, Yes, yeah, yeah. Get class is a part of the Java implementation object. Yeah, so get class is already available So give me the class. Same thing. Give me the class for object which is the new instance you give me. So in our example we know this will be class because we are in a class in sorry circle because we are in a circle class and we also want this to written circle If they are not equal, that means they are of two different type. Then I also return false You got it? Yes or no, Because they are two different types, so they are not equal. So now when you are here now you know both are of type circle now you know that. So now I will downcast to circle with confidence because otherwise I would have left. If one of them was null, I would have left if the other one is not the same type of circle I would have left. So now I go here and say do and downcast that cast that to circle. And this is my other variable, which is of type circle. So now I'm down casting it. But I know that that is of type circle otherwise, if not, it will give me error message Runtime error. It will crash. Sorry, You can't downcast that. But here we have gone through all the checks. So we know it's a circle. Now I can go and say other dot X See, there is no problem now See, now there is no problem because other is of type circle, so other will have dot Have access to XYR everything. Yeah, OK, you don't. But generally that's a good practise. OK, so now I can access everything as a part of the circle. Any questions? Please ask me online or here. Ok, so now this I just typing to show you that it's available now. So now it's simple. Now This is also of type circle. So now I'm just checking XY and that's all I'm doing. So I say this dot X must be other dot X this dot Y must be that simple, As you know, then to other written false OK, that's your equal Bit more involved. So the only first caveat is that equal must have argument of type object because I want to I want to override the method declared in the object class and because of that, I need to downcast it to my current class. And before I do that, I go and check whether the other instance is of the same type class or not. Otherwise, I don't do it. And of course I don't downcast If what is given to me is now, hm? Yeah. So if if you have a postgraduate subclass of a student with subclass of object OK, now, if you have an instance of type postgraduate, I can treat that as object, OK? And if I were downcast, I can straight every downcast to postgraduate student. If that's what the question I can simply say the same thing. So it would just go down there straight the only thing you need to realise is that whichever level you are, you can only access variables that method available at that level. That's it. OK, so if there is a variable a B and C and method M one available in a postgraduate but not in a student. If I'm treating instance as a student, ABC and M one are not available. But if a downcast they are available, you got it and we have some examples going through. We'll go through them also in line 69. A downcast. That's right. Answer is yes, sir. OK, Any questions, guys, before I proceed So all we did today in the first hour is declared a class understood nitty gritty of constructors. OK, also, how to declare Instance variable. How to declare a class variable or a static variable. Same thing. Then how why we need caters at the sets, how to declare just the matter. So method definition is rather simple here. And we went through it how to override the basic methods like two string and equals. All we have done is created a class. Now let's create circles. So let's go here now. OK, so now I can say class, I'm just not see everything is class in Java. So I want to write a test programme where I can create some circles and do something. I had to write another class but now I don't want to have local variables or anything. So all I say my class is test one. Now I don't declare variables or anything I just declare you must be aware of. What is that? Just like C. So when I'm going to execute this class, it will execute the main method like C Very similar to C. Almost the same. Ok, so all I do is I declare a main method And this method is I only want to associate this method with this class. So it is also a class method and therefore I say this is exactly what you have considered in C. So these are the all the arguments and remember in C we have to have arc in Java. I can simply go and find out number of elements in this array. So I don't need another R value there. RC The RC is not required because from here I can calculate RC, I can get RC and it doesn't return any value. I now say it's publicly available and I say static so that there's only one copy per class because I'm not going to create instances of test one Yes, like

SPEAKER 1
sea defined as having any parameters.

SPEAKER 0
It I think it would work. But you want to declare it anyways. OK, so C is a bit more relaxed about certain things. Java is not. It's in a year to do it properly kind of stuff, but I think it should work. I never tried it, but it should work. But yeah. Now how are you going to create instances and what the meanings And so so these equals we define in our method is different to the equals. That's exactly right. So the equals we define in our circle is different to the one in object class and so therefore we have a control on how we compare to circles. Now, if you use the default method, you can try. You can delete that and run. It will not work properly. OK, good question. So I say new circle, it creates a new instance. OK? Yeah.

SPEAKER 1
So if you, uh, like a generalised, just kind of through each of the No, no, it depends on what

SPEAKER 0
you want to do, you know? So it's not about a variable. Sometimes you may. The whole notion of what are the two equal instances is entirely depending on your requirements.

SPEAKER 1
So yeah, yeah, yeah.

SPEAKER 0
All those stuff. Or you can say they are equal if they're within the range, for example. So that's just a domain specific. OK, now So now I So how do I get new instance? You say new the name of the class and I'm just using the default constructor so the value of XY and R will be whatever was in the default constructor. OK, now, just to show you conceptually and you don't need to do it all the time. I stored that in C one. Now let's assume what is C one. So technically it's an instance. So what is the instance in this example? It is just a place where the value of XY and R are stored for that instance. That's it. You got it. Java manages everything. We don't need to worry about it. If I want to access that X, I'll just see one. Get X change XS, YZX or whatever. Now, if they are public, I can even access straight away like C one dot X and C one dot Y. But as I say generally go through gats and theirs. That's all it is. So see one, if you really think and again I don't want you to think after this lecture is nothing but a pointer to a memory location where this instance is stored. But they don't call Explicit Pointer because you can't do anything with that except see one dot the method name or the variable name of the public. That's all you can do. So it's not really Pointer like C, but technically it is a reference. So then all I do see one dot get area will print the area for C one and currently it will have a default radius Whatever it was 67 or whatever Accordingly it will print radio. Are you with me now again? I'm saying I'm not passing R. We have already discussed that. OK, now I said no, I want to create a circle. I want to tell what the value of XY and R are. So I'm just using another constructor. That's C two Let's assume that is at 6000 Address. I'm just giving these numbers just so that you understand instance is nothing but a reference. Sorry. The variable C one and C two is nothing but reference to those instances. That means the values where those values, for instance are stored. And this gives get so far, so simple. Please ask me if you have any questions. Now, by this time, remember, there are two new new circles So this should be two by now. You got it. So how do you access the class variable? You put the name of the class and so if I just go and id will help you here circle dot It will now it gives me the number of circles which is basically what I have declared with me. And there is also another set number of circles. I think it may be declared somewhere in that. OK, so because we may have created constructors for the G in the centre. But anyway, so it shows you I can just go and say that and I can print it. I can modify whatever I want to do. So in this case I'm simply printing the value of that. So that's how I access. So here. I'm not I for the class variable. I had to put the name of the class dot the static variable. There's only one copy. It's like a global variable, not a good practise to use them because they, as you will see later on increase coupling. You know, dependency a lot, but there are places where it's good to use, but generally you don't want to. If you don't need to, then I'm just printing something. Now. I only go and say print C two. So I said, Hang on, you are asking me to print instant. So what does it do? It goes to two print method and prints it. Therefore, we declared the two print method. So by default, if you want to print instance what it actually does, it does this. It actually calls the two print method. I have to put no argument here, so I don't need to write the whole thing. That's what it does. So if I only say print instance, it will just call the corresponding method and does it. Yes, that's right. If you get a new one then I have to write the function name like my string. OK, then I can say C two dot my string It's fine, you can do it but I don't want to type every time. So I say two string but default. If somebody just wants to print this instance that's a default representation. Good. Now I create one more circle, another circle. So by this time we've got four circles with different value. This one is another construct with two default value of R will be seven or whatever so on and so forth Is it clear so far? Yes or no? No, I say see one dot Get X. It gives me some value. I print it. OK, you got it so fast. The food. Hm Four circles C one C, two C, three C seven. Now let's say C three is at 7000. I'm just making up the number. OK, ok 5000. 6000. 7000. See what I'm doing now? Now I'm saying C two equal to C one. This is why I'm putting those numbers for you. So C One and C two are simply references. So now I'm saying C two Sorry, C One is going to be the same reference as C two Are you with me? So what is C 2 6000. So C one is going to be 6000 C two is also 6000 Is it right? Is there any variable now referring to instance at 5000 automatic garbage collection Java will come and free that memory Because internally Java remembers that every instance should have a reference It will keep track of all those behind the scene. So early versions of Java was slower because you have to do it like it doesn't do like every second but every regular time interval it does it nowadays Those algorithms are so fast that you don't even feel any difference in the speed. And I mentioned last lecture is that all they do is they use directed graph. Remember that like 5000 is a node Every variable when points to you have incoming link When a node doesn't have incoming link, that node has to be free. Yep. No. Yeah, it just It depends on that. Yeah, that's the java. Is it OK? No. So no we referring to So that is already gone now I think somebody asked me a good question last time or eventually. What we discussion led to is that Java only frees the memory allocation, which is part of the Java. Sometimes what happens that instance may have a pointed to the open file or open database. Or maybe it has created connection to chat GPT outside or whatever. So I'm using that resource. Java will get rid of that instance, but it's not going to release that resource. Remember that. So if you are referring to external resources, it's our responsibility to release them before Java is going to do garbage collection. You got it. Now there are ways to address that, but we don't want to go that at this point, and you can do Google and find out OK, but the idea is that it's our responsibility to release them, but as far as memory, it will look after them. So now if I go to C one area, this will be the area of actually C two. Remember, because C one is now pointing to C two. Now it's a running code here so you can run it now when I say this what happens? See one double equal to seat This one compares references. It doesn't call equals method be declared. So this one is simply going to compare two references. So C two is what 6000 C 3 7000 are the same, so that will be false. However, if you look at C two and C three, 258 258 Do you understand that so logically these two are equal circles They are not two different They are not the same instances. They are two different instances so logically same. So when I go here and I say C two equals Now this is the one we declared just now in this early part of the lecture. So now this will compare XY and R of C one, C two and C three. It happened to be the same. So that will return True? Yes. What is that you did say to No. So So that 1000 of those numbers I just gave you just to understand Be No, no, we can't do anything with that. So that's exactly point. So that reference we can't touch it, We can't modify it. We can't add anything. It's and even that is actually not even that number like that. It's a bit more involved. OK, but that I only give just conceptual to understand it is a reference. But technically like you see, you can increment remember that Like you know, in a plus plus and nothing like that. It is just a reference. And through that you can access the corresponding variables if they're public or whatever and the matter and that's all it could do. Yes. When you say new class, that's what are you doing? No, but I mean, the idea is that you don't deal with memory, right? You're not dealing with membrane pointers, everything java looks after. So all you do is create instances. That's all. That's all. Just one question. I come to you. Can we still? Yes. You can also use Can we still use the original two string definition? Ok, um Abram will come to that later on because we have to cover a few topics before we go there. But in our current implementation, we can't OK, but that question is about polymorphism. So, uh, we will we will discuss that, OK, if you want to, you have to find a way to do it, but I would say that will be bad software design. Um, yes, ma'am. Is there a way? No, no, no. So C++ When Java entered the C C++ was around and they tried to really not do things. Certain things in C++ which was creating in their life interpretation, providing more flexibility to create confusion kind of stuff. So they don't give you multiple inheritance. They don't give you free because they just wanted predictable behaviour. So, like, you define something different new software guy comes after two years and they interpret differently. You see, it's all these things. So they say No, no, no, no. Make it that simple. OK, that was the idea. Good, bad. Both sides. OK, but good question. OK, well, that now I mean you can just run it and it will do exactly what we discussed. The code is available to you and you can go through that. You got it. Now, the reason why I give you all the code is because now can you declare some more variables public? Ok, One thing I should show you is I think R was private. Is it right that I think our was private. So if I go see one dot it doesn't show me. R, Can you see that here? Because our was private. I can't access out here. You got it. But because the get R and set are are public, I can I can I can use them get R and set. Gar is there. I don't know whether satar Yeah, satar is also public so that just you can try it out, make it public. Private default is available accessible from outside public, obviously protected, which I haven't covered, which also is available outside Private is the one which is only available in that class or in that instance And generally variables should be private and you access them through and et cetera. I keep on repeating it even though we haven't done it yet. Now, is it clear? So far now, all we have done is just created a one class. Got it. So, um OK, so so far so good. I've done so many things. I'm just going to go ahead. Uh, with that we created the class and so on and so forth. We did all these things, OK, use the matter blah, blah, blah OK now subclass and inheritance. There are three possible approaches. I would explain that on a slide and then we have programmed to run it. OK, don't worry about that. So the logic goes like this. Ok, so the logic basically says we created AAA object. Uh, sorry Class circle. Now somebody says circle is a just only X by an hour. But what if I want to represent a graphical circle so that we have a you know, the the colour, you know, So that can have the the the outline colour the fill colour Because, you know, it's a graphical circle. You got it. So it will still have origin. X and Y it still have radius. But two more things I need and I need to allow them to set and use and so on and so forth. So can I just create a graphic circle as a subclass of a circle? So I inherit everything in the circle from circle so I don't need to declare calculate area calculator circle for us. All those methods XYR all the I mean, it's all there. Can I just use it in my graphic and then add more variables than matters if I need first example of inheritance in action. OK, now you can do that. You can achieve these in multiple ways. So the first approach is is that you just create a new class craft circle. You're not inheriting anything. Copy paste. You declare this variable copy and paste add more. The idea is that obviously that's not a good idea because you're just repeating the code. You got it. The second one is interesting. The second one uses has a relationship and it is quite popular just that in this instance, it may not make sense. Why? Because graphical circle can use everything defined in a circle. So everything makes sense in graphical circle which is already in circle. So I would rather use inheritance. But say I want to use haza. This is how we do it graphical circle and I just declare a variable circle. Can you see that here So graphical circle has instance of mathematical circle if I call it but I need two more property. So I declared two more variables. Colour is a type already defined in Java. Then I have a constructor. You know very well, but I say So you know, the the super will be inserted and all those things I don't want to repeat. But I said, the first thing I do is I just create a mathematical circle. And then all I need to do is to extra thing if the user gives me XY and R and these two colour, I create a circle with XY and R and I maintain two colour. So I'm forwarding everything to do with mathematical circle to mathematical instance and only doing additional work. That's good. OK, so now you go and this is extra method I'm putting now. I can also, when you want to go and call get area, it will simply go and say, see dot get area The answer. I'll show it to you and implement it so it needs to write those stops for forwarding the method of forwarding. We call it. I'll go and show you in a in a Java shortly, so that's kind of. But in this case, we say, look, everything in circle is applicable graphical circle. So why do you want to even do this? But again, I repeat, in many cases, iza is a dangerous and we go for Haza. So this is a very, very useful approach. But if ESA is relevant, go for it. Otherwise go as a yes man. Why did you do you? You You could put this dot C or C Because if there is no ambiguity, I don't Don't want to put this See if if there is somebody gives me C then I put this dot C So this is actually this do But there is no ambiguity with the sex. OK, so we use method forwarding So that's one approach and the last one and we go through all this files shortly. But I just want to show it on the slide F So it simply says graphical circle exchange now circle. So everything is circle is available. I don't even declare anything right now XYR everything is available. All the methods are available. All I have additional variables now I still need to write a constructor so I super here super is actually circle. So it goes to the circle and call no argument, constructor. In this case, it goes to super meaning circle and calls the constructor with three arguments and so on and so forth. Got it. And then I only do the additional work here. So and so forth. You got it. We'll go through the Java file shortly. No, but how does it work? And I want to explain that with respect to circle and object. Same thing. But make sure you understand this I can say new graphical circle. I store it in a GC which is of type graphical circle. Are you with me? Got it. So I don't have my pen here, so I just try to write it like this. So I just say C is my circle. OK, so that's my class here. And my GC is my graphical circle. Got it? No, I have variable XY and are available here. And, um, some outline colour is available here. Feel colour is available here and extra methods when I and also area. So when IAGC dot area is good to go or get area, whatever that name was, it will use the area method defined in circle use. It is already available in graphical soccer Makes sense? Yes. Now I can also then say can you assign GGC to C variable, which is of type circle? So now this variable is actually referring to the same instance which you created here as a graph. Are you with me? But because the type of C is circle, I cannot go and use the method defined in graphical circle. So graphical circle. There is a method called Draw, which is not available in circle. So when I am using C, I cannot say C dot draw, because when I'm treating that instance as a circle, I can only access method variable available at circle. But if you're confident, then you can downcast that do GC and use whatever you want. You correct so internally. It remembers everything so internally it does have an outline colour, field, colour, everything. But when I'm reading, there's a circle. You can't access them, that's all. And that, Yeah, so C as a variable.

SPEAKER 1
So but it's referring to an instance. So if you do get class, does that give you circle or graphical?

SPEAKER 0
So it says if you do C dot get class, it will give you a graphical circle or a circle graphics.

SPEAKER 1
So if if you get to the the class very

SPEAKER 0
great, yeah, yeah, The class was created good, and we have example of that coming. But anyway, a good question. OK? Any other questions? OK, so now let's go to the the programmes and see how all this works out. So there is a example Week two, all this code set is available to you. Um OK, now I'm declaring a package. All I need to do is this name a package. So that means this particular class circle is in the packet shapes and generally that refers to one directory. So all the classes in that directory are in one package. So here I'm defining a package Shapes Are you with me? Yes or no? Got it now? So now it basically says circle extends another class called shape. Ok, uh, I'll talk about that after I explained that to you graphical circle extent circle which we just discussed in the slide. Ok, and this is just a Java implementation of the same again. It is also part of this package importing colour and graphics modules here graphical circus subclass of circle. I only declared two extra variables Constructor, super blah, blah, blah, XY. All these are already available here. Got it? So all the variables from superclass are available there just playing around with that, OK, if you go to the circle Um OK, so I'm just declaring a P some variable P, by the way, as a protector. OK, so if it is protected, it is available to subclasses. OK, so graphical circle is subclass so public is available in subclass private is not available in subclass public is available in subclass Default is available in subclass protector available in subclass. OK, so you can try it out. Just change this and see what is available in subclass just to learn that So graph circle. So that was an example here just to show you now, Uh so if you go to circle here, so yeah, you can change it and and and play it. OK, now OK, the OK, now this is another constructor with XY and R. I'm just calling the super and do that. OK, now do you see this thing? That's a comment. Now I think that's part of your next lab. If I'm not wrong at this point, you should be able to pick it up from what is in the lab. But I tell you what it is So when you write AC programme. You write a programme and you write a comment. Then you create a documentation somewhere else. Is it right? So in all the new languages and particularly Java came about it says, hang on. If you write your comment right in the code, so have you gone and see the Java A PS like what is API? What is API Applications Programmers interface. What are they? Sir, it is API Documentation is available here That Oracle is just a company which is hosting it. OK, so this application programmers interface You are We are the application developers. We are the application programmers and I want to use the packages Class is available in Java tomorrow. Maybe you buy some library from outside You want to use it? I want to find a square root. I don't care how it is implemented. So like a header file in C API S tells you what are the classes? What are the constructors? What are the methods? So on and so forth. So generally we simply go look at the API create instances and use them. So a P gives you documentation regarding the classes, the methods, what they do, what they don't do the whole thing. So Java has got so many classes, so many packages you can't even remember all of them. So I gave. I mean, I used to give this example. There are two kinds of knowledge. When you know C, you know the whole C. So like if you know it live in this area, you say Where is a mixed street or where is a kuji Bay road? So you know where it is. What is the postcode of Kingsford or Randwick or where Kra meta you know it? The other kind of knowledge is you know how to find the answer, but you don't know the answer. So what is the postcode of Fremantle in Western Australia? I don't know. But I can just do one search or whatever Australia post and and find you out. Java requires both kinds of knowledge. You need to know the core, which we talked about. But there are so many libraries. So you need to be able to go and go to the right library and see. Is there any class available? Does just do what I want to do. You do that through this API search or some documentation and then use it. We don't expect you guys so we won't give you a P in the in the exam because that's not something we expect you to remember. We expect you to remember the core of Java, of course, but otherwise you need to go and pick it up. Now you know how this documentation is created. It's not. Somebody sat down OK and created this documentation. OK, so you can just go define and use SQL from that. Ok, um there are so many. I mean, I don't spend time here because looking at it 4040 already OK, so when you go to the Java programme, if you write comment just before the method of the constructor in a particular format So I'm saying parameter of that. So that's a tag X. And what is that? Tells me here parameter Y is here so and so forth. This one tells me what this structure is about or what the method is about. And that's a particular format I can just use. Come on, Java, Doc provide java file. It will create API for me automatically. Do you understand that it will extract these comments and create a P form. It will say there is a constructor graphical circle with this and it will list what is XY whatever is like that. So the idea is that you write a method and before that you write comment in a particular format Java doc format. Therefore then you can use the Java Do command to then automatically create a P. You don't need to go and have a separate documentation file in the code file. It is all in one, so therefore it is in that format. OK, now here I'm not writing any comment because I want to display many things on the screen. But technically you would have comments everywhere. So again now if you're clear now, so that's additional method. I don't write area and circumference method here now equals is now slightly different. Now I want to compare to graphical circle. Are you with me? Let me see. OK, so Circle is comparing to circle instance, so this is slightly different. It says that whatever is given first, go to super means. Go to the circle class and use the equal method I define in the circle class. Are you with me that will make sure that what object is given is not null. That will make sure that if the board references are same, it is equal. It will return. That will also make sure both of this has got both of the instances are of the type graphical circle because, you know, get get class and we compare it. We don't compare circle to that. We say get class, get class Therefore so get class for this instance Will be graphical circle for the game should be graphical So everything is checked by the super all I need to check and also XY and R everything is checked. So now if I say if superclass returns false, I return false So when I come here, Super has already said True. That means XY and R are equal. All I need to check now is the other two values. OK, so here I'm only down casting that graphical circle. And I'm only comparing the other two because this looks after most of the thing. All everything at the circle level. Yeah. Any question. I'm sorry. Just aphonia Yeah is not available anywhere except that full stop Doesn't matter. Relationship still not available in subclass private is not even available in subclass, so private is private to that class. We will stop if you want to make it available in a subclass. Declare as a default are protected. Of course, public is available everywhere, so public is always true. But if you have a default or protected, that means it is available in the subclass and the difference between the two. I'm going to show later on. I have example. But now that you ask right now is that if it is protected, it is available also in a subclass in the other package. If it is default, it is only this is getting a bit more trickier. So I mean a bit involved. So we have to have the example. Then it's clear. Yes, it's gonna sound like and, um, we come to it. Be a good example of that. So So when when I'm teaching, I normally pick the basic concepts, and then we'll go through more detail, more detail, more detail. So what you're asking there's a whole slide for that, And the idea is that overriding a variable is a bad, bad practise. But we'll talk about Why? OK, but you Yeah. Anyway. OK, so now that's done. So that's a graphical circle. And see, this is the hazza one. So Hazza one is I'm creating this graphical circle. It has a circle and all I wanted to show you is area. So I do need to write the tab here when somebody asks the area. Then I simply go to C, call the area and method forward. So I forward the answer. That's called method forwarding. Because I'm not doing anything. I'm just calling the method of the another instance and forwarding the answer. I can modify if I want to, but I just do method forwarding this technically word called method forwarding. So I do need to write this stuff. But then I decide what I want to use and not use is a relationship is everything is available anyway. That's the difference. OK, you got it. So far, so good now and you can run it and see all the examples here The test circle has gotten. I'll come back later on. I have to introduce one more concept which I think we have to go next week there. But anyway, let me talk about that. So far, so good. So superclass subclass. Everything we talked about. OK, here, two string and everything. We don't need this, but we covered this both of them. Now there's a notion of abstract class. Later on, we'll talk about interfaces and this example which follows from here. We will give you this wonderful property called polymorphism, which most likely will cover in the next lecture. But let's start right now. OK, so what is an abstract class? So Java says you can declare a class and implement some of the method, but not all. Or don't implement anything if you want. So it is just a class with partial implementation or none. So because not all the methods are implemented, obviously I cannot create instance of an abstract class a youth me because I need on implementation of the methods. Otherwise, what's the point? Now you must be thinking, Well, what's the point then? Having abstract class there And the next concept after this which is more frequently used, is called interfaces. In interface, every method is not implemented. You just provide the signature, the header of the method. We don't implement anything, so you must be thinking, What's the point? I mean, you give me an interface which is just a type. Abstract class is also a type and you don't give me implementation. So what's the point? There's a tremendous value in that and this example will show you. OK, so what is the example now and again? All these example will just make it very clear to you. OK, now it says that abstract class must be There's a word. Abstract should be there when we declare and it should have at least one abstract method. We can't instantiate just read all the points. OK, if I read, it gets boring, so I covered all of them. But you should still go and read the slide. So now here is an example Shape is an abstract class and this is the definition of the shape class is the shape. Before that, I'm saying it's an abstract class. That means one or more methods are not implemented in this case. None of them is implemented and it is public, you see now step by step. Now I say there is a matter call area which returns double and it is abstract meaning Hey, I'm not going to give implementation of that. It is publicly available. So same thing. Two methods here. Got it. Now what I say circle is a subclass of shape. Got it. The circle is as we define, so I don't need to go through that. OK, so that is what we discuss. And it implements both this method area and circumference. Both are implemented in circle so I can create whenever, at whatever level all the methods are implemented. We can create instance of that so I can create instance of circle is right make sense. Next slide Exactly the same with rectangle. Now rectangle is also accent shape. Now remember, both these methods make sense. I can find area of rectangle circum for rectangle of triangle of Pentagon, of circle. So these methods make sense to any shape. Therefore, we are put in the shape. However, when I have rectangle, I also have a variable and everything constructor. It has area method. But you see here the implementation of area is different. That's for rectangle. Circumference is different. That's for circumference. Do you understand now? So the way I calculate area of a circle is different to the one I use for rectangle. Are you with me? Tomorrow it will be triangle Poly Whatever. Like that Are you with me? But the signature is the same. The name of the method returns double. That's exactly the same. You got it Now if I create an instance of circle, I can treat that as a shape is right. Yes or no? If I create instance of a rectangle, I can treat that in a circle. Right? Wrong. Yes or no? So look at the example Now here This is where you see the advantage. I create a circle and treat that as a shape. I create an array for the shapes. Now anything of circle can be treated as a shape. Is it right? So, II I save it as a shape zero shape the shape one is a rectangle Shape two is a rectangle Shape three is a graphical circle, not even circle Because graphical circle is a circle which is also subclass of shape Are you with me now on my canvas I have created a rectangle circle graphical circle with me I need only one loop and I say go through that shapes length Go through that and call the area now. When I'm calling area for this, it is going to execute the circle area for the next one area is coming from here. Do you understand that? So the meaning of area is different depending on where the object was created. Are you with me? In a Greek poly means multiple. This is called Polymorphism. You have got multiple behaviour of area method here and it is because of dynamic, binding dynamic means at the run time. When I create an object, I bind the behaviour of area. So the behaviour in this case method area is attached to that instance dynamically at run time. So dynamic binding results in polymorphism All these buzzwords But it's a tremendous property Can you see now? So at this level I treat everything as a shape. Now each of them may have more property But I'm only interested in something which is common across all of them. You got it? I think we better stop here. I'll see you on Tuesday and I better stop recording this. I understand there was some issue with recording, so we have recorded on teams and we make it available to you. You go back there. So, Abraham, we will talk about the, uh there that later on. But good practise about the variable of what?

SPEAKER 1
I want to ask you a question. Yes, but do Hi NN I I think like that

SPEAKER 0
your friend is here on the
