SPEAKER 0
OK, I think I better say hello to you first. So, uh, my name is Helen. Um, I couldn't be here last week, so Dylan, fill us in. Um, from this week onwards, it will be mostly myself and another professor who's working on Blockchain. Um, Salil is going to be delivering lectures. Mainly when you met the tutors, Um, Dylan might come in, um, every now and then throughout the term. Uh, he may also do some project when it, um, mentoring and marking. We haven't discussed that yet, but, um, Dylan still will be around. Um, he actually told me that Monday, Um, he couldn't go through all the, um the contract smart contract testing, um, topic on Monday, But the rest of the slides, he's going to release a recording. Um, later this week. Next Monday. It's actually a public holiday. So we were going to release some pre-recorded guest lecture video. Anyway, um, So Dylan was saying maybe we could just release the recording of the rest of the topic on Monday. Um, as video for Monday. Yeah, So we'll just continue on, um, today, Um, the topic is basically going through the basics of ideas of software architecture? Yeah, I think for CS C students software, architecture or designing, Um, aspect of software architecture. Isn't something a topic that, um, come across, uh, often? Probably this. Maybe some of the software engineering students who was doing software engineering. Um, Special stream. Might have heard of it or might have experienced designing software architecture a little bit, but it's a topic that is not often taught at CS E. So we just go through some basic concepts because this really sets the context for the rest of this course in a way. Right? Because we are approaching this Blockchain application pretty much from software architecture design point of view, right? It's not just building a Blockchain system, but how do you use the Blockchain as a one component of a bigger, um, system? Right. What sort of roles Blockchain can play if you want to plug in this Blockchain properties, right? Is the proper the system? Uh, Blockchain can provide into your system and how you might do it. Well, what do you lose? What do you gain by doing so? Yeah. So, to understand that bit, we need to understand what we mean by software architecture and designing a system through software architecture viewpoint. So it's really just about setting the context, this lecture, Um, so we'll go through briefly about software design process, especially from the architectural point of view. Um, obviously, any design process requires us to think about how to collect requirements, what sort of requirements are collected, Um, and then the basics of sort of terminology, right? With some some sort of basic terms that we always use when we talk about software, architecture, um, and some analysis techniques, Right? Um, today I'm not sure how much again we will go through. I think the slides many, but we release the lecture notes. It's got the speaker notes part of it. So I find it quite detailed enough You could sort of read through a lot of them. Anyway, I may not do this analysis method because I find that probably it's not something that we will practise a lot. Um, in the course, um, we may actually do a lot more sort of light handed, um, approach Anyway, so we'll see. We just want to get to the idea of producing alternative design and then being able to compare one design over the other according to some criteria, right? So there's some, uh, a thought about analysis and why you might want to do analysis. That's the main message. The actual sort of detailed technical methodology we may not get into, Um, if you don't have time, right, So let's see. So software design process. Um, as I was just mentioning the context of this discussion, this design process isn't really about, say, designing an app, right? I mean, so we are more familiar with, say, writing a few function module to to build some, um, simple system that do something on your computer. Right? So you may start developing from, um, designing a UI or something, right? What sort of system do I build right that I can run here? We are really looking at a bit far away from that sort of single system view and have a view of a larger system that has a lot of moving parts. Yeah, so it's a bigger scale system, how you might start designing thinking about building a system like that so it's more what we call a system architecture. It's a high level overview of how different moving parts of a system work together, right to achieve certain goals that you might have. So here we're not talking about designing, um, functions or modules or designing an algorithm. Particular algorithm here we were really talking about designing a, um, a bigger system as a whole, right? I think that the notes talk about building a house. Right. So here, this building, talking about, uh, building a house in a sense that you know, where should how many bedrooms should I have? Where should they go? Where should the bathroom be and things like that. So that level of design? Yeah, but regardless of, um, the scope of the software design process. First we start with a set of goals, right? And why you are building this system, and what sort of system do you want to build? And that set of goals gives you, um, three subset of, um, input to the design process. One is requirements, right? What do you want to build? What? What should the system do? Another one that we are going to focus on a lot is what we said. Architectural constraints. Basically, this is another set of requirements that is not particularly about what the system should do. But, um, sort of other aspects of the system that you still want to, um, build into the system like how fast the system should run, How secure the system should be right or some other constraint could be that my client doesn't want anything on the cloud. Right. So my solution should not include any, um, should not include any cloud discussion or something like that. So constraints basically another set of requirements that you need to consider that may not be directly related to your functional side of the system, OK, and then you may have some creative ideas about what you want to actually use or what you want to build into the system. Right? So these are set of, um, input to your design process. And then you start designing this architecture, um, model software, architecture, design when the output of the design, um generally is basically a diagram right again, something that I don't see a lot of, um, students do for computer science students in our school. So you designing artefact is obviously diagrams containing maybe boxes and arrows, right? And some notation of what those boxes and arrows mean, it may actually add some, um, include some comments about what this design actually is representing some assumptions and things like that. So So it's basically documents, right? More designing documents. So you will produce those artefacts as part of your design process. And the idea is that you don't just produce one design. You produce this, you produce many design, many alternative design, right? Because this set of input, um, may lead to many different options, right? You may want to think about basically drafting ideas, right? And then there will be set of criteria that you will evaluate the design on and then decide. Uh, what? Which design you want to choose. And that process, of course, may involve going back and forth right refining. But in the end, you choose your design, and from may you do implementation. Yeah, Typically, we do this design and evaluation process before implementation. Because why why do we do that? You think, don't you want to just drop some from something and just go in and build start building something? Why do you go through like this? Tedious documentation and things like that. Analysis and documentation generating lots of documentation and comparing and all of that. Why would you do that? Because implementation is, um is expensive. Yeah, it's actually quite expensive and costly exercise. So you may want to do some paper based exercise first, right? Which tend to be less costly. But then you can perfect your idea and design, um, through this before you actually commit to an implementation. Right? So this is actually quite, um, common process in any design, but particularly so when you are building a big system. So as I was saying, the common approach is really to go through that refined design evaluation process before you commit to an implementation. So obviously, in our course, we're talking about using Blockchain as part of the architectural solution. So to be able to do that, um, first, we need to kind of understand what sort of role in this whole design process what sort of role Blockchain will play in your system. Yeah. And typically we say Blockchain can play four key roles. Um, one obvious one. I don't know whether you thought about this when you, uh, last week or all through up to this topic. Uh, when we when we discuss this Blockchain and what it can do or what it is for. Um, isn't it just the database, right? Isn't Blockchain just a database? Well, in a way, it is. Right. So in your architecture, Blockchain can play Certainly something like a database role, right? It stores data for you. It's a data store, but I guess it's a data store with particular properties, right, Because it's not just relational database. If you consider Blockchain as your database, then being a Blockchain will give you some certain properties, right? But it plays overall as a data store. So that's the role it plays. Yeah, it could also be a computational platform because of the smart contract. Right, So you can do some computation on it. I think I forgot to bring my drink. I normally, um, have a drink with me. I think I need to get something later so it could be a computational platform. Um, because it's got small contracts so you can run some, um, computation on it. Right. So it's a purely you can. You can think of it as a, um, component in your system that does some computation for you, right? But obviously, because it's a Blockchain. Even the computation element comes with certain properties. Right. You can you can verify. You know exactly what happened. It leaves the trails and everything, right? So it's a computation element with Blockchain properties again. It could also be some communication mechanism or communication platform. What we mean by that? It's sort of, um, shared data, um, writing and reading platform where someone, um so wants to send a message to you. That sender leaves a message on the Blockchain, and the receiver reads that message from the Blockchain. Right. So in that sense, it's a common message. Um, exchange platform rec communication platform. So you can use Blockchain for that role. Yeah, or it's a combination of storage and, um, computation element. It could also be asset management access control, Basically a access control, um, platform, um, component as well. Yeah, you can define the assets that you want to control the access for, And then something like smart contract can, um, execute logic that will give access to certain asset to certain people. Yeah, so we normally say I'm sure you can define other roles, but mainly we say four key roles of Blockchain, um, in a typical sort of architectural solution Sense. So when you build, um, a system a large system involving Blockchain Typically, you will have, um, a diagram like this in the end, right? If, uh, someone ask you to draw a layer architecture of your application that involves Blockchain, you may end up drawing something like this. Yeah, So at the top, there are applications that are running communicating with this data layer, if you like the back end right through some sort of API the back end, there's a Blockchain. And there might be some off chain data source that stores big data. But Blockchain, um could have, um you know, the leisure part that stores data it could You could have some. The token management element. You could have smart contract. So this will be a backend component of your whole system. Yeah. So one key, uh, message that we want to say in this topic when we talk about this Blockchain in a software architecture context is that Blockchain really is a one component in a big system, right? And when you plug in Blockchain into this system, you kind of have to design or decide what sort of role. Why? You are basically plugging Blockchain into the system, right? What is the reason? What sort of role do you want your Blockchain to play? Yeah, OK, so in architecture, when you decide how sort of what sort of moving parts in your system and how they are sort of layered or connected together, they might. As I was saying, software design, architecture design could have many, um, options. Right? And each option, um, would come with some sort of impact on your performance availability, security, etcetera. Right. So when you design when you decide, um, how you might structure these components in your architecture, that decision will have impact on, um, you know, what sort of performance am I going to get out of this? This, um, set up that I get What sort of privacy protection can I actually do under this, um, system design, etcetera. Right. So that decision will make, um, what kind of allow you to either gain some positive properties or lose some positive properties? Right. You can't have all of them. Yeah, Um, probably we talked about this in first lecture or the second lecture that, um, in any distributed system um, this cap theorem says you can only you can't have all three. You can't satisfy all three. You can only have two out of three, right? That sort of typical idea in software, architecture design. Um, so this that's one example of how you have to sort of trade off. You may gain some, but you will lose some, um or something That is kind of, um contradictory, right? Like, uh, transparency and privacy, you might say, using Blockchain you are, You are You're gaining transparency because everything is on the Blockchain. But then what you might lose is the privacy, right? So there are some properties that, um, you need to carefully think about when you are designing or plugging something. Certain modules in your in your system design? Yeah, and that how that leads to trade off. OK, I think that's probably the main thing here with architectural, um, design decisions lead to either gaining some properties, the good properties or losing some properties. There's always trade off. OK, um, so we said obviously, any design, um, process. You start with thinking about the requirements and gathering requirements, right? Probably You have thought, um, heard about this in, uh, maybe we we're talking about in the later slides. So basically, requirements are specification that describe what the system should do, right? That's how we understand the requirements should be. It's like your assignment specification. That's sort of for you. It's a It's a requirement, right? So it defines functionality of the system and other aspects sort of what we call nonfunctional, sort of not other aspects of the system that is not directly related to function of the system, like performance or constraints of the system. Right. So you may define all of that in the requirement document. This actually has quite good example of different levels of abstraction. So in the requirement, you may So in one requirement document, it may all be about just specifying technical, um, requirement, technical level, uh, requirement, for example, what debits should do, Right. So this is just describing how transaction should work. Yeah, but if you're describing that transaction at the business level, you should say that, uh, that accounting system should enforce accounting standards, right? So that's not, um, about how debits are implemented, right? It's more about whatever implementation that you have should, um, meet the standard or the regulation of you know, these accounting standards. That's sort of business level requirements as opposed to technical level requirement. So there are different levels of, um, abstraction when it comes to requirements. And sort of probably we all understand how requirements are or setting it as a good documentation at the start is important for lots of reasons. Right? Um, improved communication among stakeholders speed up the development, reducing costs, enno in quality, etcetera. But probably something like this is something that you would have to experience. Um, later on, when you're actually doing in a project in in involved in a project, um, documenting everything and things like that, how important it is, how practical, um, thing to have it done. Right. Um, the benefit of it, probably you instead of me telling you with this slide, maybe it's something that you will have to learn or you will get to learn, right? Uh, from your practical experience. So when it comes to requirements, there are actually two, important distinctions that we make. And this is actually another main context that we want to introduce in the lecture, functional requirements and nonfunctional requirements. I was kind of saying, Up to now there is a requirement that is directly related to the function of the system. How what the system should do. And then there are sort of other systems requirement that are not directly related to how the function should, uh, how the system should function, but sort of other concerns, right? Um, but you still want to build into the system, so we call it functional or nonfunctional requirements. Here, Functional requirements is simple. They described as a systems relationship between input and input and output and internal states. I mean, if you just remove this system and replace it with a function, that's exactly what function should do, right? That's how we describe function. Function gets an input. There's an internal state and there's an output. Right? So here we really just looking at that same concept at a system level. So here, functional requirement is really just about describing what the system should do right, given given input and everything else just becomes nonfunctional requirements. Yeah, and normally we call it either nonfunctional requirement or software quality. Yeah, so something that is not directly related to the function of the software we call it. Software quality? Yeah, properties, software, quality properties. And there are a lot of elites. Yeah, as you will see, like usability, reliability, modifiable availability, confidentiality. You get the idea, right? That's called, um, software quality software quality properties. Yeah. Um, and these describe how system behave in other ways than the functional. Yeah, like, uh, the speed or how user friendly it is and things like that. Yeah. And typical way to express nonfunctional requirement is something like that. Right? Accounting system needs to process 250 transactions per second, blah, blah, blah. Right. So this isn't about, uh, what accounting system should do. It's about how we should behave in terms of its performance. Yeah, and there are many, many other quality metrics that people care about when they build big systems. Because of that, um, there is an international standard that has many, many software quality properties, defined as a standard metric that, if any, um, sort of serious software company producing products. Um, they will go through these standards and try to get their measurement done according to all these criteria and get a certificate. Right? So these are quality measurement model. Um, as you can see there's a lot of right, um functional suitability, performance compatibility, usability, et cetera. Yeah, and we will go. And each of them in each criteria. There are some sub criteria that really sort of clarifies what? That, um, high level criteria actually means right? For example, reliability. If you want to be able to say this software is highly reliable, you should be able to say, How available is it? How recoverable is it? How mature is it? How fault tolerance is it, Right. So these are the questions you might ask to say whether the system is reliable or not. So there are lots of matrix like that. Metrics like that. Um, in the course, I think later on, we don't go through all of them. But mainly, um, a few, I think functional performance and security. Maybe three or four. We choose. And we try to sort of analyse this, um, from Blockchain point of view. Yeah. So why nonfunctional properties matter? As I was saying, this nonfunctional property is one of the main context that we want to sort of set in the course. Yeah, if you think about what nonfunctional properties actually allow you to do so. It's actually it's not just this software system concept, right? Functional and nonfunctional. In a way, if you think of any service or situation where you have lots of services, then you need to choose one, right? That that that meets your need, Say, a plumber. Right. There are many plumbers around you. They all do the same thing, right? They will come and fix your tech. So from functional point of view, they do the same. So what are the qualities do you look at to choose which plumber, right? The same in software you probably have a look at in terms besides the. Besides just the functional, um, capability or competency. You will look at pricing right, for example, Or you will look at how easy is it to contact the plumber? How easy was it to have a communication with the plumber, right. Was it friendly? Was it on time? There are many other qualities you will look at. Besides the actual fixing of the of the issue. Yeah, So that, um, nonfunctional properties is really getting it right. Makes your software, um, practically use useful and usable and make it I guess a bit more. Um, what is it applicable to a lot of customers, right? Applicable to a lot of customers satis in terms of satisfying, um, different customers. And having this nonfunctional property set in mind when you build your system allows you to think about all the other sort of regulatory requirements as well, because regulatory requirement will be mainly nonfunctional, like privacy requirement or, you know, anti money laundering requirement. All this digital currency regulation that might come around they're not functional requirement. They're mainly nonfunctional requirements, but nonetheless, something that you have to build into your system. Right. So having this nonfunctional property mindset obviously allow you to have think through this this, uh, regulatory requirements and make sure that your system satisfy them as well. And, you know, just making it system building a better system, basically, um, So out of all these sort of some might be competing, you know, you either if you lose this, uh, if you gain this, you're losing the other and things like that. So these are not sort of equally, um, achievable qualities. So you may have a a spider diagram like that for each design, right, and each design may have a stronger and weaker point. Um, according to the qualities that you're looking at and you basically choose one, choose the best one we actually hang on. Um, I forgot to tell you this, right. Um, because all this kind of relevant to what you need to do, um, we actually haven't released that. Right? I noticed that we haven't released it. Oh, sure. I need to login, huh? Because it's not my computer. Uh, do I know the password to hear? Hopefully, that's the one. Um, yeah, we haven't released it, Huh? So I think No, maybe, Yeah, I'll I'll release it after the lecture. But the I'm sure Dylan would have talked to you about the group project that we have, Um, in the course, Um, we actually haven't. Looks like we haven't, um, released the specification. If you like for the group project, I'll make sure that I do it, um, at the end of this lecture, or, you know, during the break or whatever, but basically, this group project will go through this process of design. Yeah, all the way up to implementation. But initially, the task will be that you will think through this software, architecture, basic quality issues and, um, describe your requirements and things like that. Yeah. So that's why we are talking about, um, sort of this basic sort of designing process now, right? So that you could use some of it in your group project. Um, from day one. Yeah. So you would have to document your requirements. Yeah, because in a way, no one no one. This project is kind of self set, right? You have to propose your own, um, idea for the project. So you come up with your own requirements. It's not like I'm giving you the requirements, and you're sort of, um, writing them down. So you do have to think of your own requirements, but you document them Well, yeah. So that's the exercise. So obviously, we want your requirements to be very specific, detailed and complete, clear and concise is probably important. Um, want to get it right. So we can understand what you mean. Um, And stating assumption is probably something that is important for you to do. Like what? When you are, um, writing this sort of requirements down. What is the sort of operational environment assumption you're making right? Like something is available. Something is not available or things like that. Um, good example like this. This is a functional requirement. Um, description of consent. Say the system should allow the data request, uh, to request consent to access data from the data owner. So that's functional requirement. Nonfunctional requirement number. It like that. Um, confidentiality, um must ensure that the data accessible only to authorised parties per approval and consent. So what is your definition of confidentiality in the concept of your system, for example, so you sort of do want to do something like that in your documenting or requirement. OK, so we said we want to go through some basic terminology of software architecture. Um, so, software architecture basically is a blueprint. Um, overall design of a software system, including So these are what What? When one talks about software architecture design, right. You would find three top level concept one, what you call components elements. Or mainly we call it components. Right? These are all these sort of boxes or the objects, right? The blocks that you see in your software design, architecture, design. Those are something that we would normally refer to as components. It's some functional unit that does something right here, like a Web server, right? Or an application, server or database. But as you can see, when we think about software architecture, what we call component is actually quite big, right? We're calling a Web server a single component, right? Not certain some other functions within a Web server. I guess we could do that. We could have a lot software, architecture, design, that. Just describing how Web Server is designed. Right. But in this bigger scale system, each component itself is quite big. Right. So here, a load balancer is one component we see. Or data storage of a cloud data storage unit is one component that we see. Yeah, but in a in any way, you'll see, um, components as one obvious high level, um, elements in a software architecture. And then you'll see, um, connectors connections between those components. I mean, if you think about it, components themselves are not going to operate, um, on its own right. It has to actually communicate with something so that you can operate within the big system as, uh, as one thing. So you will see lots of arrows connecting them, right? How load Balancer is talking to Web server, right? How Web Server is talking to application server. How? Application server is talking to a database, for example, so you'll see connections. And this connection should have to make sense, right? You wouldn't see, Say, for example, a web server talking to a database directly and you will take typically be able to sort of see layers. Yeah, so this is one layer Web server layer application. Layer the data layer, for example. Yeah, So, as you can see when we say blueprint, um, at one, view view of this diagram, you can sort of see how this big system right is composed, Basically, what's in it, how they're connected. And, um, how they're placed. Yeah, to to work as a as a single system. So that's, um, a typical software architecture design. Yeah. Another third component that you'll see is how these connections and components are placed in, um, physical, uh, deployment environment. Yeah, in a way, that how they are placed so well, I guess we just talked about that. So here, load balancer. Here at this level, uh, web server talking to another load uh, this is elastic load balancer. Another load balancer application server. Um, in database is a, um, cloud offline. Um, outside of this environment, this grey environment here, right, And this storage is outside of that boundary, et cetera. So you'll see, um, how these components and connections are placed in a physical, um, hardware setting. Yeah. What sort of deployment environment? Um, it will. It will have. And we call this configuration right How these components and connections are configured into a structure. Uh, topology. So when we say here, configuration is basically what we mean is topology how they're structured and placed not, um, configuration. In a sense that, you know, open a software you go to configuration, you have to type in some, you know, port number or whatever. Not that sort of configuration. Not the sort of system configuration you're talking about. How these components and connections are structured. Yeah. One configuration is opposed to, I don't know, different configuration. That or not having it, for example, right. Could be another configuration. So here configuration has particular meaning. Topology is what we mean. Uh, and this one, if you look at a design software, architecture, design, um, besides these components and connections and placement, um, you can sort of see the the underlying intention of this design. What is the main focus? Um, area of this design looks like in here looking at the load balancing here and here and the fact that it's got the scaling auto scaling as one of the main sort of placement of these components, it looks like it's really going for scalability or availability, right? He wants to have auto scaling and lots of redundancy, right? Redundant data application servers and Web service etcetera, um, configured in the system so that the system is highly scalable and highly available, right, so it can handle a lot of load. So it looks like that's the main sort of design focus of this architecture. So you can tell something like that from a particular design. So this sort of design architecture design is basically an abstraction. We're really looking at a high level, right, hiding a lot of details. So it's basically a model that abstraction is basically a model, right? My that we want to model this problem or we want to model this, um, area. That's that's basically what we mean, we want to abstract the sort of detail out. Um, you know a lot of details and have a simplified view of the problem, right? So architecture is ba architecture. Design is basically that you want to creating an abstraction of the system you want to build. Yeah. So it has complexity, um, which simplifies things that enhances communication. So you can talk to people who are not, um, Tech too technically savvy. Right? And you can still have meaningful conversation with those people about what the system is capable of doing or not capable of doing. Um, because of certain ways is is designed. Yeah. Um, yeah. So But it says the instructions are basically models and models. What kind of models you build. So what kind of design you come up with? It really depends on what is the purpose of the design. And that's why, given set of input to the design process, um, you can come up with many different options. Yeah. What, you want to focus on what you want to model? So, as I was saying here, nonfunctional properties, um, so architectural design, I probably will put it a little bit differently, right? this architectural design choices. So architectural design decisions that you make, um, that will determine what sort of functional, pro nonfunctional properties you may gain or you may lose. Yeah, so you choose, uh, create multiple design and choose the one that really satisfy the most nonfunctional property you want to satisfy. So here is an example of, say, three different options of building a system that has a back end looks like. So that's a typical presentation application layer at the top, and you could have one single database that is one architectural design, right choice. Um, simple. But the problem is, it could be that that's one point of single point of failure, right? Having just 11 database. So plus side could be that it is simple to build, simple, to understand, simple, to maintain, et cetera. But there's also, um, maybe it's not as performing right. Maybe you can't handle much load and single point of failure so you can scale this out to multiple backend database. But then, yeah, this may give you availability, higher availability, scalability, et cetera, But there's also, um, downside of having to manage these two right? Synchronise this two, which isn't really easy. Um, problem. Right? So you can ignore all of that and go to Blockchain. Right? But then again, using Blockchain as a data storage, um, has really great availability. But then it has downside of we talked about that Blockchain problem, right? It doesn't scale the if you want high throughput system in the back end, Blockchain probably isn't a good option for now, right until some other person come up with a great solution for scaling Blockchain transactions so functionally that will be the same. There will be three layer system with the database back end. But what sort of database? Um, architectural choices you have, um you have different trade off. Yeah. So if you want to design, um, your own architecture from scratch and probably I don't know whether in the project I forget in the in the specification what we were asked to do, Uh, maybe initially, you have to do it from scratch, and later on, you have to use a pattern. I'm talking about this because later, um, in the coming weeks, we are going to talk about another sort of main, um, topic in the course, which is a pattern a design pattern right design pattern is probably something that you are familiar with. If you have done some object oriented programming course, I'm sure you have done a lot of object oriented paradigm design patterns that comes with that et cetera. Here, software, architecture design. Similar. There's a bit of, um, collection of patterns that you could use to, um, start designing your system, right, rather than doing it from scratch Also, you mean of course, you can do it from scratch, right? And you may actually find some creative solutions that nobody has thought of, uh, by doing so. But, um, you not You may not be sort of sure whether what you have designed is actually, you know, correct or something that other people might consider as as elegant or nice. Nice design, right? So, um, there are collection of, um what we call patterns that are available as a generic solution to lots of problems. So one of the sort of strategy is that identify which patterns is suitable for your problem. Apply the pattern to your problem. You may have to adjust a bit to fit your problem better, but that's another, um, available option either doing it from scratch or applying a pattern. Applying a pattern. I guess it means you have to sort of understand and learn the patterns right. And that's what we will talk about in the coming weeks as well. Um, this one not so sure whether it's really necessary in a way, because patterns are the most sort of important concept. Um, in the course, I mean practically, you want to sort of learn what the patterns are for and then apply the patterns to your problem. But if you sort of read some references or books on sort of architecture, some people try to make a distinction between what you call architectural style and architectural pattern. Right? Basically, architectural style is a It's like a you know, any design or any architect. For example, you know every architect like the building architect, not not necessarily a software architect. I don't know who actually makes more money, probably a software architect who makes more money than building architect. I have no idea. But, um, you know, just think of the the famous building architect, um, and how each architect has different style, right? You can immediately recognise Ah, that's by whom? Or that's by that person, et cetera. Right, some famous architect. I'm sure you'll you'll you'll recognise their, um, style. That's why exactly what we mean by style, right? Um, it's basically a set of principles and guidelines. That sort of gives a unique, um, style really of the design, right? If it really comes down to an example, you know, Web or client server architecture is a probably one of the most commonly known architectural style. You design something as a client server architecture style. Um, if you do that when it comes to pattern, right, so architecture style is basically a bit bigger idea set of styles and a set of principles and guidelines. That sort of gives you the unique, um, identity of the architecture design, Um, method if you like. Um, in each style, you may have a, um, collection of patterns, right. This collection of patterns are not unique to a style right. It could be applied to many different styles, but, um, they are more specifically focused on a particular problem, right? That's what basic design pattern is, right Design pattern is there to solve a particular problem. There's a commonly occurring problem. You design a, um, pattern solution to solve that common problem so that the problem pattern can be applied, um, widely. And that's basically what the pattern pattern is. Design pattern is so architectural pattern is the same. The design pattern, uh, for an architecture design, is there to solve a specific problem rather than providing a style guide. Yeah. So if you say a client server is a architectural style, um, a pattern that might belong to that client or pattern that will give you a typically a client server. Architecture style is a three tier design or NBC, right? I'm sure you've heard of NBC if you've done any Web application, um, development. NBC is a very, um, famous design pattern, right? So try to make a distinction between what's a style and what's a pattern. Um, but probably for our cause for practical um, purpose. I say architectural patterns are probably more important, and we'll probably use that term more than the style. Similarly, we talked about how architectural design we could have many different options and this idea of views and viewpoints again, the term a particular term. Viewpoints and views, um, they're trying to um, kind of, I guess. Yeah. You can have many different options then in in those option Maybe you can consider particular, um, view right. One design option could be about des describing this sort of view. Another design could be about describing that sort of view. Right. So sort of try to give you a bit more, um, concrete guideline as to what sort of design option you might generate. Yeah. So it's similar to just try to sort of give an analogy where, uh, you can look at the human body system, um, skeleton, sort of circulatory thing. And the muscle. Right. So all describing human body, but different views? Yeah. And you can choose a particular out of all the views available. You can choose a particular viewpoint as your perspective. And that gives you a particular guideline about that viewpoint, um, that you could use to generate the design. Uh, software design, architecture design. I mean, so getting to that, um, more concretely speaking, there are, uh Well, this is one a person's suggestion as to what sort of views might be useful in software, architecture, design. And there's suggestion of, um describing an architecture design from logical viewpoint, process viewpoint, physical viewpoint or development viewpoint. Yeah, so that's four. And if you could actually use a scenario to describe how your design works, that's plus one. Yeah, so that's four different views, plus one. That's why it's called four plus one view model. Um, logical view is basically, um, significant components. Remember, we talked about components right in the system and their relationship. So that's I say, probably something like this is logical view. You could sort of do that right, describing just the components and their and their relationship. The process view is, um, actually, if you if that's too, if this is too high level, logical view could be something like, How would you describe a logical view In a typical software design class diagram? You've done class diagram before UML. Yeah, typical logical view, right? Um, process View is focusing on describing dynamic behaviour. How the system flows, right, how the system is controlled. So you have many components. But how do they actually work together? So that's describing the dynamic behaviour, the flow of the of the system, right? Like, um, state diagram or flow chart. That sort of diagram will be process view. Yeah, Um, physical view is basically how the comp the similar to this right? How they are sort of mapped on to, um, physical environment de deployment environment. Um, and there's a development view, which is for, um, software components. I guess it's more, more concrete view of logical view how this logical view are then translated into more programming. Programmer, programmer, friendly. Um, expression. Right. Um, documents. So these are for more software developers? These are, I guess, more higher level abstract. Um, that will be easier for communication with non technical people. Um, process view again is different to logical view, Really describing the dynamic behaviour and the flow of the system. And that's the the physical configuration. Right? How these components actually placed, um onto the hardware or de deployment environment. Yeah. OK, let's have a Oh, no, actually, because sort of finished with this one, So that's probably UML is the Did we say we are going to use UML in early on in the lecture? No. OK, but how many of you actually know UML done UML A lot of software engineering students were not that many. Um what sort of modelling language. You be familiar Way. You've done database database courses with the EL diagram. Yeah, OK, if you have done the L diagram, you know what modelling is, right? UML is just another language that allows you to do the same. So if you done EL diagram, you could do the same sort of logical sort of EL entity relationship type diagram using UML language, right? Same concept, different language, basically right. And UML has more sort of diverse collection of, um, notations that you could use. So, for example, here instead of say, um, non standard flow chart type, um, diagram EML has what you call state chart. Yeah, that allows you to describe the the work of the the flow of, um, the system using bit more standardised notation than, say, I don't know what you might find in the simple draw. Um, software? Yeah. Um, it has class diagram. It has, um, use case diagram. And it basically it's a different set of languages. Notations that you could use to describe these sort of different views. Yeah, an idea. Basically, the different ideas. Um, we may actually have a OK, I'll make a mental note about this UML notation If you know about UML rotation already, that's fine. Um, but maybe we will do a quick tutorial type of UML during the lecture. Um, later on. Right. So you can actually use it in your project because the idea is really that, um you can use some sort of modelling language, right? And UML is quite standard, um, to draw sort of different view, different ideas about your system. Yeah. OK, let's have a break. And then we come back to finish. We may. Let's have because I think I need to go and get some bottle of water. So this is 201 maybe 10 minutes too long. Yeah. Can I get it in five minutes? Maybe five minutes Break? Yeah, because we we don't have that many left. So five minutes break. So did it. 207. Yeah. I'll be back by 207. And I will go and get some water.

SPEAKER 1
Yeah, And I who can send it to the guy. Bye.

SPEAKER 2
I I that Yeah, OK.

SPEAKER 0
Gosh, You're so cold. So cold.

SPEAKER 2
Ok, how to how to set this work?

SPEAKER 0
You don't see them? Ok, uh OK, uh, so back to software architecture elements. So the basic terminology when we're talking about software, architecture, design and we already said there are three obvious high level ones that you should recognise in any architecture, design or, uh, components. And here, when we talk about software, architecture, design, the components are a little bit bigger scope right than what we normally think of our component, um, connectors between components and the configuration, the placement of the structure of those components and connectors, right? We call topology. So that what we call configuration connectors and components yeah, so software components, Um, again, there's a little bit more about what software components are fundamental, fundamental building blocks. Um, so here is called the architectural entity, right? So encapsulates a subset of system functionality. So that's why we say it's a little bit bigger scope than what you would normally think of as a component in your software. Yeah, like a Web server or database. Just all of them be abstracted out and say components. Right here is a Web server component. Here is a database component. At this moment, we don't really care exactly what database is. It could be relational. It could be you know, just data store online in the cloud. That doesn't really matter. Just a a database component or data store component. Right? For example. So that's a bit high level abstraction of, um, some subset of functionality that is quite important in the building block of of in in the building blocks of the software architecture design. Yeah, but what, um, what makes also software component is that you could restrict access to that subset by, uh, um, defined interfaces And probably most components. Are those through those interfaces you you connect with other components? Yeah. So there's, um I don't know What's the probably I don't know where you would learn this. The sort of idea of interface. Yeah. Um, so there's an internal implementation, and there's, um, an interface that you communicate with others and that others could be other components. Right. And through that interface, you can do all sorts of restrictions or, um, management of the the component connection with the communication with other components. Um, another thing about component is that you You have to have a clear execution context, right? Where is your database gonna run, right? Where is your web server? Gonna run. Yeah. Where is it placed? So that becomes part of the configuration requirement. Right? Um, as we all know is, if you say something is a component, it's supposed to be modular and self contained. Um, reusable. You can sort of place them anywhere in your architecture That is suitable. Um, components typically provide application-specific services. Yeah, um, so you you put the database component in your software architecture design that is supposed to be in a particular doing, uh, operating in a particular application context. Then the data like banking application, right? Database in the banking application, uh, will provide a particular services suitable for that for that application. So in that context, again, you think about Blockchain, right? What sort of If you're using Blockchain as a component of your architecture, Um, what is the application specific services that it provides? And what sort of role does it play as a component? Yeah, And then there's connector. Um, and I was saying is basically components themselves, they might be self contained, but, you know, they they really need to be connected with other components so that the whole system can work as a whole. So connectors are basically that right? It, um it integrates multiple components and those building blocks of components. Um, they are connected and functional as a big, um, unit in a system through these connectors. Right. So they're like a glue that enables components to work together. Um, probably something like rather than that. So these are particularly how connectors will enable communication reconnection. But I think these are probably more, um, concrete and more understandable in terms of what connectors actually do. So, uh, transferring a file like FTP could be a connector component where connectors, um, you may able to stream is a connector. Simple things like remote procedure code connect the concept. Shared database again. This is a connector too, right? Connector, in a sense that, um, these components can share information through this. Yeah, so that's a way to connecting these three applications. The three components, um, you may know something like message plus and message Q idea where, um, components can be directly communicating with message bus. Right. And Blockchain is also going to be, um, connectors. Yeah, and we'll see exactly what sort of connecting facilities Blockchain can provide. Uh, in the later topics. Yeah. So we think of Blockchain as components right in the system. Like storage component or what was it computational component, things like that. But also as a connector. Yeah. So that's gonna be, uh, when you are designing your own Blockchain, uh, project for the course. That's something that again you will think about right Blockchain as a connector Blockchain as a component in your design. S. So that's connector and components and the configuration. Yeah. Again, um, configuration is basically the state structure, right? How this, uh, component and and connectors are placed together so you can see these two options, right? There's a browser component, application, server and database. This just connecting them like this in a linear fashion. That's one configuration, right? You're placing these three components in one line? Um, browser talks to application server application talks to database. Yeah, that's a configuration. Um, another configuration. Is this right? You got extra component called load balancer. Right. Um, which can, um, route distribute request to more than one application sable. And you may have more than one databases. Yeah, um, starting from the browser. So connection could be like this load server to application application server to back databases. Yeah. So that's again another configuration structure. Right? How your components and connectors are placed together. Of course, there's pros and cons in this. Right? So here, again, very simple. Um, probably There's very low operating cost, etcetera. Right. Um, but maybe less reliable, because there's one of everything. Right. So there's a single point of failure. Um, if you do it like this, this is a bit scaled up version of it. Yeah. So obviously performance will be better. There will be, um, higher availability, But then maintaining all of this Obviously, it will be more complicated than that, Which means more cost. Yeah. So this is really just to give you an idea of what a configuration is, what we mean by configuration. Yeah. Again, this is not the example of different configuration. Um, so it it says, I think, in the example, we mentioned how the left side is one configuration that focuses on building fault tolerance. And that sort of relies on the fact that this same configuration right application server in the database a database server, that configuration is kind of divided up into different geographical location. Right? So if some big network failure happens. Yeah. So in this region, then because you got same configuration over there. I mean, same sort of set up over there. It fails over to the other. Um, just carry over to the other geographic geo geographical location so that you can continue on the operation. Right? So that's design. That is particularly, um, aiming at fault. So network fault petition kind of, um, tolerance. Um, here is more for I think we've seen similar already, right availability, basically building up a lot of scaling up and redundancy in the components so that you can have higher availability. Right? So in the end, the system might give you similar property, As in, you know, system doesn't sort of fail, even if it fails. System is still available, right? But the, um, configuration of the design philosophy of how you get that is is different, right? Just showing a different options. Really. And I think these are sort of standard, um, architecture design that, um the person who originally designed this lecture notes, um, got it from I think it's sort of typical Amazon Amazon Web service configuration when they build a cloud. OK, so it says there's an exercise. Draw a component and connect the diagram. Um, for the lunch application at the launch venue. The project one. The pollutant Ethereum. Um, what are the components? Can you think of components in that thing? L one. The smartphone? Yeah. Smart contract. That could be a component. What are the sort of big so thing you see, huh? Yeah. That's one thing you have to sort of start up before you can do anything, right? And Ethereum? Yeah. There you go. The big thing. Like Ethereum in here. We can just think of it as one component right where you think where you just deploy things. Yeah, Ethereum is one component. Yeah, I think we probably here. We talk about the meta meta mask as another component that you use to interact with others. Right. So this could be, um, remix talks to meta mask meta mask to ethereum. Right? So, components and connectors. Yeah, another way. You mentioned smart contract, right? So here you can think of E theorem as one component, but then sort of express that smart contract idea on top of the ethereum, right? That's OK. People can understand what you mean, right? So that's Ethereum and the smart contract here, right? And instead, So this is an alternative one, right? Um, browser is one component, but within that you have, um, remix and the meta mask right talking to each other. And of course, the browser talks to Ethereum. Right? So that's another alternative. Similar idea. Just different. Different view of it. Yeah, um and I think the next one says your friends are finding it difficult to use ID, uh, remix So through a new diagram that uses a mobile app for the actual interaction. Right? And I think this one basically is suggesting that then that browser bit the remix bit could be mobile app. Um, so that could be that if you are modifying the architecture to express that there is a mobile app, um, instead of this remix component that you use the browser component you use. But then that doesn't quite capture how that talks to meta mask in this case, right? Whereas in this diagram, if you were to do the same, you sort of somehow express that we I I want this part to be now on the mobile then, um, the whole sort of browser based interface or the interaction that, um users do. You can kind of capture that now. Both of them are in mobile app context, Right? So maybe it's N a neat, neat, a way of replacing that part with a mobile app idea then that maybe here you have to sort of do two right anyway, so I mean, that's true. There is a better way to when you're given a problem, right? There is a better way to express, um, the problem. The better way to model, I guess. Right. Design, um, the problem. But in any just like in any design exercise, there's no right or wrong and stuff. It's just one is slightly slightly better than, um, the other might right might better than the other. OK, I think in the past few times when I had to do sort of project marking, so you had to do presentations, and we get to sort of, you know, assess your presentation skills and things like that. But part of it is for you to present your architecture design, right? And I noticed that a lot of you we don't know how to draw this architecture. That's why we are sort of trying to give you enough context about what we mean by architecture. What is the sort of level of detail we're after? Um, what should a box represent? What should an arrow represent? What does a stacking one box over the other actually mean? Right, So in architecture diagram, this and this is kind of a bit different. Different way to express. Um, an idea. So here, basically, we're saying this and Ethereum here, right? That sort of forms one layer, right? And on top of that, there's a browser that talks to it. Yeah, so that's sort of idea of layer, right bottom layer the top layer layer one layer to that sort of thing. And this one, although you eventually do the same thing, right? Communication with the theorem at at the end. This one doesn't quite convey this idea of layer, right? I'm not saying one is better than the other. It's just that in architectural diagram, this stacking has certain connotations. Certain meaning, right. So normally you would put, for example, database at the bottom because that's the sort of the bottom backend layer. And then something that talks directly to the database over the database and something that talks to database, Uh, that that that's something that talks to the database. That if something is on top of that, then you will take another one to talk to that, um, programme that layer, etcetera. So you typically see a stacking diagram, right to express how your system works. But anyway, we'll get to later. We'll we'll do a bit of tutorial during the lecture to sort of go through how you might express this, um, design idea. Right? Um, using either URL. Maybe UMLUML will be the best choice, I think. Yeah, so we'll do that. So now we get to this ATM part, I think. Right? A T AM part, um, that I said we may not actually go through, right. But at least in this So the slides are kind of subsection topic like that, At least in here, there are a couple of slides that I want to go through, and then we'll do the exercise right at the end. Yeah. So this idea of analysis Yeah, we said there are You could have multiple design. Um, that solves the problem. Right? But each design will have some sort of um, pros and cons. Right. And you want to sort of be able to analyse that, Um, well, this one, it's basically saying why we do this modelling. Yeah, we talked about le, uh, early on when we were going through this software architecture design process. We talked about how why you before you implement right? Why, you might want to dis go through, go through this modelling and evaluation. Um, refined process. Yeah, but first, you want to model your idea, produce the design of your idea. Yeah, because you can actually, without having to build the actual system by abstracting the problem or by modelling your problem, Um, or producing a design, right. That's what we mean. All the same thing in my in my book. Um, by producing a design or producing a model, you can actually analyse your system. Um, in a way that you can answer questions like, um, what is the transaction latency in this design, right. You can You can produce a model that will allow you to answer, um, questions like this. Right? So you model your architecture with that particular question in mind, for example? Yeah. Um how does my design support availability, right? If you look at your design and you can sort of discuss, talk through if you do this and connect with that if you place it like this on here, right, things like that you can you can talk through, um, your design to see how your your design might be full tolerant or might be scalable, etcetera. We might We could be bottlenecks and things like that. You can you can think through those issues with the model. Yeah, you have it, um, so different kinds of models for different kinds of analysis you want to do. That's why you may want to have multiple models and trade off. We talked about it. Um um, a lot already. And that's the main sort of analysis that we want to do. Yeah, trade off. So as I was mentioning, often improving so gaining one quality, you may lose another, um, quality. So if you want to get a bigger server to improve the performance, but then the system might become more expensive because cost is another quality. Yeah, that you want to consider how costly is it to run the system? That's another quality. So big system be server might be faster, but it may be more expensive. Right? So that's a trade off. Um, having redundant servers may give you better availability and performance, but it's gonna have high latency and obviously more expensive to run. So what? Trade off? Um, do you consider And how do you choose them? And that, um, determine what sort of nonfunctional property can you achieve by choosing this design over that, and you can justify that decision. So this is sort of one example of how you might do that sort of analysis? Yeah. So this comparing design options on how to represent or where to store data on issue of where is your data stored, or where do you? Where should you store your data? Should you store your data on chain or off chain? Right. Um, if if it is off chain, should you consider Private Cloud or some other sort of peer to peer system. If you are storing data on chain, would you embed the data in a Bitcoin transaction? Would you embed the data in a smart contract, etcetera? Right. So these are the options, and then you consider whether this is good or bad. Um, and then, you know, come up with the with the best best option right out out of this. So this is 11 way to one way to think about, um, design options and things that you want to consider on this column and basically ticking boxes scoring, scoring the options and just with justification. So with that, um, I think this one is sort of this one is one particular approach for doing this trade off analysis, right? I don't think we use this later on. So that's why I'm suggesting that we just skip this. You can read the notes. Um, but I probably wouldn't present this during the lecture, but we could still do this exercise, I think. Yeah. So two options, Right? Two, um, design options for doing the same thing. What is the thing we want to do? So we want to design a system that meant NNFT for the photo that you took. Yeah. Um, and we want to compare and contrast these two options according to integrity, availability and cost. Yeah. So what's the difference between these two? You can see, um I mean, just to count how many components are here. This is one more component, right? So maybe it indicates that probably more complicated option. Right. Um, so this one, the user with the mobile phone, right, um, uploads the photo onto some storage. Yeah. And in that storage, there's a service that will generate hash of the photo and put it on Blockchain. Right. So that generates an FT. And the idea is later on, then, um, the user would by using some, um, cryptography solution. Um, that is well known. And something that we can do. We, uh, claim that NF ID is, um, mine. Right? So ownership proof of that and have to generate it. And that's it, right? I took the photo, upload it here. And this one put it on the Blockchain I later on connect that ID with myself. Yeah. So now I own the NFT. So that's one option in this one. So here, actually, I'm doing as in I'm as in the user user with the mobile phone, right? I'm doing two interaction with two different things, Right? One with this storage. Another one with the Blockchain. Yeah. So what is this Web component in this option? What? This web component the browser component is doing. Is it abstract? This interaction that user has to do with just one component, right? So user only deals with that, right, as you can see here. So again, you can sort of see the trade off here already. Right? You are making it more user friendly, right? By making it more complicated for for us to build in a way, right? But obviously there's an upstate. Yeah, so from a user point of view, it's easy. I upload the photo and I get an F ID. Yeah, but for that to happen, this one is now doing uploading to the storage, right, getting a hash and, um, putting it on the Blockchain to get an FINF ID. Right. So that's the different design does the same thing, but different solution. Right? So what's what do you think? In terms of integrity, I guess integrity in a sense that you know, the photo and things like that. The data that I'm using is not, um, going to a 10 ft. I think in terms of integrity, probably this both are sort of similar. It's gonna give us because we both using Blockchain, right? It's gonna give us? Yeah, that that integrity about the photo. You can always do it because it generates hash anyway, Right? If the photo has been temp tempered in any for for for for whatever reason, Let's at least we can detect that The photo has been tempered. Yeah. So integrity, I think because of the Blockchain, Probably in both systems, we can we can get them. Yeah. Similarly, it's not like one is better than the other. Yeah, availability first of what is more available. Why do you think so? Yeah, to that. Right. Blockchain directly. Mm. Here is what What could be the problem here? Yeah, that could Even even if the Blockchain is available, If that's not available, then it could be right. So this could be a problem for that? Yeah. What about cost?

SPEAKER 2
And I want you to be, huh?

SPEAKER 0
This one? Why is that? And so that connect you that right? OK, call who? The this one. This user. Yeah. This is actually an interesting question because we said cost, but cost cost to to Like whom? Right. Um So here. I think, Um, probably what we're thinking about is the Blockchain transaction cost, but You're right. Cost could be that, like, the cost of providing this this service to the to the user. Right, Because here is added value added service, right? From user's point of view, I may have to pay more to get that. Whereas here, because I'm directly accessing this underlying one. Maybe there's a minimal cost to it. Yeah, um, pay some other service that would Yeah, that's right. Yeah, yeah, yeah. Yeah. So what I what I'm saying here is again, um, importance of making assumptions right when you are doing this analysis and justifying solution, justifying one design over the other and et cetera. First, I guess we have to decide what we mean by integrity here, right? Or what we mean by cost here, right. What sort of cost are we talking about? Right. If when we ask you that question, if it is not clear to you, you make that assumption right? I'm analysing this from the point of view of blah, blah, right? And all that sort of, um, explanation. Justification would be perfect. It will be wonderful. Yeah, in terms of, um, accessing Blockchain cost. If it's if it just cost is talking about how many times the Blockchain transaction is is generating. Um, in this one, there's two times, right. One to generate here. And another one to sort of make that link right in here. This is just one time, right? So if you're talking about that sort of Blockchain interaction as cost, then you know that's two versus one. Right? But again, if it is different sense of cost, yeah, then you can make the justification. Right? So here, I just want to do this exercise because, um, from what we talked about, I think that maybe a kind of, um, you know, we kind of know about this idea of systems and, general, um, common sense about all this terminology enough that you can make that comparison, but there is some more formal methodology you can go through. But I, I don't think I don't think we'll actually apply that here. Yeah, but I always find this sort of, uh, design exercise quite in interesting. The design design is really an interesting exercise. Always. OK, I think this is, um we'll finish here. Um What did I say? I would not forget. I will release Project two, actually. What I the reason that I kind of, uh because when I came back, I was kind of expecting that in FC MS. I'll see. You know, see, this group did Did I tell you about this group thing? No. Maybe that's why. Right, So here, go to groups. Because Project one is individual. Project two is group. It's all about having this discussion. Yeah, about design choices and what to build. And why should we build it and et cetera. Yeah. So, group, um, if you go to probably when you log in, this is a sort of lecture. You When you log in, you get an option to create group. Yeah. Um, I think the group type must be called default group or something. I see There are a few students already created group, so you can join. I think up to five members each group can have can have up to five members. If you already form groups offline and want to register here, that's fine, too. If you want to contact these people and ask if you can join, that's fine, too. But basically, we'll register the group here with CM S3 here. Right, Because once you register then it gives you, um I think like a wiki page type, um, space for each group. That's where you can enter your design, get some feedback. So we do most of the group activity through this one. Yeah. So I'll say when I release the projects back, I'll also release some instructions for how we might manage the group activity. Yeah, OK. All right. It's nice to see I'm sorry that I missed the big one, but we back so all will be OK and thanks. Thanks, Dylan. I think he's going to come around again. Um, he likes this course. OK, All right. We'll see you next next week. No, not Monday. Next. The slides from slide from 36 to 39.

SPEAKER 1
You said that?

SPEAKER 0
Yeah. Um, I'll have a look at the quiz. Um, if it is I'll, I'll re I'll change the quiz question. Yeah, if it is, I'll tell you. Actually, you have to study because it's in the quiz. But anyway, don't Don't worry. Just read the notes because I think there's enough detail in there. Um, if it is in the quiz, I'll let you know, or I'll change the quiz question. all right? Yeah. No, no. Um I mean, yeah. That's why I was showing that group thing You can contact. How do I look out? You can contact the, um, the person in the group. You don't want anyone? No, no, no. The whole point is for you to have that. Hm. So I'm not like what?

SPEAKER 2
Actually. OK, um, just ok, you know? I think so. OK. And, uh OK, yeah. You dog me. I take a look at the scenario. How much more? Thank you. And the 1st 100 days, this story. So So? So if I generate Hi. Oh, yeah.

SPEAKER 0
Pay cash or something. Like of the security purpose?

SPEAKER 2
Yeah, I think so.

SPEAKER 0
Because I you remove from yeah, cover.
