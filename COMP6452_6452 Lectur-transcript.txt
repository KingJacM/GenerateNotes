SPEAKER 0
OK, we'll we'll get started. Uh, good morning, everyone. Uh, and welcome to a new term. Uh um So the class is about software architecture for Blockchain based applications, but before that, who am I? Uh, my name is Diu Manar. I'm a senior research scientist at C SIRO. So who has heard of C? SIRO 12 few. Ok, um so we are We are the Australia's national research or let's say, um, national research arm. It's essentially a commonwealth entity. And And why am I here is this class actually originated based on the work that we have done in in our research team. So this is the sixth year that we offer in this class. Uh, but there is a major change this year. So last five years, we were running the course so, like it was run by C SIRO. So we we love we belong to a business unit called Data 61. So it was developed and delivered by data 61. But this year, UN SW is taking the course ownership and so they will deal with the administrative stuff and all of that, and I'll be involved in at least three classes maybe 1/4 1. But you will probably see me, uh, during some of the project evaluations as well. So last two years, I was the the lecturer in charge. I was running this course, but this year it will be Helen. Um, that will be running. So what I'm gonna do first is first give you a little bit of an overview of the class. Like what we are going to do and what you should ideally do to do well in this class. And then second part of today's lecture is starting on Blockchain basics. We may or may not be able to finish everything, but don't worry, but I'll be there, at least for another two lectures. And I think I should be able to finish everything. So, as I said, Helen is the lecturer in charge, So she will be your contact point. Uh, as from the teaching staff. Uh, but then Professor Salil is also involved, and I'll be like taking probably 3 to 4 classes, but definitely the first three. Then Ivan and Eric are your T. Uh, they will help with the labs and and the projects. And T is the course administrator in the sense like you will see a lot of posts from team on a forum and and places like that so most of the messages will come from team. So, uh, all the course content will be available through Web C MS. Or if you go to this link, it will take you to Web C MS so you can see all of the slides and the labs as well. So I'll talk about the labs when we get there. So what? Why, why this course was developed and why this was delivered is because we have been working in this space, Um, in in the last. Um, I would say seven plus years, I have been working on Blockchain for similar time frame as well, but I was I have been at data 61 only, like five plus years. So we generally work on things like this related technology, smart contracts, organisation and things like that. But we have a pretty good background in software, engineering and architecture aspects. So that is why so what we are doing is this class is not about Cryptocurrency. We are not going to talk about Cryptocurrency. But I will define what a token and how that token is different from, Let's say, Bitcoin or Ethereum or something like that. But the clause is more about some of the fundamentals around, like distributor systems can say a little bit about security but more importantly about like how you go about designing Blockchain based applications. So we bring in a software architecture focus into this. So this is not to say this Blockchain is great or the Blockchain is great. But to objectively look at and say OK, these are the problems with Bitcoin, or these are the good things about Bitcoin or Ethereum or some other Blockchain platform, but in terms of like application domains, particularly work on, let's say, supply chains and enterprise, social governance and things like that. So this is essentially about tracking things feasibility, verifying claims, trust, enhancing trust in a multiparty business process. But I also work on the fin tech domain in the sense we what we call a decentralised finance domain. So I worked with something called a research centre called uh DFCRC Digital Finance CRC, which is kind of trying to bring in some of these concepts into traditional finance context. So we are not talking so much about crypto, but essentially like what Blockchain can do to enhance other financial systems like, let's say how how we can help a X and and things like that. So this is a textbook. I would say about 60% to 70% that we cover in this class comes from this text box textbook, which was written by three authors. So they were actually the ones who delivered the very first school when this was offered six years ago. So they designed and developed this course. But the in go and move on Mark is still around, but so Sherry was. Sherry Zoo was involved for a while, but it's just a transition, so it should be accessible through Unsw. Only thing is, content is slightly outdated. I won't say it's wrong, but there are new concepts because this is 2019. 5 years in this space is quite a lot of time, and you may have realised, like how fast open air is moving. So it's just now days and hours, not not years anymore, so things may have changed a little bit, but if you have any questions, feel free to ask So at the end of the day, what at the end of the course, what you will be able to do so Ideally, you should be able to explain the principles of Blockchains and its role in some sort of an application architecture. And more importantly, I be able to assess the suitability of the Blockchain to solve a constraint problem. In a sense, not every problem but problem with some sort of a school. Now, I would say, like first rule of Blockchain is not to use Blockchain. You may have heard this in the machine learning context. First rule of machine learning is not to use machine learning If you can solve the problem in most simple ways, go for that because Blockchain you are bringing in quite a lot of problems. But it can also help helps you solve certain problems as well. So it's not that you should apply Blockchain for everything you need to figure out where it really fits and what problem you are trying to solve. So then you will be able to design Blockchain based software architecture so we will be actually design architectures in this class and then be able to make some trade offs in terms of functional and nonfunctional trade off. It's It's not that you can like when you build a software system, you can achieve everything. You gain something, you lose something. So the question is, whatever you are losing, are you happy with those? So that's that's what we want to talk about in this class and then be able to build a small application around Blockchain. Now, perhaps the best example of best feedback I have received about this class is one wouldn't tell me like This is the only class in my undergraduate career at Let's Say, at Unsw, I learned everything from writing requirements, designing something, developing something, testing and demonstrating that like if you take a typical book, let's say a database class or something like that. You will write some queries. You will build a library like, let's say, a database for a library or something like that. But you don't really see that end to end. So this is This is perhaps the only particularly for undergraduate. This is perhaps the only class that you will be able to do end to end. But on the other hand, that doesn't mean it's easy. So Ah, is this class easy? Probably not. But on the other hand, will I learn a lot from this class? Definitely. But what I mean by it probably not in the sense, not easy it's not. There's some theory, but there's a substantial hands on component as well. So if this is gonna be, let's say, your first class to programming. Please don't take this class so we will be using solidity most of the time in your labs. But solid. It is not a bad language, but on the other hand, it should not be a first introduction to programming class, because when you run a programme across the network on thousands of nodes, there are new challenges rather than working just on your on your laptop. So that's why I'm saying, like you need to apply a little bit, hands on experience and those will you will develop. So it's more through, like persistently working. It's not because this class is very theoretical or anything like that. It's just you need to do the things on time, and that's what I mean by hard here. It's not that I'm saying you cannot pass this class. It's nothing like that. So you just need to apply whatever you learn day by day, so that you can actually do well at the end. So we will go through this 10 weeks. I don't want to go into different topics, but let's say today we like first week basics. Second weeks, we start on smart contracts and software architecture basics. And then we have a holiday here which we will, rather than having any class we will cover through by putting a recorded lecture about a real world Blockchain systems. And then we talk about some software architecture aspects of this, and this is where your project to presentation. So here you will be presenting a set of requirements, functional and nonfunctional requirements and are designed to satisfy those requirements. Actually, you will be doing two designs, and you will be comparing and contrasting those two designs. So that's why I said you have to look at trade offs so one design will have a certain pros and cons. Another design will have a certain pros and cons, so you are gonna design two things at least, and then compare them. Then Week six is the break and we come back again. Week seven, we have a couple of topics. But this year one key change is this week nine. So CS is going to have a Blockchain industry week. So you will like. We will get a couple of industry people into the class and talk about whatever that they are doing. We are still trying to finalise what they are. But only thing that I requested them is whoever coming and presenting. Please promote Don't please don't promote crypto. That's not what we want to do. But we want to see like what sort of real world applications people are building using Blockchain. So maybe supply chains, maybe decentralised finance and things like that. And then at the very end you have the second part of your project too Which is that the demonstration? So whatever you develop, you demonstrate to us at the very end in terms of assessment. So you have two projects like the lab one that you are getting Today is your first project. Essentially we will give you a piece of code. We will give you a long hand out on what to do. But then you you need to do. Fix few things in the programme that we give you so that will give you 15 marks at the end and then your project two is 30 marks but like 16 plus 14. So Project one presentation, 16 marks. Projects two demonstration 14 marks like that. So there will be two quizzes online quizzes. We will advertise them when they are, but I think they are already marked here on week four. So first quiz on week four and then the other one on week eight. Um, so then the final exam. It's an open book exam 24 hours open. Only thing is, this is not a typical exam paper. It'll be like you get a research paper to read through. It will take about two hours, 2 to 3 hours to read, depending on how fast you can read. And then we asked like a bunch of high level questions like OK, what do you think about what is discussed in this paper and how you relate them to the things you learn in the class? So what are the good things? What are the bad things? Of course we go in step by step. There are about 14. I don't know. Maybe, let's say 12 to 14 questions to answer. So we will ask. Like, according to this paper, what are the requirements? And what was the specific design that they had? So how do you evaluate that design? And then, at the very end, there are a couple of questions like, OK, what can we do to improve this design based on whatever you learn in the class? So it's again like not so much remembering root learning, remembering things and trying to dump at the end. Of course, I have seen examples like, particularly last year, GPD generated answers. But the thing is, sometimes that answer does not even relate to the question paper. So there was something like, OK, how to improve? Uh, something about how to improve data storage in this solution, And that solution was not talking about data storage at all. So please don't do things like those. It's not hard. It's just you need to kind of follow the process, and I don't I don't I don't see any of you not being able to get a HD at the end of this term. Um, about lab classes um so the lab classes are mostly to guide you. In a sense, we have four lab sheets that is already there. I'm not sure everything is there. At least Lab one is already there. Others we will just run through because the problem in this domain is, let's say, whatever we did last year, when it comes to this year, some of the tools have changed or the location of a button or something has changed. So we had to always go back and double check whether the latest libraries whether the latest tools are always inconsistent with the lab sheet. So that's we did that for lab one. So which is already available, so you can pretty much go to every any of the labs classes that you want. You don't need to just go to the one that you register. Only thing is, we hope that not everyone let's say half of the class will show up for one of the lab classes. Please don't do that. But for whatever reason, you cannot go into a regular one. You want to go on something else that's OK with us, and we are not gonna teach anything in the lab class. What what happens is you have the handout that is your self guide. But as you walk through that, if you have any questions you the TAS are available to discuss, so it's just take your laptop to the class, start working, or even if you want to work before before the lab do, that's fine with us and just come to the lab. You're not gonna take attendance or anything like that, just but if you have questions. So if you want to discuss anything with the T, please come to the lab. And at that point, but one thing I would say, like in in Lab one, it very specifically says, Please don't cut and paste this code from PDF into the tool, but about 80% of the class does that A. And you can't even figure out why it is not compiling. It's simply because there are hidden characters. Nobody sees them. So so one thing I would say to be successful in this class, please read the instructions. Instruction is, in a sense, whatever given to you in whatever the document. Plus, let's say whatever the team post on a forum and things like that. Those are usually the problems like 8088. 90% of the problems that we have in the class are simply because you don't read something. And it is not uncommon for me to like, get an email after the first quiz to say, Oh, I didn't realise there was a quiz this way. This is Week four and even now I'm announcing that I have heard various example by various reasons. I mean, if you get sick, I understand. But like even the quiz is open for 24 hours. But I have had reasons, like students saying, Oh, I forgot to set my alarm. Does it matter when the quiz is open for 24 hours and it's only a 20 minute quiz. So So this is what I'm saying. Like it's mostly because students sometimes don't follow up with notifications, and things like that is nothing else. So simply if you really want to do well in this class, probably that's the most important thing you need to do. Just follow up with announcements, whatever we tell in the class and and I'm pretty sure you're gonna do well. Other thing is free up. If you have any questions, ask questions. So we are going to use the forum for various various things. You can also post questions, so please use that. It's a very good resource. Students can answer each other as well, but we can also help you help you. In many cases, there are possibilities like you can put like. Generally it's an open post. But if you really want to lock something and only, let's say, make it available to the teaching staff, that's also possible. Um, I think I covered pretty much everything. But if you want to talk to us like talk before or after the class, or or or get an appointment or or just post something on the forum, we may be able to agree on a time just to have a quick chat. And and same with the T A As as Well, OK, I think that's my last slide. Any questions? All good. Everything really clear? OK, so we'll get started. And as I said, like please reach out. That's the biggest problem. And one last thing. Maybe Project two, particularly when it comes to the second part of the Project two, which is the demonstration. Part of the development, testing and demonstration part shouldn't do the presentation in Week five and Week six is a holiday week and student disappears. And then everyone tried to come together weeks week before the deadline. And that's a recipe for disaster because you cannot really get something up and running. I mean, if everything works or if you're an extremely efficient programmer developer, let's say yes, you can do that. But otherwise there are bugs, and some of the bugs are not very easy to resolve because you're not going to just run your code on the laptop itself. You will be putting this to a global network, and sometimes certain things don't go well. And it takes some time to figure out biggest reason that some of the students projects don't do at the very end, Very like, let's say we have. Unfortunately, we have had students like groups that had 16 out of 16 for presentation one, but only like eight marks of the presentation, too. It's simply because everyone disappears. We or before everyone tried to do something and then realise it's too late and then also start Quite a lot of finger pointing, saying OK, you didn't do your part because of that. I couldn't integrate this and all of that. So I have had situations like where students submitting evidence to say, Hey, we send him so many notifications He never responded And then I had to go through a wechat and that is in Chinese and I can't figure out who he saw me. So I have had, like, various student submitting. So the thing is, is it in? Let's say there's a four student group and three of them are actually doing work and then someone is not responding, so they they should not be penalised. I understand that. And But then on the other hand, like students start pointing fingers at each other, saying it was your mistake, you didn't do it because of that. I didn't do it. So your your code need to integrate at the end. So integration needs planning, so you need to plan a little bit like what is what you're gonna do. And don't give me whatever your code. One day before the demonstration, at least give me three days before the demonstration because then you and I can make sure that things work together, so I'll highly encourage you to use things like github. So how many of you have github accounts? So how many of you are not computer science students? Everyone is a compre student, so if you are a computer science student, why you don't have a G account? This is outside the class, but my experience tell me like when you apply for a job, let's say at the end of your fourth year or if you are a master student companies usually wants to know the work you have done. And one of the easiest ways to demonstrate your work is to put a link to your git hub in your CV in. In today's environment, having a GI profile is extremely important. At least put your class projects in there, of course. Then we have a problem, like we need to make sure every year, like students don't copy from the last year. But that's our problem. But everyone should ideally have an account. If you really want to demonstrate to the rest of the world, this is what I'm capable of. These are the programmes I have written. These are the languages that I'm more familiar with. So this is not just for this class, but it's today. Like having AJ account is like a must for any computer science student, I would say. OK, um, last chance. Any other questions? OK, so let's get started. And what you will also learn through this class is to look at, be able to look at a lot of things that you hear in this space. Various blogs, various videos people talk about and say this Blockchain is the greatest. So this decent application is the best in the world. You will actually get tools in the sense mental tools to be able to object, to evaluate some of these claims A lot of people make not a lot of things that you hear in this space is true. But that doesn't mean there is an opportunity to innovate. Innovation is there. Blockchain is actually transforming a lot of things as a country like, let's say, Australia can benefit a lot and there are already a few applications. But so what we want to talk about is like, what are the technical ideas behind them? But this is where we will focus most of the time in this class Like how you design the applications like this. Ok, um so this one eat river? I think it is down. Oh, I did a mistake. Uh oh, OK. Ah, OK, up. So that was my mistake. II. I maintain the service, but I didn't log in for a while. Apparently the note ran out of this space and and it was down for about 10 days. So when? When So? OK, forget about all of that. So what you are seeing here is a live visualisation of what is happening in Ethereum. Blockchain So all these circles, these are the transactions that are waiting to be included in a block like this. So this is going pretty fast. Ideally, this should go every 12 seconds. But this is going very fast because my node is trying to now catch up Whatever it missed over the last 10 days because it was down. It was not synchronised with the rest of the so that is why it's moving pretty fast. But ideally, what happens is a new rectangle should appear here approximately every 12 seconds. So these are a bunch of transactions that are waiting to be included in a block. So here's a block and all the transaction. There are circles like these different colours and the sizes are sizes. We don't really see much here because this is running at full speed. Colours indicate whether they are Cryptocurrency transactions or whether they are smart contract transactions. And sometimes you will see a bigger circle. If that transaction is carrying quite a lot of ether ether is the Cryptocurrency used by Ethereum. Um, so then, like if it is like transferring 100 litre, the circle will be bigger. So what we see here is these blocks, they have a number. So this is called the block number, and they have what is called a block address. That's the unique ID, or identifier of a block. And if you see, like each of these blocks are linked to the block. So this is the parent. This is like the child. So these are the success of the blocks, and these are the ones that happened earlier. Now a bunch of transactions goes into a block, so this is called the block body, and this is called the head up. So if I click on one of these transactions. So, see, uh, let me get something, OK? Bit of eater. So it takes to a website called it a scan. This is like the de facto we like. What are what is called the Blockchain browser for Ethereum ecosystem. So this transaction has a unique ID. What is called the transaction hash. This need to be globally unique. And this transaction is already included. Success. But my note is catching up. So that is why it's still appearing on that ui. After about two hours, it should be up to date and then, like, we will not see transaction that are already included. So this got included in a block number called this one. So only eight blocks before. So, like this into 18 to 12 seconds. So about 80 90 96 seconds ago. So, um, so it got included in a block and this is the time stamp, So yeah, one minute something. And it was trying to do some sort of a swap it either for us. DD What is UDD? Anyone heard of us? DD Yeah, so to say it's a stable coin. So what is a stable coin? We'll talk about that very later very briefly, but a stable coin means like one coin is equivalent to $1. The problem if you do transactions with Cryptocurrencies like if you pay me one. E today is about 5000 plus Australian dollars at this point, but tomorrow who knows? It can go down to 404,000 or maybe 6000. Then I'm at a better place. But so stable coins try to deal with this volatility by having a stable value over time. So it's $1. Always. It's equivalent to, let's say, $1 or $1. So if someone is trying to use a service called UNICEF version three So these are what are called automated market makers. We're not going to talk about them here, but in this class. But what is essentially doing is you are trying to swap ether for USD. So, like 0.01 E or it's actually much smaller than that is equal to about $21 21.7 US dollars. So this is there are a few other additional details here if you go down, so I would I would highly encourage you to go through this and get a little bit familiar. Anyway, through labs, you will do that. OK, so from so who is sending this to is who is receiving this transaction. So like if you make a payment, there is a sender and there is always a receiver. So from is the sender two is a receiver and this is what is called an ERC 20 token transfer. We'll talk about them much later. And how? What is the value of the transaction fee? So, in public Blockchains, when you send transactions, you have to pay a small fee. Maybe if you guys can't see, let me try to increase. Yeah, does that help? And there are a few additional details like OK, so they will talk about them briefly next week. But later in detail like when you send this transaction, you have to pay a fee. If you are willing to pay a higher fee, your transaction has a higher chance of getting included in the Blockchain faster. But I mean by getting a transaction included in the Blockchain, faster is you want to move from here into one of these as soon as possible. Otherwise, you can wait here. You can EAT in, sometimes even a week, and your transaction may not get included. Usually you want to do this in seconds. Um, so this is actually the binary input that was used inside that transaction. OK, so maybe let's also look at a block. Let me just click on one of these. OK, so here's a block block has a number block is finalised in the sense everyone in this network of like, I don't know how many Ethereum nodes are. There are definitely more than 5000 across the world, maybe even 10,000. So everyone agrees this block is finalised. In a sense, whatever transactions that are recorded here, uh, final, what is mean by final? Let's discuss that a little bit later. So So this was included 10 days ago because my node is still catching up. Uh, it was proposed on, uh, on slot. OK, let's not talk about slots and epoch at this time. We'll do that next week. No, actually on Wednesday, So this block has 123 transactions. So what it means is so something like a rectangle like this, this one has 123 transactions, so you will see like blocks are of different sizes. Some of them have more transactions. Some of them have less transactions. Uh, so there were 16 withdrawals in this one who got the the fee in the sense. So this is essentially, like, who build the block. So if you build a block in a public block here, you usually get Cryptocurrency. So this is how Cryptocurrency generally comes into existence. A miner building a block gets what is called a block revolt. So that is how new Cryptocurrency get generated because miners put an effort to build the block. And because of that, they get compensated by having those new Cryptocurrency assigned to their name. So how much was the reward? It was only like 0.03. It used to be much higher, but it has gone down now. So anyone heard of the reason Bitcoin having so Yeah, What does that mean? Um, I think every 210,000 What?

SPEAKER 1
It, um, the reward that the miners get for in the past.

SPEAKER 0
Yeah. So there is a rule hard coded into the notes. So let's say, for example, Bitcoin, I think started with about 50 Bitcoins. Then, after some time, it became 25. After some time that became 12.5 then 6.25. I think we went from 6.25 to 3.7 whatever half of that recently. So that means with time, the the new cryptocurrencies that get generated reduces. If you understand a little bit of economics in the sense this is like reducing the supply, that means the price of an asset should go up. So this is why recently Bitcoin has gone up. There are other factors, but this is one of the factors, so you get compensated a little bit. But if you really convert this into dollar values, that is still not bad. Um, there's something called difficulty. Don't worry about this one, size of the block. It's only about 60 60 kg bytes. The block is not very big, Only 60 kg bytes. There's something called gas used. The idea is like from whatever. So let's say this is what you should have done. You have only filled like less than half of it. Uh, gas limit was 3 30 million, so only about 11.8 million was used, so the miner could have done more work and included more transactions. But whatever reason, Miner decided not to do so because it's always up to the minor to desire whatever they want to do. Um, let's not worry about some of these, like base fees and things like that. Some of these we will eventually talk about in this class. There are a few additional things like, OK, what is your hash? This is the block's unique identifier. This is the parent hash in the sense the block before you had this unique identifier, we'll talk about that very soon. Like why that is important. Um, so that's what is called the straight route withdrawal route. Non is no longer useful, and that's why it's always set to zero now in in Ethereum, Version one. There was a value here, but when they move to Ethereum version two, this is no longer being used, and these are there's a bunch of transactions. So if I click on this, I get to see that 123 transactions that were included in that block. Any questions?

SPEAKER 2
Yeah, take more visit that OK, so if I try

SPEAKER 0
to give good question if I try to give a most simple example Now think of an account ledger in the sense you record transactions on a book. So let's say, What's your name? Sorry you you die. So let's say I pay you $5. So on that book, on a page of a row, which I will write, I paid $5 to him. So, like that, someone else pay me. I pay someone else like that. I can record a bunch of transactions on that page. Then let's say I take the summary from that page and I can go on to the next page. So one of those pages that I record those transactions is like a block, and I take the Let's say what the closing balance, either a credit or a debit, and I then go to the next page and start writing more transactions. So So the idea of a block is somewhat similar to that where you record a bunch of transactions and and you take a summary from that and then you move on to the next block. Now the thing is like, for whatever reason, let's say I want to claim that? No, no, I actually paid you $50. Then I need to go and change my transaction on whatever the page that I wrote that 5 $5 transaction. But the thing is, if I change that $5 to $50 the final summary on that page changes. So that means I had to change that, take that change and go on to the next block as well. And so that is where this chain of blocks becomes very important. So the idea here is like, let's say a truck is running fast, But let's say I record something here. Either I want to deny that or I want to claim that I paid him more than what I said or I want to double spend that $5 in physical world in the sense when you have notes, if you give me $5 if I give him $5 I don't I no longer have that $5. But in the digital world, if I just say I give you $5 recorded as some digital thing, I can just keep spending that $5 again and again. So this is this is actually the problem that Bitcoin was initially trying to solve, But it's called the double spending problem. So if I brought something there and if I want to change my mind, I need to go and update this block. But the thing is, when I do that, that block is already linked to another block after the block. So if I If I'm a fraudulent actor and if I want to change something, I need to update my transaction, that means this blocks hash will change. So this hash, though we did not talk about it, we'll talk about it next week, on Wednesday. This way is the hash OK? This is like a digital fingerprint. Even if I change a single bit in that block, that cash value will change. So if I decide to change something that block changes, so that means whoever include this block as the parents. So let's say this is my hash now, if I go back to the top, so just remember this number. So this is Block 765 and the hash value. Start with 300 let's say end in one. A E. Now, if I go to the subs and block and get the details. So this is this is the parent. So the next block is linked to my block. So if I change something in my set of transactions that has changes, that means whatever I change. So let's say what I change here now need to be reflected here. But if I change that one, that has gonna change. Then I need to go and change the next one. So if I'm a fraudulent actor or someone who wants to double spend, No, let's say I never paid. I paid more than enough. Whatever I want to do. I am in a race with rest of the network to build all of these blocks and be here. So if I have enough computing power, if I have enough money Cryptocurrency I can rewrite this whole history. I don't need to rewrite anything before that, but whatever my transaction and into the future, so I'm essentially in a race to build, modify my block and modify all the subsequent blocks with the rest of the network. But the size of the network here is like 10,000 nodes, so you may have heard of something called the 51% attack in, like what are called proof of Blockchains. We'll talk about the details, but very simply, that means if I have more than if I have 51% of the computing power in the network. The rest of the network has only 49 So I can like, think about two vehicles trying to overtake each other. If I have, like one kilometre per hour advantage, I can eventually overtake them. But it takes time. So so that's the whole idea. If I if I control too much competing power, if a single individual or a couple of people control too much competing power or in Bitcoin context, it has to be too much. Either. I need to have two third of it to rewrite the history. So two third of it is like a couple of billion dollars US dollars, not even Australian dollars. So this becomes either computationally hard or economically hard to do that. So so the whole idea is if I want to change something, I'm competing with the rest of the network, and I cannot do that unless I have a massive amount of competing power or let's save money to do that and just to, let's say, give him $50 on claim that I gave him $50 not $5. I don't want to spend $2 billion or, let's say, $5 billion trying to override the network. So there is what is called. There's a bit of a not really a bit of there is what is called game theory in play here. So it's essentially a game, a good actors and the bad actors trying to play, so that that was a long answer to your question. But somehow did I kind of give you an idea of what is happening here.

SPEAKER 3
Uh, this network is somebody is running it or like everybody, everybody.

SPEAKER 0
So for an example, what you're seeing is a note that we run on AWS just to collect this data and show that we don't do mining. But this one is pretty much because you have to be become a So what I do is I just go to a website called get planned. Download the source code. Um oh, just download the binary and I just run it, and I eventually become part of that network after synchronising So this node is still synchronising. It is trying to catch up whatever it lost over the last 10 days. So if you if you start a new node, it takes about two weeks to catch up. So this is trying to catch up 10 days of works like since, like, 6 a.m. today. It should hopefully be done in a couple of hours so anyone can run. Only thing is, you are essentially reliant on a set of protocol rules that you have written into the source code. So the code is the one that decide every certain number of blocks. The price that you pay to build a Bitcoin block reduces by half like becomes half. So that's a protocol rule. But if everybody decides we are going to change the rule, you can do that. You just you need to run the latest version on Let's say the software that says from next time onward, we are not gonna make it half. We are only gonna make it one third. If you want to do that, that's possible. But you rely on this common behaviour. We are a large set of actors in Bitcoin again, we are talking about 10,000 plus nodes. And those 10,000 people, most of them don't know, even like who is who and where they are located. Even any other questions. So please go to the site, click on a few things. It will take you either transaction on a block. Nothing can go wrong, but please browse through some of these. But anyway, like when you do lab one, you will see some of these, and you can actually put your code and see them like if you go here. Uh uh, Where where can I change the network? OK, here. Now you will probably deploy your code to girly test network or so probably Sophia test network. So once you upload your smart contract, you can look at your transactions on this web interface because you are just submitting these transactions to a global letter. Now to play in the test networks, you don't really need real money. You just need to somehow accumulate test once we will talk about four ways to do that in the lab. But in the real network, you need in this case you need ether. But in other networks like Bitcoin or something else, Uh, we'll stop this simply because it's gonna eat out the battery. Uh, in this case, just the CP power. Now this This is a view taken much like from ITER version one. And there are quite a lot of like these red blocks which are very hard to see in the version two. I have seen only one so far. Not that I have been looking all the time, but I have seen one. But early days There is what is called this consensus and and soft folks. We will talk about them next time. So it's like when I build a block, let's say if I'm a miner, I decide to put a bunch of transactions into one of these rectangles or the boxes, and I will decide one of them as my parents. So I decided to use this one as the parent. You can't probably see this, but they had the same number. So So what happens is while I try to build a block, someone else in this network, because there are, like 10,000 others, not someone not just someone. Maybe a few others may also try to build the block. So there is a possibility that multiple of us may build a block at the same time and claim to the rest of the network. This is the latest block. So network has a way of resolving these kind of contentions. This is what we call consensus and then agreeing like, OK, so this is my block, and my successor decides to use me rather than this. So this has become an uncle block in Ethereum terms Bitcoin terms. These are called open blocks, so they decide to discard these, whereas they decide to use this, which is linked to this one. So after a while, what happens is you ignore transactions that are on these red ones because nobody is really referring to them other than the one just after. So this is where things get a little bit complicated. Now, when you when you do a transaction on a typical banking system, anyone done a NPP or a pay ID transaction? No. Yes. So if you do a pay ID transaction when the money goes to other side, that's it. But in Blockchain world, these things are a little bit more complicated. Just because let's say one of these goes into one of these doesn't mean your transaction is final. You need to wait some time so that you give enough time for these kind of issues to be resolved. Because if my transaction goes into this one after a while, rest of the network does not consider me as a valley block. Then my transaction is actually not included. So in in again, if I'm jumping ahead in Bitcoin, we usually wait like one hour before considering a transaction to be final or included in the longest chain. What I mean by the longest chain is all of these links that always point to the predecessor of the successor, depending on how you want to look at this so that you form a longer chain while disregarding this red ones, whereas in Ethereum it's about 7.5 minutes before you consider your transaction to be included. So things are a little bit different in this space. It's not just you send the transaction that is done that is persistently written. It takes a little bit of a time to resolve those kind of conflicts. So what you saw was it a scan? That is what is called a Blockchain Explorer. Uh, then II. I tend to use it sometimes this blockchain.com simply because they have a they demonstrate like data from about 15 different Blockchains and very useful. Sometimes when you want to look at like, data and like, look at various things happening across different Blockchains. And again, it's like if you have a private Blockchain like hyperedge fabric, they have something similar. So this is essentially a way to see what is going on on a Blockchain. Now, before we talk about what Blockchain changes, we need to understand a little bit about what do you mean by conventional technologies? So you may have heard of this idea of a client server system where there are a bunch of clients through the Internet, they go to server somewhere. You don't even know where they are, but somehow get access to a service. Now, these are very simple, the simplest form of client server. But a lot of large scale applications has a more complicated set up like this. It is decentralised. So this is everything in a single centralised server, but this is decentralised, so you have a bunch of nodes that goes through to some sort of a load balancer what they are. Let's not worry about them. We will eventually discuss them, and it hits the set of one of the Web servers. And then one of those Web servers will redirect your request to some sort of an application server, and ultimately you will hit some sort of a database. And like while you have three databases, there's only one primary and two replicas because generally writing into multiple databases are hard. Reading them from multiple databases is not a problem, but writing generally is a problem. So you you write, you write to a typically a master that master will replicate to the replicas. So if for whatever reason master fails, you can start continuing from the replicas. Now, if you if you really look at these, they are like that second set up is not on a central single place. Now let's say this could be in Sydney. This could be in, Let's say, Tokyo, and maybe this is in North America. That's possible if your application runs across the globe so they are no longer centralised. But if you really look at this, this is This still belongs to a certain organisation they administratively centralised network wise or hardware wise. They are decentralised but still belongs to a single entity. So the computations, the storage of the administration, they they may have various forms of centralization and decentralisation. But how something like Blockchain would be different is particularly with this aspect. Even the administration is decentralised. I have my node. I do whatever I want. As far as the rest of the node agrees with whatever I'm doing, I'm part of the network in the sense they don't ignore me. Then you're on your own. Note. You do whatever as far as you play by the protocol rules. You are part of the network, so this is the key difference. Not that, like before, Blockchain hardware was still decent. Like like this is how I mean something like Facebook or or, let's say, Microsoft Services Office 365 and things like that, it's much more complicated than even this, But it's still under, let's say, Microsoft or Facebook or someone like that. So the Blockchains original idea was to replace this 3rd 3rd party with a network of not. But why do we need a third party now, particularly in financial transactions When two people that don't know each other want to trade some sort of a trade Like I'm selling something, you're buying something. Even if you know each other. Sometimes we need some sort of a backstop in the sense if that trade goes wrong, like, let's say I gave you something you didn't pay me. You need someone to mediate this transaction. So that is why we have a middleman. So usually commercial banks play this role, and they usually take a big cut for providing that sort of a service. So what they're essentially doing is they are providing a service to establish trust between two parties that has never seen each other. Even many cases they may know. But there are enough cases that you don't even know who you are trading with. So Blockchains idea is to replace this middle man with a network of notes. So that helps you establish that trust using that network of node. So technically, this is essentially an app only database, so it's a database that you will try transactions one after another. You're not gonna delete them, you will just keep appending them. But that was Blockchain version one or let's say, generation one with the the M came Generation two, where it just says not only you can record things, but you can actually run a business logic. On top of it, you can run a programme on top of it. That is where the smart, smart contracts came into the picture. So it's not just shared data or recorded data, but now shared behaviours through computation. So but still, most Blockchains are still logically centralised as data in the sense, Whatever I keep is same as whatever you keep. So that is why my node is like spending a couple of hours trying to catch up with the rest of the network because it won't have the same copy as what everyone else in the network is having. It is possible to decentralise this technically hard, so that is why still a lot of Blockchains are what we call logically centralised as data. But definitely administration is decentralised. So what Blockchains are good for they are good for new, trustworthy and efficient ways of working together. Don't bring in a Blockchain to solve a problem that does not exist in the sense like let's say if you have an efficiency problem, Blockchain is going to make it worse. But if you have a trust problem, it can help you do that. So, for an example, like something like, um, let's say there is an asset. Have you, uh, who? What is a non fungible token? NFTS. Anyone heard of NFTS? How to explain? But someone put, Let's say someone takes a photo of a dog on the street and put a put that and make an NFT out of it. And let's say, trying to trade that for $5 you can create an nft for pretty much anything today. But let's say whoever did that and you are interested really interested in that that photo because you believe some, like some days it's gonna be $5 million worth, So you want a bite, but you don't know that person, and that person doesn't know you, so you don't want to be in a situation where you send that $5 equivalent to whatever Cryptocurrency. You don't want to lose that as well as the person who owns the NFT doesn't want to lose the ownership of the NFT if you if you don't get paid. So this is what the Blockchain allows you to do. It allows you to allows you to transact with people that you have never heard of or you don't even need to know. They don't need to know who is buying. So you hide behind some sort of address, Remember? Like there were the zero X hash numbers. Those are unique IDs, so you hide behind something like that. But the Blockchain will ensure an atomic transaction in the sense it can make Sure you pay whatever $5 equal and in whatever Cryptocurrency and you get hold of the NFT either both shops or nothing shops. So this is this is pretty much what the Blockchain is really able to do. So it replaced that middle man, but still ensuring two people to make sure that ensuring two people can transact even if they don't have any trust among themselves. Um, maybe a good time to take a break was the time. Yeah, Any questions before that? OK, maybe let's let's have a quick five minute break.

SPEAKER 2
No, OK, question the economy.

SPEAKER 3
So like OK, ok, it's a home 16. Yeah, but what the that I want no less so

SPEAKER 0
no.

SPEAKER 3
So So So basically my law will get from so name.

SPEAKER 0
So next What is this? So you so So it's extended the legs.

SPEAKER 3
So we one of those one of those I can see is that if I had and the so Oh, that it the plan in the whole. OK, I don't even delo We are not if you don't get that OK, so I have what right?

SPEAKER 0
Oh, why is what?

SPEAKER 3
But you can actually do it in six seconds The

SPEAKER 0
fire policy among people who runs these networks. Ok, um so there was a question about like what does the Blockchain really means? And whatever I said, How does that really work? So So what I did was I kind of jump ahead in the sense I talk about what happens at a high level like you have an nft. I have Cryptocurrency and you want to sell your nft. I want to buy your nft. But tomorrow, particularly part of today, Wednesday and next Monday, what I will talk about more is how this really happens behind the scenes. So at a very simple level, think about it as a database. So? So the database knows. Let's say it was his NFT. That dog picture was his NFT database currently knows that he owns that NFT, which is some set of bits to say, Here's the NFT. Here's the URL and things like that. And then it also knows. Let's say I own 0.5 it. I wish I own that much, but I own, let's say 0.5. But after that transaction, what the network will do is it'll remember that I own that nft. And let's say I pay like 0.01 E for that transaction and I had 0.5. Now it becomes 0.49. So what the network really does is that that the ledger concept I said, every time you do a transaction, it keep track of the the the credits and the balances. So it's like a database but replicated across 10,000 plus nodes. Then remember that now out of that transaction, I am the owner of that NFT, and because of that, I also lose 0.01 ether that went out from my account. And now it is in his account. Does does that help, at least at this point. But how this happens? Yes, it is complicated and and let's try to break this in the next two today, plus the next two lectures. But even after that, if you don't really understand it, don't worry so much. Having a decent understanding is enough. If you really want to appreciate this technology, you really need to understand security distributed systems and and quite a lot of other things. So it is. The class probably won't make you an expert in those topics because you need a little bit more technical depth to understand. But at least I hope you will be able to get a decent understanding of how all of this happens and all the magic behind this. So why I why I like Blockchain is primarily from a technical point of view? Because, let's say, 10 years ago, you cannot go and tell a blank bank. I have a database system call a Blockchain or whatever that you put a transaction one hour later, that transaction will be confirmed. No bank would buy that, and that's what exactly happens in Bitcoin. But today that discussion is very different. I have a of course they don't want to use Bitcoin. One hour is too late, but now you can walk to a bank and say how this wonderful database system that you can do a transaction and that transaction will be final in five seconds. But that allows you to trade with anyone across the world, regardless of jurisdictional boundaries and all of that, that's that's a very different discussion. That was not possible, Let's say 1015 years ago. So what are you gaining your ability to transact with anyone in the world anywhere in the world? What are you losing? Of course, banking systems runs on a fraction of a second, but let's say what happens in 200 milliseconds now becomes five seconds. But so that's That's the trade of I'm talking about. You gain something, you win, you lose something. But of course, there are other problems. No government will be happy when you can send let's say Australian dollars to anyone in the world because that has a lot of other problems. Tax monetary values like, let's say, inflation and all of those those becomes extremely difficult to control. But that's not the focus of this class. So this is where it becomes very interesting. Technology wise, Blockchain is ready to do a lot of things, but you have to deal with a lot of other political economics or regulator related issues before it really becomes a global thing. So it works very well for certain applications. But others it needs time. OK, so Blockchains. Or sometimes you may have heard this word dlt or distributed ledger technologies. So dlt is an umbrella term. So any ledger that is distributed, remember I said, a ledger is writing things on a book one page at a time. That's a ledger. So if you distribute this ledger, that's a distributor. Ledger Blockchain is one way of implementing a distributor Ledger in a later class. We will talk about a few other ways of doing this, so Blockchain is not the only way to do this. But Blockchain is the most popular way of doing it again, because there's quite a lot of Cryptocurrency attached to this, and that's what makes people It's interesting a lot of people. So ledger is essentially an APP only list of blocks. Each block has a bunch of transactions. Um, so ledger structure is one list, but in the sense operations are in a peer to peer network. So all of these nodes that run by different individuals somehow helps you to record these transactions, and the block can link one block to another block. But just remember, this is just one way of doing it. There are other ways to do it. You can have. So this is like a link list in typical data, uh, data structures and algorithms. Well, this is a link list. There's a link. There is some some sort of a data entry that links to the next one. But there are like graph like networks. There are mili networks, so still a link is a graphy one. So So there are other ways of doing this, but this is the most most straightforward one to at least understand. Uh, and also they are what is called distributed ledger ecosystems. Where let's say these two parties may have a ledger that is only for them, and these two parties may have a separate ledger. This is very useful in supply chains, because if everyone wrote everything into the same ledger, there's too much transparency. No business will be happy about that because there are business confidentiality or commercial confidentiality needs. Where organisations want to protect certain information, though they also want to claim that this, let's say, uh, if I get that copy Cuff is made out of, let's say, 95% recycled paper, that 95% recycled paper is bragging rights and that that gives you that marketing advantage. But on the other hand, you don't necessarily want to say where your paper came from, because that sometimes can be sensitive in the sense it may reveal your suppliers, because you may have a certain advantage on who is providing you things. So this is This is why, in some of these environments, everyone putting everything in the same place is not very attractive. So you have the smaller ledgers. But of course you lose some of those properties because now, so let's say how many parties we have. 120, that's not a good example. Um, OK, so let's say there are 10 circles here. Each of those are nodes now that thin, a network with thin nodes is a more robust network compared to a network with only two nodes. So let's say you have two into five versus everyone in the same network. So you lose certain properties in the sense it's not a large network anymore, not as robust as the bigger network. But on the other hand, you have better security or privacy. So these are again the trade off that people work in, and this is actually a space that I work most of the time. Like how you somehow slice and dice this information so that you have these claims like this Cup Coffee cup is made out of 90% recycled paper. But still it does not reveal certain information that the businesses does not want to reveal to the other parties. OK, don't worry. We'll talk about these things as being on now. Here's one way to classify Blockchains, but it's called permission or public versus private and permissionless versus permission. Uh, this this is coming from the IO standard definition and not not the easiest to understand, but this is this is kind of the best I have seen. Like if you if you read anything on Blockchains, you will see like private Blockchains public Blockchains consortium Blockchains and all of that different people trying to define this but this matrix at least two like these two ways of looking at this at least simplify things. So what do you mean by public? Public Blockchain is accessible to anyone. So Ethereum and Bitcoin are public Blockchains. Anyone can see what is happening on the network. So we saw what is happening on Ethereum. Anyone can start a node and become part of the network. That's a public network. Whereas let's say, uh, something like, uh, an exchange like AEX or someone like that decides to run a Blockchain to support whatever they are, trading transactions. They don't want to make it public to everyone. So that's a private network. So essentially, a Blockchain that is used by a limited set of users is a private network. So in the sense there will be some sort of access control or firewall or something like that. The rest of the rest of the Internet cannot see what is happening there. Only a selected set of individuals can see. So easiest way to remember is public. Everyone can see private only whoever you designate can see Now, permission versus permissionless is a little bit tricky. Now there are Blockchains that anyone can transact, but not everyone can build blocks. You need special permission so you, Alice and Bob can transact. But let's say Charlie and Dave are only the ones who are allowed to build blocks, so those are called permission Blockchains. In the sense they are, they require some sort of authorization to perform activities like validating transactions and building blocks, whereas permission less means anybody can do anything. So if you talk about something like Bitcoin and Ethereum, you just go and download the code. You need to have enough hardware capacity. You start running a note after about two weeks, or sometimes you can do it even faster. There are ways to do it faster. You become part of that network, so that is a public permissionless network. So what are the properties? It's open competition by the operators in the sense everyone is trying to build a block. If you are successful in building a block, you get that what is called the block generation reward. You earn some Cryptocurrency for building a block, so it's everyone is competing, so there's usually fees for using the Blockchain, and they have the greatest transparency and security. Everyone can see what is happening on those networks, and there are thousands and thousands of nodes. So it's because of that. Like, remember, I mentioned this 51% of the attack. Someone wants to change the transactions. Then on a larger network, you need massive amount of combating power, which essentially means, let's say, billions of dollars to overtake the rest of the network and do something bad. So they are very strong in that sense because there are thousands of nodes that you are competing against. On the other hand, they can be slower. So the time to confirm a transaction on Bitcoin is one hour, typically just an assumption. That is what people are comfortable with in Ethereum, it's about 7.5 seconds minutes, not seconds. On the other hand, if you look at something like this quadrant private and permission so open to select a set of individuals and only subset of those individuals can perform certain actions. So they did require preauthorized operations. They are easy to regulate because you know who is transacting, who is doing what. If they misbehave, you can take them to the court, at least because you know who they are, whereas, let's say 10,000 noes in Bitcoin, We don't even know where they are. Um and they give you the greatest privacy because it is for selected few. Not everyone see what is happening on that space. Then there are a bunch of Blockchains here that are public but permission. So this means anyone can transact like S like stellar and things like that Anyone can transact But only selected set of nodes can validate those transactions and build blocks. Maybe I should go to the next slide and come back. So Bitcoin, ethereum and algo run public permissionless Anyone can be part of the network and run a note. We will talk about hyperedge fabric in the class, Not so much others. So something like hyperedge fabric is what is called a private permission Blockchain selected set of organisations or one organisation, different departments or something like that. They can run a Blockchain and there are very clear guidance on like who can do what on that sort of a network, then things like hedera ripple, avalanche stellar All of those I I think ripple there can be anyone can transact only 100 knows that is approved by the ripple. Whatever management organisation, I'm not sure what it's really called. So there's like a consortium, not not a consortium, I would say an organisation that is taking care of ripple. So only 100 nodes that are approved by them can validate ripple transactions and build blocks. So this is slightly different model. It's public anyone can transact, but only a few nodes that are designated by a certain organisation can build blocks. On the other hand, if you just take the ethereum source code or code and just run in your virtual private network or in your organisation, that becomes what is called a private permissionless network. So let's say you deploy an an ethereum instance with finals. So it is. It's a private network because it's not open to the rest of the Internet. But there's no concept of permissions and things like that. All those five notes can build blocks and validate transactions, whereas something like hyper fabric is a little more complicated, because even though there are five nodes, you can even say, Oh, only these three out of that five can build, uh, like valid build blocks. So this is this is why this is done is organisations have various reasons to do certain things in certain ways. So so coming back. So the simplest way to remember this is private permissionless means anyone can join and anyone can do anything. So public permission list. So then public permission means anyone can do send transactions but only selected notes can do things like mining private permission list. Just take a permission like private public Blockchain and just run it on your local network or whatever your network And don't open it up to the rest of the network Rest of the Internet. And then this one, the last one, the private and permission Uh, so you just have a network that is yours. But you also have full control on who is doing what. So this is the most open but not very good at in terms of privacy and slow. These are fast, very good at privacy. But they're not very open, and these two kind of sits in the middle. So because these are using preauthorized operators, they are definitely faster than these ones. So that is why, like stellar avalanche, they are able to process more transactions than Bitcoin and Ethereum. Any questions?

SPEAKER 3
Yeah, OK, 34.

SPEAKER 0
They can do anything depending on what is hard coded in the sense What is coded into the code? What does the software says?

SPEAKER 3
Yes, yes.

SPEAKER 0
So what happens is if any of those 95 try to build a block, the rest of the network will not consider them. Essentially, they will ignore them. Yeah, So it's like everyone has a white list. Whoever built the block is not in that white list. They are gonna ignore that. OK, so, uh, I hope the next couple of slides will help you understand some of these what we just discussed. So the goal is to replace this centralised trusted party with a set of notes. And why don't we? Why? We don't like centralised trusted parties because there are enough examples of the manipulating the system. They had too much power, so they tend to manipulate their single point of failure and they lack transparency and they lack of transparency because that's what allows them to manipulate and charge higher fees. So what with Blockchain, we are not going to trust a single node in this network. We don't trust any of these single node individual nodes. But we trust the collective. So how you do that is let's say there are 100 nodes. We're not going to trust any of those individual ones. But each of those remaining 99 can double check what that other one did. So So what happens is we establish a trust from replicating the data replicating the transactions, but most importantly, by cross tracking each other's work, is this a very efficient way of doing it? No, because whatever I I do need to be double checked by everyone else in the letter. But why is that important? Why should everyone check whatever I'm doing? Yeah. Yeah. So you should not trust me. You don't want to trust me. So this is the cost of lack of trust because you don't trust someone. You double check everything whereas like think about real world even like when you build trust with a friend. After a while, you don't worry about certain things. You just let things happen. But when you don't trust things, there are always various guards and you want to make sure things are OK all the time. So this is a lack the cost of not having trust is you have to double check everyone's work. So this is why I'm saying like Blockchains are not efficient. But on the other hand, it can work on an environment that you don't need to trust others. You don't even need to know who they are. But centralised systems are far more efficient because they belong to a single organisation and that organisation has full control, so they don't necessarily need to do like if someone updates the database, they're not gonna go and verify that was that update really valid except the fact that whatever the database authentication was correct, so remember this. We don't trust individual nodes in this network. It's just that collective behaviour that we code into a programme that allows us to have this behaviour that we double check everyone and make sure everyone does the correct thing. Now this is not easy, and that is actually what I'm going to talk about in the next couple of slides. So let's say we have a ledger. So there was a question like, OK, here's a simple legend. Let's say Alice has 500 eater. That's quite a lot of money but let's say it's Bob 1000 Charlie has 500. But these ledgers, particularly with like the second generation Blockchain, can be used to record other things. So for an example, there are enough applications on using Blockchains to record land ownership. So, for example, Dave owns whatever the plot number at Zip code 2115. So this is just ownership of land, or they are used in many supply chain scenarios. So let's say, uh in there is mango may, uh, grown in Queensland and that is, they claim organic mango. And so they have a organic certificate number something like that. So Blockchains can record other forms of data not just, let's say, some sort of Cryptocurrency ownership. Now what happens here is in a in a typical Blockchain. You ended up replicating the ledger on each note. So let's say this used to be the conventional centralised database. Now we go into a paradigm like this where everyone is keeping everything, and any updates to one of these copies are being double checked by the other two copies. But then there is this term called the Replicated versus distributed. So here's a replicated ledger where the same ledger exist in three places. Whereas this is a truly distributed one in the sense, not everyone has exactly the same thing, but there are duplicates. So, for example, this land ownership is recorded in two places because if this node goes down, at least you have this copy. But that does not mean that everyone must record this one. So, for an example, like, uh, if you if you record everything that is happening in Ethereum, that's about seven terabytes. Will it be more than that now? So you don't want 10,000 nodes in a network to record that same 7007 terabytes? But that is actually what is currently happening. They want to go here. But that is hard, technically hard. We will briefly touch this. Why? This is hard, but this is a better design because you're not gonna like everyone is just not gonna spend seven terabytes just to record the same thing. If you had 10 copies of, let's say, Dave's land ownership, that's probably enough. As far as that is replicated across the globe. As far as one of those 10 is up and running, you still have it you don't really need 10,000 not to do this. So the takeaway here is Most Blockchains today are are replicated. They're not truly distributed over what is called Chardon now. So let's say there are three copies here and Alice is doing a transfer to Bob. So, Alice, can you record this transaction and initiate this transaction on any of these three copies and say I'm gonna transfer 300 litre or whatever to Bob? So when you do this transaction, you send a message to Bob. Let's say this is Charlie. You send a message to each of them and they should update the account balances. So this goes back to what I said earlier. Like when you when you change ownership as part of this transaction, what happens is you deduct 300 from Alice and you credit that 300 to Bob. So this is the the happy part when the sunny day scenario, when everything works well, only thing is, if you happen to have 10,000 nodes in this network, you need to have 10,000 arrows in the sense this transaction need to go to everyone in the network. Now, networks are unreliable So there are instances that while Bob got the transaction, Charlie may never get the transaction or at least thought for a long time. So this lead to an inconsistent ledger. I haven't updated Alice one, but this can be very easily updated. So Alice and Bob remember, like has a certain ledger state that is inconsistent with Charlie. But we still have majority. We have two third majority if I update Alice Ledger. If Alice behaves correctly, at least two of the copies out of three has majority. But the thing is, when you have more and more notes, things like these are gonna happen more frequently, keeping up like think about like if you want to synchronise your tablet and the laptop or the laptop and the desktop is not easy unless you rely on let's say, onedrive or iCloud or something to do things. If you want to do it, manage yourself. It's a hell. But think about like keeping this sync across 10,000 notes. That's far more complicated than that. So what else can go wrong? So these are our concurrent transactions, in the sense at least, initiated a transaction at Time 10 and say I'm gonna transfer 300 to Bob and Bob gets that. Let's say after three times steps like three seconds, three milliseconds, three, whatever you wanna call them. But it takes some time because maybe the network connection is slow, slow or something like that. It takes some time for Charlie to get that. But now that Bob has enough money, Bob does another transaction immediately after that. And in a global network like Internet, it is possible that while this part may be very slow, this path could be fast. So Bob and Charlie has a fast connection, though Alice and Charlie does not do, do not. So in that case, what's gonna happen is Charlie would look and say, Oh, you don't have 1000 200 in your account. So I'm gonna reject this transaction. Alice and Bob will be happy because there's enough money to do that transaction. So Charlie is not so you could lead to an inconsistent ledger because of these kind of issues as well. And again more notes that you have more transactions that you have in a network. These kind of issues are going to get worse. But the bigger problem is Alice can purposefully lie. Alice can go and say, Hey, Bob, I'm gonna transfer 300 to you because you have 500 and go and tell Charlie Hey, I'm gonna transfer 400 to you From Alice Bob's point of view, that transaction is valid from Charlie's point of view. The second transaction is also valid unless Bob and Charlie talks to each other at some point to figure out Alice has been more asset. Or, let's say, more Cryptocurrency than what she has. And doing this on a distributor network Digital Network is much more easier than when you have, let's say, $500 in notes. So this this was the main problem that Bitcoin was trying to solve. How do we prevent someone like Alice from double spending money? So she had only 500 but she has spent now 700. So how can we solve this problem? Not just one problem. I talk about few like lost packets or lost messages, reordered messages and, more importantly, someone like Alice trying to double spend. So what are some of the potential solutions to deal with these kind of problems anymore? Sorry, have to right Yep. So you go back to Oh, you, we we We follow the standard approach, having a centralised third party to mediate everyone's transaction because that Central Party will see at least is trying to double spin. And it will allow the first transaction to go ahead. But not the second one saying, Hey, Alice, stop. You don't have enough money. That's the solution. What else can we do?

SPEAKER 2
Allow some time?

SPEAKER 0
So yep. So waiting some time. The question is, how much? So what's a good time? Five seconds. Half an hour, three hours when 50% of the network. So OK, so what is the 50% of the do we know how many nodes are in Bitcoin or Ethereum at any given time? So counting on a distributor systems is a very hard problem, because nodes always come and go, and you can never get an exact idea. But you can get a decent idea to say what is a good 50%? So let's say, if you know, maybe there's 10,000 plus 4000 plus is probably more than enough again. The question is, how do you know that old 55 5000 got the message or something like that. But that's that's the way to do it. Centralization is the way to do it. What else can we do?

SPEAKER 2
Yeah, bye Like. And more acknowledgement.

SPEAKER 0
Yeah, mhm.

SPEAKER 2
At least a cow. And meanwhile, the system will talk for Ali. Do not make any transaction and after can receive a message. Mhm, he said, Yeah, so?

SPEAKER 0
So what you are talking about is some sort of a serialisation where you send the transaction, and then there is a receipt or some sort of an acknowledgement. Until that is agreed by everyone, you don't move on. So there are a bunch of solutions, but most of what you said will belong to probably two types of solutions. One is some sort of a limit on concurrency. Some sort of serialisation or the other one is based on some assumption about time now, why? Serialisation is not good. That reduces what is called throughput. What is throughput? Sorry. Information that Yeah, that's for me to look at it. If you give a simple definition of throughput, would be whatever the number of things like in this case like transactions that you can process per unit time When you make things cereal, you cannot do a lot of things at the same time, essentially one thing at a time. So you reduce the throughput. What's the problem with time? Yeah, uh, so So, to estimate you need you have to have clocks and your clock and my clock doesn't run at the same rate. Even if two of us let's synchronise our clocks now, after some time, we will be out of sync. So that is what is called the drift and the skew drift in the sense every clock runs at a slightly different rate. So after time there is a drift and drift in your clock versus drift in my clock leads to what is called Q. So let's say my one runs faster. Your one runs lower the gap, tend to increase with time. So because of that, in distributed systems, we try to avoid use of physical time simply because we cannot keep this clock sync all the time. Even if they are synced, they are always gonna be a little bit off. Think of like a first person shooter game. If you can set the time on your console to yesterday, you will always be the first person to shoot. That's not how those games work. So they don't rely on the senders time stamp they just rely on when you press the button on your console when that message is received by the game engine. So we generally in distributor systems, we try to avoid the physical time simply because we can't rely on that. Otherwise, if you allow people to do that, they can easily game the time. But going back to this problem now, we know that, uh, maybe this one or the next one is a good example. Maybe this. OK, so there are two transactions. Can at least one of these be valid? Yes. Which one? Anyone doesn't matter. Only thing that we need to prevent is both from happening. So if you put them in some sort of order, that one will go through, other one will eventually won't go through because there's not enough money. So even in this one, if you get the order right in one case, one transaction is gonna fail. Other one is gonna be successful if you don't get the order right. If you get the order right, both will be successful because when Alice transfers 300 to Bob, Bob can also do that second transaction. So what we really need is a way for the entire network to agree. This is the order of transactions rather than say, this is the first transaction, that is the second transaction. So a simple example would be think about like, OK, um, you are going to withdraw some money from an ATM at the same time bank back office system is trying to give interest to your account. You will probably be happy if the bank gives you interest before you debit. If you take money out of it rather than you take money out of it, then bank gives you interest because you get a couple of cents more. Maybe, But rather than worrying about the sequence of those two possibilities, what you need to make sure is particularly even in a centralised system like this, both the replica and the master need to agree in which order you are going to process those transactions. Because if one replica process, let's say interest and then did up because you're gonna withdraw money, another replica first deduct money and then give interest. We have an inconsistent database because one instance has more money simply because you got let's say interest for $500 more. Whereas the other database instance has less money simply because you deduct the 500 before calculating the interest. Um, let me see. So this is what I'm saying. So let's say you had fine. No, no, I bought Mark. Uh, maybe I have. So let's say you're up now. So in one case, let's say you have this much and let's say you got 0.1% interest and then deduct 500 whereas in the other case you have this. Deduct this and then give interest. The problem is, if one database copy runs this, the other one runs this you have an inconsistent database. What we just need to do is, well, you're not going to fight with the bank or the bank will be happy with this one. What matter is all of those copies have the same state. So so what? What we really need is a way to put these transactions in a particular order. So this is what Satoshi Nakamoto in 2009 came up with he came up with a way he or she, we don't know who that is, came up with a way that we could do things like this on a large network, but still make sure everyone in the network agrees. What is the order of those transactions? It's not a very efficient way of doing it, but it helps to solve other problems. So this is where the cap theorem comes into the picture. So Eric Brewer just made a statement later, it became a paper, and actually a theorem say it is impossible for a Web based service to provide the following three at the same time consistency, availability and partition tolerance. What I mean by that is, let's say Alice does a transaction saying I'm going to transfer 200 to Charlie that get reflected on this database. But somehow it need to be replicated back onto this side, so all three copies are consistent at some point. But if there is a network failure in keeping this information flow now, if you go and query this database, you will see 500 instead of 200. So this is an inconsistent set of databases at this point So this is what is mean by the consistency. So in this case, we lose the consistency because network is now partition. Network connections are not there all the time. There's a connection here. There's a connection here, but this connection is lost and availability means you can access a service as and when you need it. OK, so Eric essentially said, you need to pick any 32 out of these three. If you want the network to be consistent in the presence of a network failure, essentially stop the service. So that is a lack of availability. Because if nodes cannot talk to each other now, and if you want to make sure all the database instances are consistent, you have to stop the service pretty much. You should not allow further updates because you cannot get all the replicas in sync. Another way to look at this would be you can, um, you can be available. Networks can partition as well, but you can try to compromise the consistency in the sense like we don't worry about consistency. Maybe we can somehow deal with the problem later. If you have heard of something called Amazon dynamo db 00, the database engine that runs behind Amazon, not Amazon Web services, the Amazon website. That is pretty much what it does, because Amazon, particularly during Christmas time, gets so many requests so and having multiple database replicas and keeping them consistent is hard. So their solution was like if we have 1000 keyboards in stocks, it doesn't really matter if somehow customers owned 1000 500 keyboards because different customers go to different database instances and there is a possibility that things can go wrong. Um, going back, maybe to this pickup. So one of them go to one replica. The other one goes to run replica, and eventually Amazon may have committed to sell 1005 100 keyboards, though there are only 1000 keyboards on the top, so you can solve that problem in a few ways you can back code. In a sense, you go back and tell the manufacturer I need five more keyboards. Only thing is, custom is gonna feel a little bit of a delay in delivery. Amazon Fine print says Eventually. If I cannot do this, I can refund you money, or Amazon is even willing to buy it from a competitor and still sell sell it at a lower price so that they can retain the customer. So what they do is, rather than trying to deal with this technical problem, they came up with a business solution to say there are various of ways of satisfying the customer. Let's deal with that way rather than worrying about our database being consistent all the time. Because if you want a consistent database, you need to reduce throughput because you need to see the things so you cannot deal with a lot of customers at the same time. So I'm going to look too much detail. But what you really need to understand is in this diagram diagram you generally need to decide. Either you want to have despair, despair or the pair. It's very difficult for a service or pretty much impossible. That's what the theorem says, a service to be consistent, available as well as deal with network issues. But the thing is that P is fixed for you. Global networks, like global network like Internet, tend to fail at various times, so it's like you P is chosen for you. Now the question is, do you want C Or do you want a so Blockchain designs to be available? Compromising consistency. So this is why you need to wait one hour in Bitcoin to really see whether your transaction is in the longest chain. So because on a short time period notes can be inconsistent, like my database copy may not be same as your your ledger. My ledger is not same as UM, probably is not a good example. Maybe this one, so these temporary failures are OK, but you build the network and the protocol in such a way that at least after one hour, everyone will be consistent. So these are very different design compared to typical databases. That's the take. So you have a massive network that runs across the globe. You are going to be dealing with network issues because that's not a choice, really, it's It's a part of the design part of the design, but you will be available all the time. You can access the network at any point. Only thing is, what you see now may change in a few minutes, but whatever you see after one hour is extremely unlikely to change. So how are you
