SPEAKER 0
OK, Uh, we should start. And yeah, if you're online, can you hear me? If you can say yes, that would be good. Yeah, if you're online, can you hear me? That should be OK now. Um um, can you hear me now? Um, Z, please. Yes. Yes, because, um yeah, that's great. Thank you. Ok, um so there are a few things to cover today. Uh, let me go to where we are. I just like to kind of, you know OK, so So we covered all this stuff? Yes. Last lecture we covered exceptions generics, and we were somewhere in collection. So we have still finish that example. And in a way, that last example really, uh, highlights many important points, OK? And so I'm going to finish that. And in that we'll discuss a few points. It does cover how we can use genetics, how we can write Softwares which are easy to maintain. It has got some very nice characteristics which are quite useful. It communicates to us how we may go about designing Softwares. Very simple example. But there are a lot of things you should observe there, and then we will just skip this we skip design by contract, so it's a rather simple concept. I'll quickly go through that. It's an important one. And then we go and talk again briefly about J unit testing. You know about testing in from 1531. But with respect to Java, what are the differences? That's all we're going to highlight and then we'll jump to design principles. OK, we'll see what we can cover there, but we should be able to cover most of it. So there are a few things to cover and again reminder that please start working on the assignment. If you have any questions, please post it on the ad forum or go to the help session. There are many health sessions out there, so if you need any help in clarification or anything, please go there so that that's where we are now. So with the collections, we kind of briefly mentioned that Java has got many collections already implemented, which we can simply use. So the example we were discussing was the customer, uh, implements a comparable interface, which is also a generic interface. So the type T is replaced by a customer, and but the com comparable interface indicates that you must provide a method which, basically compared to the other object, OK, and why this is all useful is because when we go and use it and this is all we discussed last time. So I'm quickly kind of repeating that here. So when I create a three set, it says, Well, you can only provide me elements which basically implement that particular compatible interface because implicitly what it is telling is that those elements will have compared to method which it requires because it is a ordered structure. Otherwise it will not compile. It will not run. So then we went ahead, and if you remember it somewhere here, we basically said that. Look, if you go to the collection method and study, yeah, so we said, Look, collections is actually a A class already available in Java, and it has got a static method called sort, so I don't need to create any object. I can simply go and say collection dot sort because sort is a static method and it says that you give me a collection. In this case, it's in a list tomorrow. It could be whatever collection you want and, uh, it will take that collection and it will sort it. And this is the example I'm talking about. It says, Well, I'm going to sort it. But if the collection is of type integer, integers are compared in a particular way. Strings are compared another way. In this case, customers needs to be compared in particular ways. So you see, the sorting algorithm doesn't have a mechanism to compare to elements. But everything else is there because everything else remains the same. So when you're designing your software, so what things change, what things don't change. And if I if I observe that, can I put those things not change in one class or at one place in a simple language, but generally one class and things that change I provide that in the right way is that I use Is there a relationship? Has a relationship whatever. So the idea is that those things change. I only need to go and change that one part. That thing, which doesn't change, remains the same. I don't need to touch it all the time I can implement that test so sorting algorithm is already implemented, and he says, well, But one thing it doesn't have is how to compare to elements. And he says, Therefore, whatever collection you give me, those elements in the collection should have implemented compared to because I will use that method to compare two elements. And remember that compared to math, says, if there are equal zero, if it is less than the next one, it is minus less than zero or greater than zero. So that's the definition of the compared to. So it gives you all possible ways to compare to values. And it says that it is our responsibility to implement that compared to which follows the natural order. So what is the natural order In a simple language? It says that, yeah, what is a natural order? So the compare to method if you if you read that API, which I showed you yesterday, somebody was saying you like. We don't do this because we use normally comparisons which are already implemented in C or now Java how to compare to in teachers. Now we just use that operator how to compare to strings. We just use the corresponding library we haven't implemented. Compared to so what is important is when you when you implement compared to method is that you should make sure that it preserves the natural order. And it is it's a rather simple concept, but the name is a bit more fancy here. So the the natural order really says that what and and this is important to understand and remember because if you don't do this, you may have problem. OK, so Natural Order says basically that says that if a is equal to B and if B is equal to C, that means a should be equal to C. Makes sense, OK similarly it would say Well ok, If a is greater than B NB is greater than C then that should imply that a is greater than C. That deputy got it same thing vice versa All other things you can consider if he is less than BB is doesn't C then a is doesn't C and so on and so forth. Now it is obvious but make sure that is true when you implement that compared to OK, so if the object you're dealing with is complex, you may not satisfy this criteria then the behaviour of sorting algorithm would not be as expected. OK, so it's simple, but make sure that you you you you realise that all these natural orders are preserved. OK, so now once that's outside the way. So basically says this will simply sort it. So this example is a very good example where we are providing the way to compare two elements. But how to sort is part of the algorithm. That's what I'm trying to highlight here. OK, now the issue with this kind of example is that now my class customer may have one type of comparison. But you see, I may want to compare once on the postcode once maybe on the name or some combination. So the way I compare to customer well, sometimes I want to order them on on the postcode or the name or the rewards point or the combination so and so forth. So I only have one implementation. So it's it extends that idea and then says, Well, ok, it also has. So this is what we're talking about. It says it also has got another approach which basically says collection short. Now you see, there are two arguments in Java method signature therefore, is not only the name. It's actually number of arguments and type of arguments. They should be all unique. So this sort method is completely, I mean, not completely is different to the previous one. OK, but we kept the same name where we are doing more like a method overloading because it does do the same thing. The meaning is the same. Like my ad. Here it is sorting it, but it will look slightly different to the previous one. So what is the difference here? It says that you give me the collection now. It is not going to look into this element for comparison method. But it says you give me another object and that object is only going to tell me how to compare two elements. So the the logic to compare two elements now is not part of these elements, but is in this object. Why we do that? We do that because if I want to compare based on the rewards point, this object will have that logic. I can create another object where I compare two customers based on the name third object, compare on some other criteria so I can now use the same sorting algorithm the same collection. But by just providing different objects which provide different logic to compare to elements. I can sort it differently. I can sort on the name. So now the sorting the comparison criteria is even external to the collection. And the logic to sort is not in any of these two is part of this. What's happening here? There are three things we are doing OK and they all are such that I can bring them in whatever sequence I want. I can put them together so I can take any collection here. And I can just create the corresponding object which only has got one method implemented. I'm going to show you show it to you very shortly and it just uses that. So it's a very easy way to put something together, change the criteria, how to sort so on and so forth. Not difficult at all. Easy to reuse, Easy to extend. You see all these characteristics. So this is already a pattern which we are going to touch upon later on, which is already implemented as part of the collection. So then you must be wondering what is this object now? I skip that first line here. So this object basically says My compare. It says that it is an object of this class Now What is this class? It says that this class, if I go here, I've just implemented it implements comparator. Now there is another interface which is very similar to comparable. Just the name is different because the definitions are slightly different. It again same thing Parameterized. And it says that any comparator is an interface and it has got only one method like comparable. It basically says Compare. And it says the compare method will take two objects again, it's parameterized, as you can see T and T. So it says I'm going to take two objects and it will compare same thing. It will return zero. If they are equal, it will return less than zero If first one is less than the second one greater than zero if the first one is greater than the second one. Same logic. But now I got 22 objects, OK, because in the previous one it was comparing given object with the current object. This one says, Give me two objects I compare to give you the answer so it's completely external. It's not even connected to those elements, though. And this is great because now, as you see, if I provide this, it will compare on the rewards point. If I provide some other logic, it will use that so I can create many such classes, and each class will simply give me a way to compare to customers. That's it. And I can create the corresponding object and provide. Is it clear to you? Does it make sense, Yes or no? Now, this is the traditional way of doing it, in which I say, if you look at this, uh, this interface, it gives me that one method which I'm implementing so I can keep on creating new, different classes, uh, which have provided me a different way to compare customers and can create objects from that. Now that's very good. And then but then say, But this class is very small. Can you see that it's just one method that's it does one matter. So you do. You do that, and that's one possible answer, and that's pretty good answer. But there is a bit of overhead. If you want to think that I need to go and write a separate class, and all it does is just give me one method. That's it. So in the early so Java has got something called anonymous classes not used that much. But I'm I'm going to show that to you. I just, uh, got a page from the Java tutorial. No, no, no, no, no. OK, um I thought I opened that page. Okay, let me see. Java is the official tutorial. Um, I think that should basically get there. So anonymous classes. OK, so you can as an official tutor, you can go through that. All I say is that it's not used that much nowadays, But in case you want to know but example is here. So I don't need to kind of create another example here. OK, so it says that all it does is that here is an interface. It's a very simple interface. Hello world. It has got two methods. Greet and greet someone. Just a simple example. Now it's like interface. Comparator. Also, it only got one method. It got two methods. It's an interface, remember? But it's not a class Now. What I can do is that I want to create an object which is of the type hollow world. So then what I need to do Technically I need to create one more class which implements this method and create an object of the class. But instead of defining that class can anonymously create at class. So you do like this. You say new now Hollow world is an interface. But you say I'm create want want to create an object of the type hollow world. Remember? Hello World is not a class. Hello World is an inter interface. So this is the way you use anonymous class. So now I'm declaring the class on the fly in creating object of the class because I only need to use that one object. You know I'm not going to use multiple object If that is the case. So then I say, Well, where is my class definition? Which class implement this? I said, Well, I'll let you just know here. So this is the anonymous class in this class because it's implement this interface. It provides these two methods. Can you see that method? One method too. So this object has got two methods. One is here. One is here and it is of Type Hollow. I can do the same thing another hollow. But this time my class definition has got a different implementation of them so and so forth. So this is only useful if you are not going to create object of this particular class multiple times. If you're creating many times, then you don't want to keep on writing this many times, OK, because that's more of a reputation and you don't want it. You want to create a separate file and get objects. Just traditionally we do. But if you are just one of creating an object, you may do something like this. So that's called anonymous class. But recently Java introduced something called Lambda expression. And so Lambda expression is super good because you don't need to do all this. This is very verbose. Lots of lines you have to type so later on because we haven't covered lambda expression right now. So later on, we are going to cover Lambda expression and we are going to cover all these files here. Can you see that here And they will allow you to write this matter which compares two elements on the fly in case you're interested? Um, yeah. So you can literally do I mean again. You may not understand this, but you can just write like this, OK? You may have seen a cross compared, and I I'm simply, um this is an example of the anonymous class anonymous class. It's a bit slow here. I don't know why. Yeah, Anonymous class. So sorry. Yeah, So I say new competitor. So that's an interface implementation. This is my compared definition. So this object has got this compared method and then I say now, I can also have sort method attached to that particular. So that sort method is available in many ways. OK, in this case, the sort method is available through the collection also so collection sort you can use that. And I gave these objects so it will use this object to compare to elements I can also do collection dot sort and the collection that also will work in the same way just a different way of approaching the same method. So that but again this year I had to type so many things here Now again, next thing will not be available. I can do the same thing lambda expression just in one line. So this is actually implementation of that method expressed as a lambda expression. So increasingly, I mean, you can use all of them. You can have a separate class, you can have anonymous class or lambda expression. All will do the same thing. So we will touch upon lambda expression later on because we need to cover a few things and then I'll explain How do you realise that? Using Lebda expression. Ok, so that's the end of that collection. Any questions? Please ask me. Ok. No. Um Ok, now let's go to, uh, design by contract. So what is that? And you know why it is useful, so designed by contract. OK, so generally speaking, we are used to writing defensive. Um do sorry. Do defensive programming. OK, so what we are really saying is that generally we do that. So hang on. We write a programme, you need to kind of address all the unforeseen circumstances. What if the user doesn't give you the mark, which is valid, or the input which is valid? You know, you have statements as statements to consider if the input is not valid. Do this. Do that a certain and so on and so forth. So that's a good idea, actually very good idea. So basically it says that my software should be highly available and I want to address all the unfortunate circumstances. So if user does something or the client gives me values which are not valid, XYZ I'll I'll basically check all of them before I go and do something which is a good practise and that's what we normally do. The question now is that if I constantly do that, if I'm writing the whole programme which is of like, 50 lines or 100 lines and I'm writing the entire programme, so at the input I check it and then I do rest of stuff. So no, no problem. But when you're designing a large software, as you can see you have requirements and then based on the requirements, you may come up with different interfaces and different classes. Now they are going to interact with each other. Now when I'm implementing a particular uh class or methods in that particular class. If in that method I'm given like three parameters or three values three arguments now do I need to check it all the time, so I may write a method. Get grade. So given a mark, it gives you an SW grade. So if it is 25 it says FL. If it is 55 it says PS. If it is 99 it will say HD and so on and so forth. Now in that method, should I always check if the mark is less than zero, Do this or better than 100. Do this, or can I assume that what is Whatever Mark is given to me is a valid mark. Now, if I assume what is given to me is a very valid mark because my get grade would have a precondition. And precondition means the input must satisfy this criteria. Meaning it should be between zero and one inclusive. Now, if I write that precondition, then can I just assume it will be true? And I don't check it. That is going to be your design by contract. So you say that I have a contract with my client and my contract says that you give me valid marks, I give you great. That's it. If you don't give me a valid mark, well, then I don't guarantee anything. So this is designed by contra now. Why it is useful is because if you are constantly doing defensive programming in every class, in every method in the class, you may have so many checks. So at one time, we need to have confidence that we have checked the the input from the client or the user. And inside, we are going to make sure that the methods which are calling each other they would follow the the contracts which are agreed upon between the methods and the contracts are nothing but the precondition. The post condition we're going to talk about today. Precondition means something which must be true before you execute the method. The post condition is that if that is true, the method will lend you the post condition. If you give me the valid mark, I give you great. If you don't give me a valid mark. Well, no guarantee what I'll give you. So my contract is that you give me value bar and I give you great. OK, so it is. So the advantage of this is that the software is going to be a bit less complicated because you don't need to check lots of places, you know, and and that's that's going to increase readability, reasonability and so on and so forth. But if by some reason the client doesn't give right answer or if the precondition is not true, then you have problem, so there are two sides to it. OK, so if your software is is going to be, needs to be high available and so on and so forth, then you may want to have lots and lots of checks, and some of them may be redundant because somebody has already checked it beforehand. But I check it again. Just to be sure you can do that, it's more over it, so there are two sides to it. Lot of time. We basically are in this category because a big software has been designed, and so every method for that will have precondition and post condition. And based on that, you implement your method because you can't think of all situations where what is given to you is not correct, because then it becomes too complicated sometimes. OK, so generally so you you follow that, and so you look at API, API says. This method and that method this precondition that supposed accordingly You go and implement because remember, a lot of time you will be working as one team member and so many people are designing different classes, different methods of the same project. So all you're given is that you implement this class. It's got these methods. Each method has got pre and post condition, and this is derived based on the overall software design. So you go and implement that and test it accordingly. That's it. So somebody who designed the whole system has no responsibility to come up with this brain condition. OK, so now this idea is, in a way, came up, uh, Bertrand Meyer tossed up this idea, and it is actually not at all novel. OK, it says in business, uh, we always deal with contracts. So when you buy a plane ticket, OK, and basically you're flying from Sydney to Melbourne and you bought a plane ticket. Now this is a contract between us and the airline. The airline says that you arrive in time and you have right size and weight of your luggage. Then their line is supposed to because we paid money. Whatever, there is a contract. They are supposed to take us from Sydney to Melbourne. OK, However, if I don't arrive in time, they don't have any responsibility. If I have a luggage which is of the right size or the weight, then I may have problem. So as far as I satisfy my precondition, then the airline, the contract says, will take me from Sydney to Melbourne. But if I don't satisfy my precondition, then there's nothing corrected. So all this happens all the time. Now we are thinking of that as part of the software. OK, now these things are very simple, but, um, I've given you a very good example. So few things are repeated here, so I'll go through quickly. Ask me online also if you have any questions. OK, so every software element should be, uh, should define a specification or a contract which says again, repeating If this precondition is true, you are in post condition. The contract should address the following three questions. The precondition. What? What is the contract? Expecting what should be true beforehand? Post condition. That's what you will get. If precondition is true, the method will land you in the post condition and this is sometimes you don't think about. But it's often important what does the contract maintain? So it says that these things it will maintain it will not violate them. These things are invariant OK, so it says that some values must satisfy certain constraints and those constraints should be satisfied throughout before or after the execution before or after the execution of the method. For example, a value of the mark should always remain between zero and 100. OK, so it says that Look, maybe there is a method which deducts, marks or applies penalties. But the invariant is that mark cannot be negative. For example. OK, if that is the case, OK, you can get bonus, but maximum is 100. So often we say like this is the method That's a precursor condition and these are the invariants that these things will always be true meaning the mark is always valid mark or so on and so forth. OK, so the invariants are the one which you always want to maintain. You know, they are the constraints which should be satisfied OK, so the contract can can do the three things there. OK, precondition post invariant. It should be declarative and must not include impairment. So now when you are defining it, it's not about how you do it. It's about what should be Precondition. What? You should get the end. What should not change in a a language, not a programme programme is a logic which will realise that tomorrow that logic may change. But what we want is fixed, and generally we want to express it as precisely as possible as formally as possible and as verily as possible. Now there are attempts already to express these contracts in a very formal way, So there are formal specification based languages already the research topic here, here and overseas. Also, there was one individual here who passed away. It was quite senior Ken Robinson. He did a lot of work in that area. And so the aim at that time was that you go and you don't write programme. You just precisely define what this method should do. And the idea, technically, is that once you provide it, so you got the requirements and then you design your classes. Then you require principles. You press a button and can you output the C programme or the Java programme for you. So if I properly define it then I should automate the whole process of generating the code. The issue, then is the world is very complex and it's not that easy to formally specify and define what we want. Amazingly, it's not that simple. So they have to come up with different form of languages, some good bad families. So that hasn't progressed that well now. Still, there are advances in a small domain. We can do that. OK, but not in a in a many real world applications a large one, at least to start with. OK, some real world. But the scope is very limited. OK, so Java. So therefore we say try to be as precise, formal as possible, but we understand that it is if you get too formal, it becomes too complicated. Also now, benefits of this card do not need to do error checking multiple times, preventer and checks. Given the precondition as satisfied client expect, the output condition responsible is clearly a sign and it is cleaner and faster. These are all the advantages of design by contract. OK now, implementation issues, some programming languages now that's no more kind of use. It gives you native support. Now, this language was designed by Mayer himself and so he came up with a language where you can just provide pre and post condition and the logic behind the scene will make sure those things are true. OK, Java doesn't give you any support. So in Java we only provide pre and post condition just as a comment. We have to put that logic in it. But there is the automatic way of doing it. OK, in the absence of native programming, what we then have is unit tests, as you know, the testing which we are going to briefly cover next topic. But you know, already for 1531. So every method we know what that method is supposed to do, what should be the precondition of what post? So what we do, we go and come up with lots of taste. So and those tests will basically have different input and corresponding expected written values, and you test it. So this is how we normally realise the pre and post condition and invariant also so that test will make sure invariants are satisfied tastes will make sure that if the precondition is true, we are to be land in post condition all the time so we can go through this often. Pre and post conditions are included in the documentation as included before they should be as declared precise as possible. OK, so now just an example. And again, this is just an example from the Eiffel language which is not that much used nowadays, is that here is a class. So this is a different way of the class is a dictionary and you are given an element, for example and the features are that this is the kind of a method here. So I want to put um Element X Uh and this is the corresponding key. OK, so let me get the glasses here. Insert X so that it will be retrievable through the key. So that's key element pair. OK, that's a key element pair key and the corresponding element here. And I it's a dictionary. OK, so I want to insert this key element pair so that next time I'm given a key, I can get X back. OK, so precondition. I can just write that in. I say The precondition is that the count is less than the capacity. So in my collection, if it is an array of 20 for example, the the current count is less or equal to capacity. OK, and key is not empty. So there's a valid key there. So if these things are not satisfied, it will basically give error message. That matter will not be executed. So instead of us writing your statements, it's you just say requires and you write down what you require. Then as a post condition, it would ensure the following that has X So the the collection has got X and if you give me key then it will return X and the count will increase by one. Now, if you write it, then the language will make sure that whatever logic you apply and and whatever implementation here will at the end, this will be true and we can also say the count should be greater than zero less than capacity. It also makes sure that before and after the execution that is also true. So all the checks will be carried out So there is over it there, obviously Now, if you don't have it. Java doesn't support it. Then each of these We can do that inside our method if you want to Thank you. So this java example is that Look, it says generally we just have comments here and also the particular tag. So they will appear in the Java doc also here it basically says the parameter value to calculate the square root return is square root. OK? And the precondition is this post condition Is this so we just provided it as a comment and then we have to put the logic inside. OK, so these are just the the comments we are providing. Ok, please ask me for any questions. OK? A precondition condition or a predicted. That should be true. I've already mentioned that Ok, if the precondition is undefined, there is no guarantee of what the or the post Condition is. I've covered most of it here. OK, that OK now these are the examples here. Ok, the precondition examples OK, so I say precondition is marked between 0 to 100. Ok, so now somebody gives me the mark. Ok. Now, um, if I'm doing design by contract which is on this side and this side is defensive programme. OK, if I'm doing design by contract, you see, I don't check anything. I just say my precondition is this. And off I go and a written pass or fail because I say the precondition of anybody uses this matter must give me Mark. I'm not going to check it. That's that's December contract. OK, here. I also say my precondition is I is less than number of students and I just go and get it. I don't see what if it is out of index and so on and so forth. If I'm doing defensive programming, I would check it here. You see, that's the defensive programming, and, uh, same thing will apply for the other one and so on and so forth. That's just two examples given to us. OK, so depending you just know what is defensive programming? What is the December contract? And often in a big projects, we just say design by contract. So you you you don't care about the rest of the software. You know what this method is supposed to do and just do it accordingly. Now, just a few, uh, more cases here Preconditions. How they should behave if I use the inheritance. So it says that if there is a method, calculate trajectory and what is given to use angle theta Now that method is implemented in the superclass and the precondition in the superclass is that the A should be greater than zero and less than 90 inclusive. So that's the method in the superclass. Now the subclass wants to override that method. Override means is the same signature. I'm overriding it. OK, so we say that if you are overriding it, you can weaken the precondition. So what is what? What do you mean by weak here? Weak means that you expected between 0 to 90 Now my implementation should work for 0 to 90. But it can even work for more than that. So it's more relaxed. OK, so now this condition is theta should be between 0 to 180. That's fine. So if it is between 0 to 90 it will work. But it will also work 210. So that's good. That's relaxing it. I cannot make it stronger. This is not valid. I cannot make it stronger. So I cannot say 0 to 45 in that case, you know my my superclass says that it should work up to 90 but the subclass will only work up to 45. What will happen? Somebody gives me 60. It will not work So my contract to the clients is not satisfied. OK, so the subclasses should honour all the preconditions of the super classes. They can offer more but they should satisfy all the conditions of Superclass. Are you with me? Makes sense? Is it? Post condition is kind of in a way similar Also here also we should basically, um is a condition after the execution. So what will happen at the end of it and so on and so forth? You can read through that now what is post condition for inheritance? Same thing. OK, so it says that if my superclass has a particular post condition the subclass If I override that method must also satisfy that post condition. It must offer that it can offer something more So if the superclass says that original contract of the Superclass was to return a set That's my super class. Now the subclass I over the method I must return a set meaning a collection without duplicates and so and so forth. However, I can return a sorted set so Sorted set is still a set, but it offers something more. That's fine, but it is set. OK, got it. And the class invariants are the values which don't change. So we say like mark should always be 0 to 100. The other classic example is that age should always be greater than zero because we can't have age less than that. So it says whatever you do, OK, before you execute the method and after these values, this constraint should be satisfied. These are your invariants. OK, so class hearings are established during the construction and constantly maintained between the calls. So in the particular execution of the method, you may violate the constraints or the invariant. But before and after the execution of the method, they should always be satisfied. You may break generally, you don't want to break anyway. But after at the end of the execution, so every start of the execution of the battle and after that, after a after the execution ends, you still have the invariant satisfied. OK, uh, class invariant and inheritance. So it's the same thing. Every subclass should basically honour all the invariants of all the parent classes. You can add more invariant, but you should satisfy all the invariants of all the super classes. Simple as that. OK, any questions, guys, that's pretty much the end. So it's not a very complicated concept, but it basically tells you two things. Defensive programming, which we generally have been doing. But often we go designed by contract, meaning that whatever is specified as a pre and post condition you go from there and implement the logic. So your focus is you want to implement a method. OK, give me precondition. Give me post condition. Off you go an invariant of and then based on that, I put my logic. And then importantly, Java doesn't have a native uh uh, checking. So basically we go and design unit test based on preposition and the invariant. We design lots of tests and test your implementation. That's summary. Now, if you subclass honour all the preposition and invariants of the superclass, that's summary. You can offer more, but not less. Ok, Any questions online? If not, um, we're a little bit behind, so I'll just move on to the next one So the next one is J unit, which should be not that difficult. You have done testing before. So again, let's go. And then we jump to design principles and then refactoring and design patterns. That's where it gets more interesting on and on. These are the topics we are just covering. Um, not difficult. You can even read those slides or follow from that. But we we just briefly discuss that if you have any questions you can ask me. But they are important but not complicated to understand. So J unit testing. OK, now, testing you have already studied extensively, understand? In 1531. So my aim is not to tell you what the testing is, but it's just in Java how we do that. So they're different testing now. As you realise, there are different layers of tasting. The most outer layer is the client expectation Visit acceptance testing. So this one OK, eventually, when I deliver my software, the client needs to use and approve my software. So that's my client testing now, Based on the class expectation, I'm going to design my system so it gives me requirements. Document gives me system testing so at the end of the day, system should behave like this. Now, to get this system testing, I will create a system in which I may have many different components, like different classes, they will interact together. So then that gives me integration testing. So you basically go from the higher level testing to one refine one refund. The focus of this course is that and from integration, you So you will have many, many different class and, uh, methods in them. And then you will basically have unit testing for every method and later on, you can even have unit testing for every class and so on and so forth. But let's focus for every method here, a unit here is generally a method. So the idea is that and again, a method knows, you know, the precondition the post condition invariance So now and you know what it's supposed to do. So now you can write a test for that Now, the important thing is that unit test is also very useful. When we do refactoring task, refactoring means you have a software which is already running. There is no bug in the software, and we're going to. That's the next topic. OK, uh, one of the next topics. So it is doing what it's supposed to do, but the software is is is very rigid. It is very difficult to change. People can't understand. So you are just changing the design of the software internal. But external behaviour remains the same at that time. Unit testing are also very important because we want to make sure that if I change anything in my software, I run all my test to make sure that my behaviour external behaviour of software is still the same. So unit tests are extremely important, as you have experienced in your previous course. Also So we are focusing on unit testing, particularly J unit Java unit testing with respect to methods. Jared is a very popular testing open framework for Java programmes. OK, and the most popular idea is we already integrate that is available as a part of that. Now the basic terminology Now again, the concept of testing don't change. They are just going to go through how you can realise that in Java a test case, what is a test case? Well, it is a thing but a class everything in Java is a class. OK, so if the class, uh, Java class containing test method is called test uh, case and the way you do that is test method, a method that executes the test code. It is called test method and you a a noted that with this tag. So if you put this tag in front of a particular method and we have examples coming, well, that becomes a test method. Simple. It's not very complicated, OK, and a test case is nothing but a Java class which has taste methods. It gives you many asserts. OK, uh so like you have used asserts in C now asserts in Java is also available, but generally that's disabled. But they will give you rather, uh, useful way of writing, Different asserts. And we'll go through some of them which are quite useful to make sure that everything is happening as we expected. And a test suit is nothing but a collection of test cases, test cases, nothing but Java classes with test methods. OK, now the best thing to do. It's just to go through this example and then I have appointed to a very good tutorial online tutorial. Very popular one. And, uh, I'll go through that briefly. But you can also go through that and it gives you lots of good examples and how to do it and so on and so forth. OK, so what it says is that here's a class. OK, it says a test. This is a class now, I said, This is a method test example usage. Whatever method is there doesn't return anything. This that means it's my test method. OK, now what I'm doing, I'm creating a new pizza forum with particular OK now assert Equal is part of J in it. OK, what does it do? It says that you execute this and that should be equal to this value, so as equals. Simply compare these two and they should be equal. Then it's fine. If not, it will give you a corresponding error message that just compares two values. That's it. Now these values can be whatever these two values two strings or numbers or whatever. OK, now we're doing something here. I create a publish this particular message. It's my new threat. What about now? Assad True says that execute this statement. Whatever statement is given to you here and that should return true then no problem. Now you can write this statement. This is just one example but tomorrow but it should return true. That's it. Now, in this example, what we are doing is that I want to execute the logic. Here is the following. OK, I want to execute this OK? And so I said I'm going to call this method and it should return an array of strings which with these values now that's what the expected answer is. OK, so I am creating a new array of string with all these values now in the class array, there is also method equals that compares this array with the array written by that. And if they both are equally to written through otherwise false. So remember that a cert basically says, Give me whatever expression you want to give me. I will execute that If it is true, then it's fine in this case. It also shows you that there are a lot of things available already as a part of Java. So there is one way I can compare two arrays by I don't need to go through myself to do that. I can also write method to do it. But we can just use the existing method which compares the written by that with the array here. OK, these are set equal is a rather simple one. It says that the user is going to go and call that method and it should return five. They should be equal OK, otherwise it's going to be false. So they are simple about doing it. OK, so there are many ways and different asserts available. Uh and you can go to the tutorial and see many of them OK again assert equal. As you can see here I execute that method and it should return this it should so and so forth. Now, of course, the interesting thing is that Java also has got exceptions, Remember? So he says that you know, if something is not right, he's going to throw exceptions. So I want to check it. Is it working or not? Let me open a file and file is not there and I want to make sure it through exception. So it says that look, there is another assert for throw. So it says that if you and again You may not understand this because this is in Lambda expression, which we will cover later on. But basically it says that if you execute this function, then it should throw this exception. So this is the class then. So you should throw object of this class. OK, got it, That's all. If it doesn't throw, it will give me error message, he says. Sorry, it's not correct. So I'm expecting it should throw because I want to test both ways and vice versa. Assad does not throw. So in this case, it says, Can you execute this method? So you say OK, just go and execute all these statements and none of them should throw any exception. So there are a different way you can assert What? What? Your logic. So again, this is a bit bigger. One asset does not throw us. Just carry out all these steps and you should not have any exceptions coming out. If it is, then let me know because there is something is missing here. Something is wrong here. Does asset equals call dot equal for us, so asset equals No, no, no asset equals simply equals those two methods. So assert equals. No, no, that simply compares these two. The question is, that does assert How does it compare to values? Does it compare using the equals of the object? Or does it use double equal to so answering a question it will use double equal to So you just comparing two objects and it was me. So, uh, so the question says that Is it using this equal to or it uses that equals method. Remember that there's equals method in every object. Ok, that method remember that thing equals matter. He compares two objects. So the idea is that no, it uses that now. If I want to use these equals, then I can use as a true and then I call equals me. Example is already here. See, here it is using equals method, which is part of the array, which is different to our equals method. This equals method compares to arrays and returns True. Got it. I hope you got it now. Yeah, that's right. That's exactly so. That's an example already here. Your question is answered here. If you want to use equals method, then you use call set to Yes. What is that? Yeah, so it it will print error message. It will tell you that these are such fail and description with that. Like Yep, yep. So if it if there is no exception coming, it's fine. If it throws any exception, then it will tell you that this assert failed. You got it. So idea is that in this case, we are expecting that we should be able to execute this without any problem. However, if any of the statement throws an exception, then it says it should not have thrown. So So it failed now and therefore it will report to us. And so that test failed. Got it? Yeah. Any questions? Guys, please wait. But then how come a set equals it will compare to strings, mate. Yeah, it will just compare to strings. OK, but don't you need to use But it is up to J unit to test Uh, sorry comparison it So it will just compare. And in that comparing it will basically use it will compare strings to string. Now remember that the string has got I. I had this extra example for the string, so the Java deals with strings in a slightly different way you know, uh, constants and otherwise. So in this case, it will compare two strings. So it will say that means it has got the same characters, if that's what you're asking. Yeah. So String is a unique situation because Java has some peculiar way of handling constant strings versus the instance of strings. OK, so answering that particular string example, I think, and again we can look into the documentation for J unit. But I think it will compare string, meaning that it will compare the characters. Liam. Ok, but for all other objects, it is going to, I think, use double equal to ok and otherwise just as a true and articles. That's the best way of going if you really want to have a full control. Ok, now there are a lot of examples here. Um and that's the very useful tutorial, So I can just leave that That's fine. It's very popular tutorial also So I think, um, I just put a link here. Uh, please go through that. A lot of things that we cover. Um, it's very popular, uh, for testing framework. Also for java. Ok, so the overview, you know, software testing, few things on that J unit five we use These are the things import. I'm I'm not gonna go through that. You should be able to know this by now is an example. They are running through the class calculator and multiply a and B. Just a very simple example. Uh, you know, now there is also this notion is that, uh, before you taste something, you want to set up some values? Maybe. And after this, you may want to do something. OK, so the J a unit also. Now, this is the package we need to input or J unit dot jupiter dot API before each. Also, there is a something called after each. So these are the, uh, methods. We are, uh, tags or whatever the methods we are importing. So we can set up things we want to do before and things we want to do after, so OK, uh, so OK, let's go through that. OK, so that's the test. I'm I'm I'm trying to get it here, OK? And that's just the name of the taste. It's just a display name of the test. So whenever you get a message, it's a bit more meaningful and the test basically is a test Multiply It is a set equal, so it will basically execute this and it should be equal to 20. And this is the corresponding method. So if something goes wrong, I want to meaningfully inform the user. So it gives you that So it's rather simple as assert equal as usual, as you can expect. Ok, OK, again There's another test here. OK, which basically is the asset equal. So on and so forth. Got it. So please, please read through that. Everything is explained here what is of the tech does and what you will get. So I'm not gonna Yeah, all of them. Ok, um now I'm gonna go to something which is interesting. OK, so these are the assert equal assert True, assert False, which we haven't covered. But you can also have assert false assert, not null assert null. Ok, all of them. Then assert throw also will be there. You can also have assert all and these are the Lambda expressions. I'm skipping them now, but anyway, we are just calling. So we are basically saying this should be equal to that and this should be equal to that you can do it in one. Go here. I'm asserting all of them. You can also define timeouts, so it should return the answer in a particular time. Ok, uh, disable the test now. This is where we just discovered briefly. And then we'll come back to this, uh, for the dynamic testing. OK, so there are different assets with respect to our, um codes, which you should be able to use go through this documentation. The other one is that so far, what it says is that you can write test. So if I want to taste multiplication, then for every multiplication I need to write one test A is equal to three. B is equal to five. A is equal to seven. B is equal to 100. So I have to write so many tests in a nature. They are doing the same thing. They are just giving two different values of A and B. And we know the answer, and we check it so often. And we use quite a bit. Here is that we can either use dynamic testing sorry or parameterized testing. Both of them achieve the same goal in a way similar goal or almost the same, they say. You can succinctly tell me what different combinations of a and B you want to give and what is your answer? And if I give expected input and output for 100 such combinations, then I can just write one method, and that method will be executed 100 times with this different a B and the expected answer. So it's called parameter Rice, or dynamic means it will dynamically generate 100 tastes. So it's a much easier way to expressing multiple tastes. That's all now dynamic requires lambda expression. So we will come back to the rata lamb or you will read the documentation. It is easy to understand Parameterized does the same thing without Lambda, so I'm going to cover that right now. OK, so let's go to the example, and that's easy to do. So again, you see this has got a Lambda expression. It's a big one, so it's a bit complicated for you to understand right now, but that does exactly the same thing as parameters. And once we finish lambda, come back and you will immediately understand, or I'll explain that to you at that time now, parameter testing. So what does it do? Let's go through example. That's easier to understand. OK, so this is just the name of the class using parameterized test. So here is a method which returns data. Now what is the data input and expected output, corresponding input and corresponding output. So what we do here is that we say multiplication, so OK, this is the input A and B. That's expected output. This is the input A and B that's expected output. So each of these calib brackets gives me one set which includes the inputs and the expected output. And so this is an array of array. So in this array, the first element is this gives me the value for the one taste. Second element gives me the value for the second taste, so on and so forth. And so what data returns is a two dimensional array array of arrays you got It makes sense, yes or no. Now I see this is not the taste, but this is parameterized taste. It's a tag here, so it will be executed differently. If it is tested it it is executed once. If it is parameterized, it will be executed for each of the parameters given. So now it says parameters like give me the data. So the next T method So So is that the values you're getting from executing this method, which is this method So it is simply returning array of array. So now the values are nothing but array of arrays. That's the way java J It works. You just have to follow the examples. OK, now this is my taste. Actually, the taste basically is a taste with string parameter or whatever like that. OK, now what it says is that this data is just the array of integer. So first time this data is going to be this second time. This data is going to be the second one. OK, maybe it's easier to do it here. OK, so so first time The data is going to be that now I create a object of the class. I want to test test. Then I say data zero, which is going to be one data one is going to be two and there are three is in this case is going to be two again. So expected is two M one and M two now all I do, I go to the tester which I created here. I'm testing. Multiply method give M and M two and that should equal to the expected. Ok, so that will be one that will be two. And that will be two. That's it. Next time the whole thing will be repeated for the next couple and so on and so forth. Ok, you can you can understand now Now, next time the data will be these three. And off you go. You can see here next time. This will be three. This will be sorry. This will be five. This will be three and expected will be 15. So on and so forth. You got it? Yes, enough. So you can write. You know this is parameterized so you can basically carry out the same testing for multiple input output. And that's quite useful in many situations. You got it. So if I get grade, I would have done it and I would have just written the array because I don't need the array. In that case, no two. Yeah, array of array. And the first element is 25 FL. You know, 55 pass 91 HD you know, 77 distinction. So on and so forth Got it. Sub. OK, that's pretty much it is. OK, so it basically again explains everything I explained in more detail here also. So that's the J unit for you. Yeah, Any questions yet? Uh, regarding J in it, It's easy. OK, but you will be using it. You may have already started using in the lab and, uh, that's a reference to it. Ok, any questions online? Guys, let me know. Now that's the Tropic wear going to cover now, which is the design principles? OK, sir, what are the design principles? Software design principles. OK, now a few things that are easy to understand but importantly, even though they are easy to understand and you may find a little bit obvious can I strongly recommend that you take them seriously and make sure that it's self fair satisfies these principles as far as possible because as I said to you before, what we are learning in this course is not complicated. But we are learning basic disciplines which we should follow. We often get lazy and don't follow them. But if we follow them, then your software would be pretty good. And there is a systematic approach. There is a black out here. So when we go through these principles, then you look at your software assignment one. Am I violating any of the principles? Can I not do something so I don't violate them? Your code will improve straight away. It's a check box. You go through them, make sure those mistakes you are not making your software is already good. You can then go and add patterns and improve it so on and so forth. But at least we don't write bad software. One thing common constant in software is that is going to change. Change is constant. Always now building a good software is all about making sure that a software does not does. What customer wants to do and ensure system is flexible, extendable, maintainable, reusable so on and so forth. You see, these are the few objectives you keep on seeing all the time, but they are quite important because the software is a multibillion dollar, maybe tomorrow trillion dollar industry. We cannot start writing software from scratch all the time. We have to reuse what we have done before, But then again. What we have done before may not remain the same. I need to add something. I need to modify something. So it's very important that our software is reusable. Is maintainable OK? It is also flexible. It is extendable. All of these are very, very important features. And what this course is telling you is that if you follow the software principles, the design principles and if you use patterns, this will become much easier to achieve. And this is essentially important. So far, it was all focused on passing that test, writing 102 100 lines of code and maybe 2521 making it efficient. And now we say, OK, these are also important. Equally in a way, a change in the requirements sometimes reveals all these problems. So when you initially port your software, it's all fine then somebody. But can I add these changes? Then you go and look at the software and it is so difficult to modify it because you did not design it properly. And what is that? We'll see shortly here. So then you realise, Hey, this is actually horrible software. OK, make sure that your software need to continuously improve or extend, and so on and so forth, so there will be change. So So it's not about delivering first, but making sure that if more features that need to be added, if there is a bug, I can do all of them very quickly. And if something is working brilliantly, I can Can I pick it up and use my new software? All these things we want to be able to do, what means why we write bad software, that the reasons are many. And it's not because we can't it, because sometimes we are lazy and we don't put attention to it. Is it because we don't know? Often it is. You are in a time pressure. You are to do something quickly. You are doing so many things. So I'm not even blaming individual designers and that a discipline approach will help you also speed up your design. When you go to design patterns, there are recipes and so you know, then you look at the context and say this is where I can use my particular pattern. It will make it much easier for to write your software because the rest of the code the structure is already there. You're just going to use and modify. That will give you all the characteristics you need as well as speed up your software. OK, so if you don't write a good software, there are so many consequences. As you can see here, design smells means bad software design. What are they when software rots means, you know, I mean, this is all just kind of a way of expressing that the software is bad. OK, why? A design smell is a symptom of a poor design often caused by a violation of software principles which we are going to cover today and has restructures in the software that suggests refactoring. Now that will be the next topic. OK, so if the software is pretty bad, it doesn't satisfy some principles or criteria. Then I need to refactor restructure my software so that external behaviour remains the same. But the software is now better than before, meaning more flexible, re reusable, so on and so forth. OK, so there are a few problems you may come across OK, so the first one is rigidity versus fragility. Now these are just different ways to express what our software what characteristics our software should have and should not have so tendency of the software being too difficult to change, even in a simple way. So if I want to change something, it becomes too complicated because I change this, then it is connected to something else that may also affect so that so simple change I want to make. So I say, Well, look, US W has now changed the marking criteria. Now it's not 100 0 to 100 marks. It is actually 0 to 100 and 50 marks. Now. Can I make this change easily? R is going to be too complicated. Example. OK, uh, and also single gene causes. Casca changes, so one change will then influence another change. So just to make one change, I have to do many, many places changes, so that's kind of very rigid. It's not easy to modify my software a lot of dependencies between different classes and methods. Yeah, that may have increased speed a little bit, but then software is tightly connected with each other, which is not a good news, but fragility tendencies have to break in many places when a single change is made again. That kind of goes to the earlier thing that if the software is tightly connected, the technical word is coupled. Then one change would affect so many places. So either I fix all of them or I break the rest of it. So either way, it's not a good news. OK, now these are just like, you know, different way of expressing the characteristic of the software. Don't go by the objectives as such, but it just tells you different characteristics. Uh, IMIL design is hard to reuse, meaning that IMIL means software is not easy to reuse. I have implemented very nice way of doing something in in one software. I interact with the user in a particular way. Now I want the same interface interaction in the new software. Well, I can't unplug it because it is actually going in accessing database in a particular way, doing XYZ. And for that I need all these other classes and other systems in place, and I can't take them out because it's not easy to do so. It's It's not easy to unplug what I need Easily we use that part OK designed parts that could could be useful for the system, but so on and so forth. OK, please go. Software changes are easier to implement OK through hacks rather than design preserving principles. So this course is how easy it is for you to go and implement changes. So if it is not easy, then it's a problem. And again, it is because of the system, meta couple and so on and so forth. All these things will be more clear when we go through examples tendency to a model to to be difficult to understand. So it's not clear what you're doing. You know, I have to read your comments. I need to receive logic flow. I don't understand exactly. Now this is interesting also is because you may not read your software after some time. Delta T, some other new software programmer, will come in your place. You may have moved out or have promoted to some other place. They need to look at your code and do something so they should be able to understand your code. And here also following design principles and importantly, using design patterns is extremely important. And I'll explain that to you because once you use design pattern, it is much more easy to document what you have done, and the reader will immediately say Ah, that's observer pattern That's a strategy pattern. So they know immediately the structure and they know what you are trying to do. And this, I think, is one of the very important advantage of using patterns. OK, and I'll talk about that when we go there. OK? Otherwise you have to express your logic. Pattern is kind of recipe and I said I've used that recipe and that recipe is known in the software world. So the new person also knows that recipe and the recipe may have 5, 10 steps or whatever, so you don't need to describe those 10 steps all as I'm using this pattern done, then you only say this type is done this way and there's two lines is you express something which is rather detailed implementation of a particular way of realising the software and everything is clear now. Now, if I don't do that, then I have to write those 20 lines what they do, how they are connected, what I'm doing, how I am doing too long. So please use patterns as far as possible. OK, so you should not make software complex, Needless complexity and needless repetition both of them. Obviously, I'm not going to say Don't make it complex. And of course, you should not repeat anything because repetition gives you redundancy. Are you with me? So same thing is done. Copy paste, copy paste, see, and then have a bug in one. Then I have to go to every other instance of reputation and modify that. So I didn't write in a method and call that method absolutely avoid repetition. Also, try to make it simpler so that easy to understand. OK, don't try to make it too complicated. Sometimes that means you may need to add some extra lines. A few lines generally nowadays. That's not a problem. We get a lot of ra M there memories there, even if you do one extra step. Generally, the execution speed is not an issue for most of the software. So don't try to make it too cryptic because that one one milliseconds you are saving Well, that doesn't matter. You should be rather writing something more easily understandable. OK, I look at the source code and AC equals, does use equals OK, Thanks, mate. Thanks, Liam. Thanks. So he says, assert equals is actually using equals, not double equals. So, uh, correction. Ok, I thought you using equal. But it is double equal. Thanks. Aye. OK, now this is the these words you will see all the time. Kate is a good design coupling and cohesion. So what we want? We want loosely coupled systems which are highly cohesive. Now, of course, what is coupling and what is cohesive? That's what we are discussing next day. Why? Because you see again the same adjectives we get all this features if it is loosely coupled and highly cohesive that you should always try to achieve as far as possible. So what is coupling? OK? So the coupling is is defined as a degree of interdependence between different components or classes. OK, so it says that coupling refers to dependency between classes so highly coupled systems where classes depend a lot on each other. Ok, and if I have zero coupling, then each class is independent. They don't depend on each other to do extremes. Now I cannot have zero coupling because if I remember writing a software, the objects of one class will interact with the other because that's because they form a system now. So I need interaction between classes. Need some dependency but their classes. But make sure it is as minimum as possible to achieve your goal. OK, so this is called loosely coupled system. So there is a coupling, of course. Otherwise there is no system, so there is a coupling, but it lose. The couple means the dependence between the class is as minimal as possible. How do you achieve this? Remember I said that all variables. We want to keep private. We want to do everything we can do inside the class. We don't want to go outside the class and ask somebody to do your work as far as possible. I wouldn't do it there and then only make those things publicly available where I need to interact or somebody needs to interact with us. So only those things are public. Everything else should be private. And so there is a coupling through those public matters, for example, but they want to keep it as minimum as possible. Everything else we do inside, that's how you create loosely couple seasons. There's one example, and many more will follow. OK, so zero coupling is is basically, you know there's then there's no system, you know, there's no interaction class, so generally we won't lose the couple systems. OK, so they interact with each other, but they don't depend too much on each other. OK, cohesion means that, um, the degree to which all elements of a component or module work together as a functional unit. So it says that you know, my class is cohesive because all the components are related to some concepts or theme or they work together. So, for example, my class provides method for a particular shape like circle. The other class is for rectangle, so they are all related to one theme or one concept, so they work together. I don't want to write a class where it is doing something regarding circle and then suddenly some other shape, or then carrying out some mathematical operations that is not cohesive, trying to do different things. So you want to write classes which are cohesive. They, they, they they are related to particular concept, and then do everything about that concept is in that class. They are not scattered everywhere. That's cohesive. Software OK, high cohesive modules are much easier to maintain and less frequently change and have higher probabilities. So what does it mean is that if I put whatever I need to put regarding circle in my class, it's a simple example of circles I give but or a student or customer. Then tomorrow, if I want to use the same student class for a software for a new university, I can just pick up that class and put it somewhere else because a everything to do but student is in their class. Customer is in their class, OK? And so I can It doesn't rely on other classes to do its work, so I can just put it in somewhere else I don't so to represent student, I don't need four more classes. It's everything in one class. Just go easy. I can put it there that also then leads to something called single. Uh uh OK, later on. OK, so do not put all this into single class to avoid low cohesion. OK, so So that's a cohesive class right now. So there are some balancing act here to carry out here, so the idea is that it should be cohesive and you want to do everything you can privately as far as possible. Only make things public where you want to interact with each other. So that's highly cohesive and lose the couple. That's what we want to achieve all the time. OK, any questions? Please ask me. So now and applying data is the key to creating high quality software. OK, so far, you must be thinking, OK, we are all this conceptual stuff. We are going to go very quickly to actually going through examples and then we go through Refactoring. Actually, you will see the first version, the last one and how we improve it. And refactoring is also one of the tasks in your second assignment and you will really, at that time appreciate the the the design principles and the patterns how valuable they are. Design principles are key notions considered fundamental to many software designs. The critical design tool for software development is a mind well educated in design principles. OK, and that's hope hopefully we can achieve at the end of this course. OK, so first of all, you should have that vision. You should have that angle which looks for good designs by following design principles. OK, you should be educated and you want to go apply that basic tool or technique that can be applied to designing or writing a code which is called again the same thing. OK, so what are the principles? And let's go through the principles now? OK, so that's kind of a good software design should be highly cohesive. Lose the couple system. These are the two things will come lose. The couple is very important and it should be cohesive means that you don't want to do too many things in one class. It should be about one thing and lose the couple. That's that's a summary. So everything will try to lead to here because once you have it, then reusability is easy. Everything else becomes easier now. So these things you already covered already don't repeat yourself. That's kind of, you know, write something in a method and call it rather than copy paste, copy paste. A particular logic. OK, also don't make it too complicated, you know. Keep it simple, OK? Because it should be ridable blind, blind and so on and so forth. Now design patterns are the one we are going to discuss extensively in the later part of this course after uh, we discuss principles. Now it's a gang of four. OK, that's why it is UF. So they they published his book, which is in computer time frame bit old like a couple of decades old now, but it's still relevant. So, so good. Things last long, OK? And they have lots of patterns there and we're going to pick some of the pattern because we can't cover all of them in this course. But we all the important one we are covering in this course and the rest you can pick up easily. It's not a complicated thing to learn, but it's about thinking about design principles and patterns and use them in red context. And that's what we are going to teach you. And then you can pick up new pattern and use a new context on the ongoing basis. OK, and that's what we're going to go through. The next slide is all about solid principle. OK, so what are the solid principles here? Single responsibility principle class should only have a single responsibility. Now that for me, is a little bit excessive, I would rather say it should be cohesive and it should basically have a responsibility related to one theme or one concept. Don't try to do too many things, so just don't write one class which deal with all the shapes. For example, just have a one for circle one for rectangle because the way you do carry out tasks for circle and rectangle are different. So I have two classes I don't want to put in one. OK, this one is very important and refer to it a lot Open close principle. So what it means is that it is open for extension, open for extension, but it is absolutely closed for modification. So what does it mean? So it basically says that we should try to design classes such that once I design a class, I test it properly and I released my software. If I now I want to add new features or something, I don't want to open that class and modify it because I've already tested it. Every time I open, I have to go through the testing again, so and so forth. And it may change the behaviour and there may be bug later on because the the way it interacts with the class may change and so on and so forth. So as far as possible, don't try to modify what is already working what is already working. Don't modify. However, I may still need to add behaviours or extend my software. So can I. It is open for extension. The classic example of this is inheritance. You have a graphical circle tested, working fine. Somebody says, You know, I want to now represent graphical sorry circle which is implemented. Working fine. Somebody says I want to implement graphical circle. I don't modify the circle and add things. I would simply create a new class which extends the so I'm extending circle without opening the circle and adding extra behaviour like out colour outline, colour field colour, so on and so forth. So you're adding more behaviours or modifying it in a subclass without changing the superclass. That's a classic example of you are able to extend it without modifying the class, which is already running successfully. Open close principle. A lot of time. You don't want to go and modify something which is working but still want to add something or modify something and a lot of pattern will allow you to do that And we have some examples coming up. Lisco substitution basically says that objects in a programme should be replaceable by the instances of its subtype. So that's kind of obvious. But if you don't design properly, that is not going to be true. So what? Disco substitution says that there is a class A OK, and then there's a subclass B here. OK, so he says that the objects in the programme should be replaceable by instance of the subtype subclasses. OK, so if I have instance of a I should be able to replace that by instance of B Now obviously, because B inherits everything in a it may have additional staff. So I say that instance of a should be replaceable by subclass because subclass should offer that anyway but something more now. As you will see later on in the example, it is not always the case. If you don't design it properly, you will not satisfy liso substitution principle interface segregation principle. OK, it says that many client specific interfaces are better than one general purpose interfaces. OK, so segregate interfaces OK, so provide multiple interfaces so users can go and pick whatever combination they need rather than one large fat interface. OK, this is also important. We will touch upon later on dependency inversion principle. One should depend upon the abstraction and not the conclusion. So in simple language, abstraction means interfaces or abstract classes, but change of faces. So it says that and conclusion is basically implementation of the classes. So it says that always rely on interfaces because that will tell you the methods and what they are supposed to do. How they do don't depend on one once it may be done in a particular way next time that that may change, but what it does remains the same. That is part of the interface. So you rely on the interface, not the implementation, and interface means rely on what they are supposed to do the pre and post conditions, not how that is achieved, because that gives you flexibility that how it is achieved can be modified as far as pre input condition and invariant remain the same. OK, so and this will also be very useful. And there's one pattern called pre creational pattern, which will show you that we don't want to rely on implementation directly. Of course, we have relied because we are using them, but rather indirectly. We will talk about that. Very good example. We will come later on. OK, OK, so when to use design principles? Design prints help eliminate design smells bad programming practises, but don't apply them when they are not needed. Sometimes you know, you can write a simple, nice software and don't try to go out of the way and say No, no, I do need to use principles and then make your design even more awkward. So don't force on that. So idea, as I said to you later on, is that? Read your software. There are some checklist which tells you whether your software has got bad practises in them or not. If it is, address them simple. OK, don't be overzealous in make and and make it complicated. That's what it says now. After all this, let's go to the first design principle. OK, list knowledge or love? Demeter. So what does it say? It's very simple. OK, now you may find it rather obvious, but it's good to still kind of go through it so principle of list knowledge or love Demeter. They call it so the logic goes like this. OK, so you may have a class here. OK, now that class DEPENDS is connected to related to another class here. And that class is connected to one class here. And that class has got object of that class. And that class has object of that class. Something here, Same thing. This class may have object of that class and that class may have all these possibilities. Are there OK, now it says that if you want to interact with if you want to use information, can use information which is already in your class in your instance, or in your neighbours. Immediate neighbours don't try to get information from far So the example is the following. Ok, now let's say some data I need which resides here. Say phone number of somebody postcode of somebody Date of birth of somebody is in that class. I want to use that in this Class A Here at this point, I need to use this information. OK, what I'm gonna do now remember that my class a has object of class B, which in turn has class C class D. And that's class E. I'm just naming it like that's easy to say. So I can say in class A I have object of class. B. So I I go to the B and say, Well, can you get me information from C? Can you get information from D And can you get me from E? Whatever I get, I return it here. That will go here. That will go here and that will go here. I can get the whole thing. Is that right or wrong? Yes or no? I can get that information now. Remember that we we don't want duplicates. I don't want to store the same phone number or the same date of birth at multiple locations. So information is going to be scattered across in our network of objects. So it is quite possible that sometimes what I need is not in my class. It's somewhere else. And a better example is you will see when we go through factoring example next week. But in this example, what it says is that look, I need to go and access data far away from my instance. Now you say, What's the problem with that. It's just all the objects are connected with each other and I just go and get it. Now what? This principal says that if you have a class OK, if you have a class try OK? If you have a class, then try to only access information which is inside their class or in the neighbours. That's it. Don't try to go further apart. Depend only on your neighbours as far as possible. Don't depend far apart. So there are contradictions here, but the information is far apart and I don't want to copy it because then redundancy will create more problem. Then you are on the other side. We are saying I only want to go to the neighbours. How does it work if I go to the neighbour, I don't get information and you don't want me to go and travel long distance to get the information. So what's the purpose here? So the goal here is to say we want to decrease the dependency chain and I want to decrease the chain. So let's say in our original example here I want to access information here and information is here so I can create this long chain. And I say I'll get it like this. You there, Same thing. This will also maybe accessing information from here to here. And this may be accessing information from that to that. And this may be accessing information from here to hear, so that maybe so many parts Now you see what's happening already? Now somebody comes and there is some improvement or something is going on. So I said, Well, OK, I'm gonna go, and I need to modify this class. So you modified that class for some reason there was a bug in it or you to add something on it. Now hang on. I don't know how many classes use information in class E because there may be long pathways everywhere. So I need to do unit testing for every class because there may be some linkage far apart from coming from far. So I make change in one class. I have to test every other class because there may be dependency across long chains. How do we speak? And can I avoid that still access information from far So there is a contradiction. And so it says that Look what we do in this situation and the example will follow now very quickly. It is a very simple example. It says Look, if I restrict myself to only my neighbours means the first connection Then what happens if I modify this? All I need to do is only taste this and everything connected. And I taste that. If those two testing works, I'm comfortable. The rest will be fine. So my dependency is only to my neighbour. So if in behaviour the neighbour changes, I need to test myself. Otherwise I don't. OK, now how do we realise it? The best way to do is to go through this example OK, which is basically so you may. You may not be clear at this point what I'm talking about. So let's go through this example, OK, very quickly. Here is a car class which is a P. Sorry, The Class A, which is taking the car object and is doing something now in doing something it needs OK, so what do you have here? There's an object for car, so it says car. Uh, somebody owns the car, so a car has owner. So whenever I create a car instance the owner I store It is a very simple example. Then get on or set owner. As you can see, then, uh, the the car owner is of a person. And then what is a person? So the person is basically, um class person has got name and address. See? Name is a class Also because first name last name address is also a class because you can have a different fields in that get them and they get get in set here. And then if you say the address, for example, address has got house name so on and so forth. You got it. Can you see that? Yes or no? So now it says that if I want to do something here. So I say for some reason, I want to know the postcode of the owner of this car. Somebody gives me a car and I want to know the postcode of the owner because accordingly I want to decide my premium insurance premium and so on and so forth. So I say, Well, ok, I go to the car and that will give me the owner of the car. The owner of the card is a person, so I can Then go and get the address of that person. And in the address, I can go and get the postcode. Now, this shows me a long chain, dot, dot, dot, dot, dot dot But of course, the postcode is only in one place, so I'm not going to copy that. But still, if I use structures like this, then long chains, as I've shown before, means that anything connected could be connected to anything else. So I need to test everything across it. So how do I reconcile these two things together? So all we are suggesting is that in this class, car should only look to the neighbour. Only one connection. So can I do something like this in the car? I say I give you a method, get owner's postcode that goes to the owner and executes one method. So this also depends only to the neighbour. And if I go to the owner now, yes, Owner is a person. So the part, I think it's a bit slow. Come on. Yeah, the person here and the person has got, uh, get postcode. So it goes to the address and get me the postcode. So there's only one link it here. And if I do this then I can simply say here like string P Code two is equal to I say car dot Get and you see here, get postcode So now because I have this one linkage I can only write now it says this is preferred option because there's only one linkage now you may say Yeah, yeah, yeah, But underlying that is the whole linkage. The question is that that means I only need to go and check a particular class. If there is a modification in the neighbour, it's very subtle. OK, if the neighbour is not modified, I don't need to test my class because this behaviour of this is not changing. So I only modify the neighbour. And if that works, that is fine. So if there isn't any change in this postcode here, then only one linkage I need to test. It's almost the end of the time, so that's an example. And I'll start with another example here in the next lecture and we go from there. OK, I better stop any questions, guys. Things will get more interesting now, particularly when we finish the patterns and the refactoring and the patterns. That's where the real interest is. I can't see you on uh, Tuesday, please. Hopefully you're working on your assignment, guys. Yes, right now.

SPEAKER 1
Is it OK if you turn on the lights? OK, OK, yeah, yeah.
